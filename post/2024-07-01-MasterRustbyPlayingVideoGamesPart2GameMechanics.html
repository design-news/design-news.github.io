<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>비디오 게임으로 러스트 마스터하기 2부  게임 메커닉 익히기 | design-news</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://design-news.github.io///post/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="비디오 게임으로 러스트 마스터하기 2부  게임 메커닉 익히기 | design-news" data-gatsby-head="true"/><meta property="og:title" content="비디오 게임으로 러스트 마스터하기 2부  게임 메커닉 익히기 | design-news" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://design-news.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://design-news.github.io///post/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics" data-gatsby-head="true"/><meta name="twitter:title" content="비디오 게임으로 러스트 마스터하기 2부  게임 메커닉 익히기 | design-news" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | design-news" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-01 17:46" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-3b19b133b17efefe.js" defer=""></script><script src="/_next/static/27A9ztIgBqdXqyYJG3uHv/_buildManifest.js" defer=""></script><script src="/_next/static/27A9ztIgBqdXqyYJG3uHv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Design News</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">비디오 게임으로 러스트 마스터하기 2부  게임 메커닉 익히기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="비디오 게임으로 러스트 마스터하기 2부  게임 메커닉 익히기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Design News</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 1, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>1부를 아직 안 읽으셨나요? 확인해보세요!</p>
<p>자, 이제 우리는 Rust 로봇을 세팅했어요. 그럼 이제는 뭘 해야 할까요?</p>
<p>목표는 최고의 로봇 킬러를 만드는 것입니다. 순위 시스템에서 다른 플레이어들의 로봇과 경쟁할 겁니다 — 더 많은 경기에서 승리하면 순위가 올라가요. 이게 다예요! 덤으로 매월 대회가 열려 최종 우승자를 가립니다. 👑</p>
<p><img src="/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_0.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>멋져요! 이제 우리가 만들고 있는 로봇을 이해해야 합니다. 로봇은 빌딩 화면에서 선택할 4개의 구성 요소가 있습니다. 현재 우리 로봇은 4개의 라이플을 가지고 있습니다. 이러한 구성 요소는 아래 이미지에 표시된 대로 숫자로 식별됩니다. 여기서 0은 앞, 1은 위, 2는 왼쪽, 3은 아래를 나타냅니다. 이는 머리의 방향에 기반합니다. 나중에 머리를 회전시킬 것입니다.</p>
<p><img src="/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_1.png" alt="로봇 구성요소"></p>
<p>구성 요소 외에도 모듈이 있습니다. 이러한 모듈은 특별한 기능을 수행하여 로봇이 주변을 관찰하고 독특한 능력을 실행할 수 있도록 합니다. 실제 로봇을 프로그래밍해본 적이 있다면 센서가 세계를 인식하는 데 중요한 역할을 한다는 것을 이해할 것입니다. 이 게임은 모듈을 통해 비슷한 개념을 적용합니다. 레이더, 레이저 및 힘-필드 모듈로 시작할 것입니다요.</p>
<p><img src="/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_2.png" alt="로봇 모듈"></p>
<div class="content-ad"></div>
<p>그럼, 첫 번째 강력한 머신을 만드는 것으로 들어가 봅시다.</p>
<p>이 머신의 계획은, 우리의 위치를 기반으로 적이 어디에 있는지 감지하기 위해 레이더 모듈을 사용할 것입니다. 그런 다음 우리는 적에게 모든 구성 요소(소총)를 조준하여 사용할 것입니다. 그리고 계속 발포하도록 반복할 것입니다!</p>
<p>나는 코드를 모두 넣어둘 것인데, 한 번 살펴봐 주겠니? 러스트에 완전히 처음이신 분들은 조금 무서울 수 있습니다. 하지만 우리는 모든 것을 살펴보고 기사의 끝에는 더 잘 이해하실 수 있기를 희망합니다!</p>
<p>그래서 여기 커다란 무서운 코드 덤프 입니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-rust"><span class="hljs-meta">#![allow(unused_must_use)]</span>
<span class="hljs-keyword">use</span> rbot;

<span class="hljs-comment">// 코드의 진입점입니다. lib.rs 파일에 main 함수가 필요합니다. 사용자 정의 코드와 상호작용하는 게임의 인터페이스로 작동합니다. 새 파일, 모듈을 생성하고 온라인 패키지를 사용하십시오. 코드는 WebAssembly로 컴파일되어야 합니다.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// 문서는 다음에서 확인할 수 있습니다: https://docs.rs/rbot/latest/rbot/</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-comment">// 레이더를 사용 가능할 때까지 기다립니다. 쿨다운이 있으므로 항상 호출할 수 없습니다. await_module을 사용하여 준비되었음을 확인합니다.</span>
        rbot::modules::<span class="hljs-title function_ invoke__">await_module</span>(rbot::modules::Module::Radar);

        <span class="hljs-comment">// 적 위치를 알아내기 위해 레이더 모듈을 사용합니다.</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">radar_msg</span> = rbot::modules::<span class="hljs-title function_ invoke__">radar</span>().<span class="hljs-title function_ invoke__">unwrap</span>();

        <span class="hljs-comment">// 적의 위치에 대한 각도를 x와 y를 각도로 변환하여 구합니다.</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">angle</span> = rbot::conversions::<span class="hljs-title function_ invoke__">xy_to_angle</span>(radar_msg.x, radar_msg.y);

        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">4</span> {
            <span class="hljs-comment">// 특정 구성 요소를 적 방향으로 조준합니다.</span>
            rbot::<span class="hljs-title function_ invoke__">await_aim</span>(i, angle, <span class="hljs-number">0.5</span>);

            <span class="hljs-comment">// 구성 요소가 사용할 준비가 될 때까지 기다립니다.</span>
            rbot::<span class="hljs-title function_ invoke__">await_component</span>(i);

            <span class="hljs-comment">// 특정 구성 요소를 사용합니다.</span>
            rbot::<span class="hljs-title function_ invoke__">use_component</span>(i, <span class="hljs-literal">false</span>);
        }
    }
}
</code></pre>
<img src="https://miro.medium.com/v2/resize:fit:1152/1*hDUUgh1Dy2iWkOXtpkviBQ.gif">
<p>아아아아!? 무서워!! 하지만 걱정 마세요, 모두 함께 해결해 나갈 거에요. 한 걸음씩.</p>
<p>메인: 먼저, 우리의 main 함수를 살펴봅시다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
  
}
</code></pre>
<p>이게 뭐지? 우리 프로그램의 진입점이야. 똑똑한 사람이 이렇게 해야 한다고 결정하고, 우리는 단순히 받아들일 뿐이야. 대부분의 프로그래밍 언어에서 비슷한 구조를 찾을 수 있어. 오늘은 여기서 우리 모든 코드를 작성할 거야.</p>
<p>Loop: 다음 코드 블록은 loop야.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">loop</span> {

}
</code></pre>
<div class="content-ad"></div>
<p>루프는 코드를 여러 번 반복해서 실행하는 데 정말 좋은 도구에요. 계속해서 반복해서 반복해서 반복해서 반복해서 반복해서 반복해서 반복해서… 이렇게 이해하시죠. '...' 안에 있는 내용이 계속해서 반복되죠. 멋지죠! 로봇이 끊임없이 작업을 실행하도록 원할 때 매우 유용한 기능이에요.</p>
<p>로봇 명령어: 이제 로봇 명령어에 대해 이야기해볼게요! 여기서 우리는 로봇이 원하는 일을 하도록 지정할 수 있어요. 이 코드 블록에서 레이다 모듈이 활성화될 준비가 될 때까지 기다리도록 로봇에게 지시하는 거에요. 이걸 안하면 레이다를 호출했을 때 실패하고 대신 에러를 반환할 수도 있어요 (에러에 대해서는 나중에 더 설명할게요).</p>
<pre><code class="hljs language-js"><span class="hljs-attr">rbot</span>::<span class="hljs-attr">modules</span>::<span class="hljs-title function_">await_module</span>(<span class="hljs-attr">rbot</span>::<span class="hljs-attr">modules</span>::<span class="hljs-title class_">Module</span>::<span class="hljs-title class_">Radar</span>);
</code></pre>
<p>로봇 명령어: 이제 레이다를 안전하게 사용하고 로봇으로부터 센서의 읽기 값이 돌아올 수 있어요. 이 메시지에는 적 로봇의 위치에 대한 정보가 포함되어 있어요. 이 정보를 통해 그 적을 조준하고 파괴할 수 있어요! 😈</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> radar_msg = <span class="hljs-attr">rbot</span>::<span class="hljs-attr">modules</span>::<span class="hljs-title function_">radar</span>().<span class="hljs-title function_">unwrap</span>();
</code></pre>
<p>로봇 명령: 이 메시지로부터 적에 대한 x와 y 좌표를 상대적으로 얻습니다. 이 정보를 적이 있는 각도로 변환할 수 있습니다. 각도와 좌표에 대해 아무것도 모른다면 일단 받아들이세요. 우리는 앞으로 수학적인 내용에 더 깊이 들어갈 것입니다! 이것은 로봇공학을 할 때 이해해야 하는 매우 중요한 개념으로, 여기서 배우고자 하는 것입니다!</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> angle = <span class="hljs-attr">rbot</span>::<span class="hljs-attr">conversions</span>::<span class="hljs-title function_">xy_to_angle</span>(radar_msg.<span class="hljs-property">x</span>, radar_msg.<span class="hljs-property">y</span>);
</code></pre>
<p>For-loop: Loop와 비슷하게, for-loop는 코드를 여러 번 반복해서 호출하는 데 사용됩니다. Loop와 for-loop의 차이점은 우리가 블록을 몇 번 실행할지를 지정할 수 있다는 것입니다. 이 경우에는 블록을 4번 실행할 것입니다. 또한 몇 번째 반복 중에 있는지를 나타내는 변수 i를 가지고 있을 것입니다. 이렇게 하면 모든 컴포넌트(조준하고 발사하는 등)에 대해 동일한 절차를 수행할 수 있습니다!</p>
<div class="content-ad"></div>
<p>로봇 명령: 이 명령은 로봇이 지정된 각도를 향하도록 하는 것을 명령합니다. 로봇이 각도를 향할 때까지 코드는 실행을 멈추며, 허용 오차는 0.5도입니다. 한 번 로봇이 각도를 향했을 때, 코드는 계속 실행됩니다. 우리는 조준한 후에만 발포하길 원하기 때문에 정말 좋은 방법이죠! for 루프에서 i에 주목해주세요! 이전에 기사에서 설명한 대로 '0,1,2,3' 구성요소를 사용 중입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-attr">rbot</span>::<span class="hljs-title function_">await_aim</span>(i, angle, <span class="hljs-number">0.5</span>);
</code></pre>
<p>로봇 명령: 이제 거의 적을 공격할 준비가 된 상태입니다. 그러나 무기가 준비된 상태인지 확인해야 합니다. 무기에 총알이 없는 상태에서 쏘려고 한다면 어색할 테니까요? 그래서 이 명령은 로봇에게 코드 실행을 계속하기 전에 구성 요소가 준비될 때까지 기다리라고 지시하는 것입니다!</p>
<pre><code class="hljs language-js"><span class="hljs-attr">rbot</span>::<span class="hljs-title function_">await_component</span>(i);
</code></pre>
<div class="content-ad"></div>
<p>로봇 명령: 발사! 이제 우리는 소총으로 쏠 수 있어요! 우리 총알이 적에 맞아 가는 걸 지켜보고 승리의 달콤함을 누려보세요! 참고로, "false"는 로봇에게 소총을 계속 발사하지 말라고 말해요. 우리는 한 번만 쏘기를 원해요!</p>
<pre><code class="hljs language-js"><span class="hljs-attr">rbot</span>::<span class="hljs-title function_">use_component</span>(i, <span class="hljs-literal">false</span>);
</code></pre>
<p>준비를 마친 우리 로봇은 이제 투기장에 들어가 다른 로봇과 싸울 준비가 돼 있어요!</p>
<p>친절하게, 로봇을 컴파일하는 것을 기억해 주세요!!! 코드를 업데이트하더라도 아무것도 바뀌지 않는다고 생각하신다면, 아마 컴파일을 잊은 것일 겁니다.</p>
<div class="content-ad"></div>
<p>서버에 코드를 업로드하려면 뒤로 가기 버튼을 누르고 실행 버튼을 눌러주세요! 당신의 로봇은 랭킹에 따라 실력에 맞는 로봇과 대결하게 될 것입니다. 이기면 이기는 만큼 로봇의 랭킹이 올라갑니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1152/1*YYOoeiUS00hHvJd9-twJUg.gif" alt="로봇 대결"></p>
<p>당신의 로봇이 승리할 수 있기를 바랍니다!</p>
<p>이 기사는 많이 진전되었죠. 제가 알고 있어요! 우리는 일어날 수 있는 최소한의 장벽을 넘어야 했을 뿐입니다. 걱정하지 마세요, 앞으로 우리는 천천히 속도를 줄여 뒤로 한 걸음 물러서며 천천히 전진할 겁니다!</p>
<div class="content-ad"></div>
<p>다음 기사를 기대해주세요! 거기에서는 Rust, 프로그래밍 및 로봇 공학 세계를 더 깊이 파헤쳐볼 예정이에요!</p>
<p>코딩 즐겁게 하세요!</p>
<p>참고: 이 게임은 초기 액세스 중이며 개발 중에 있습니다. 이해하기 어려운 부분이 있다면, <a href="https://botbeats.net%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">https://botbeats.net에서</a> 찾을 수 있는 디스코드 채널로 이동해보세요. 개발자들은 여러분의 모든 질문에 즐겁게 답변해주고 버그를 가능한 한 모두 해결하려 할 거에요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"비디오 게임으로 러스트 마스터하기 2부  게임 메커닉 익히기","description":"","date":"2024-07-01 17:46","slug":"2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics","content":"\n\n1부를 아직 안 읽으셨나요? 확인해보세요!\n\n자, 이제 우리는 Rust 로봇을 세팅했어요. 그럼 이제는 뭘 해야 할까요?\n\n목표는 최고의 로봇 킬러를 만드는 것입니다. 순위 시스템에서 다른 플레이어들의 로봇과 경쟁할 겁니다 — 더 많은 경기에서 승리하면 순위가 올라가요. 이게 다예요! 덤으로 매월 대회가 열려 최종 우승자를 가립니다. 👑\n\n![이미지](/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n멋져요! 이제 우리가 만들고 있는 로봇을 이해해야 합니다. 로봇은 빌딩 화면에서 선택할 4개의 구성 요소가 있습니다. 현재 우리 로봇은 4개의 라이플을 가지고 있습니다. 이러한 구성 요소는 아래 이미지에 표시된 대로 숫자로 식별됩니다. 여기서 0은 앞, 1은 위, 2는 왼쪽, 3은 아래를 나타냅니다. 이는 머리의 방향에 기반합니다. 나중에 머리를 회전시킬 것입니다.\n\n![로봇 구성요소](/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_1.png)\n\n구성 요소 외에도 모듈이 있습니다. 이러한 모듈은 특별한 기능을 수행하여 로봇이 주변을 관찰하고 독특한 능력을 실행할 수 있도록 합니다. 실제 로봇을 프로그래밍해본 적이 있다면 센서가 세계를 인식하는 데 중요한 역할을 한다는 것을 이해할 것입니다. 이 게임은 모듈을 통해 비슷한 개념을 적용합니다. 레이더, 레이저 및 힘-필드 모듈로 시작할 것입니다요.\n\n![로봇 모듈](/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼, 첫 번째 강력한 머신을 만드는 것으로 들어가 봅시다.\n\n이 머신의 계획은, 우리의 위치를 기반으로 적이 어디에 있는지 감지하기 위해 레이더 모듈을 사용할 것입니다. 그런 다음 우리는 적에게 모든 구성 요소(소총)를 조준하여 사용할 것입니다. 그리고 계속 발포하도록 반복할 것입니다!\n\n나는 코드를 모두 넣어둘 것인데, 한 번 살펴봐 주겠니? 러스트에 완전히 처음이신 분들은 조금 무서울 수 있습니다. 하지만 우리는 모든 것을 살펴보고 기사의 끝에는 더 잘 이해하실 수 있기를 희망합니다!\n\n그래서 여기 커다란 무서운 코드 덤프 입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\n#![allow(unused_must_use)]\nuse rbot;\n\n// 코드의 진입점입니다. lib.rs 파일에 main 함수가 필요합니다. 사용자 정의 코드와 상호작용하는 게임의 인터페이스로 작동합니다. 새 파일, 모듈을 생성하고 온라인 패키지를 사용하십시오. 코드는 WebAssembly로 컴파일되어야 합니다.\n//\n// 문서는 다음에서 확인할 수 있습니다: https://docs.rs/rbot/latest/rbot/\npub fn main() {\n    loop {\n        // 레이더를 사용 가능할 때까지 기다립니다. 쿨다운이 있으므로 항상 호출할 수 없습니다. await_module을 사용하여 준비되었음을 확인합니다.\n        rbot::modules::await_module(rbot::modules::Module::Radar);\n\n        // 적 위치를 알아내기 위해 레이더 모듈을 사용합니다.\n        let radar_msg = rbot::modules::radar().unwrap();\n\n        // 적의 위치에 대한 각도를 x와 y를 각도로 변환하여 구합니다.\n        let angle = rbot::conversions::xy_to_angle(radar_msg.x, radar_msg.y);\n\n        for i in 0..4 {\n            // 특정 구성 요소를 적 방향으로 조준합니다.\n            rbot::await_aim(i, angle, 0.5);\n\n            // 구성 요소가 사용할 준비가 될 때까지 기다립니다.\n            rbot::await_component(i);\n\n            // 특정 구성 요소를 사용합니다.\n            rbot::use_component(i, false);\n        }\n    }\n}\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1152/1*hDUUgh1Dy2iWkOXtpkviBQ.gif\" /\u003e\n\n아아아아!? 무서워!! 하지만 걱정 마세요, 모두 함께 해결해 나갈 거에요. 한 걸음씩.\n \n메인: 먼저, 우리의 main 함수를 살펴봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\npub fn main() {\n  \n}\n```\n\n이게 뭐지? 우리 프로그램의 진입점이야. 똑똑한 사람이 이렇게 해야 한다고 결정하고, 우리는 단순히 받아들일 뿐이야. 대부분의 프로그래밍 언어에서 비슷한 구조를 찾을 수 있어. 오늘은 여기서 우리 모든 코드를 작성할 거야.\n\nLoop: 다음 코드 블록은 loop야.\n\n```rust\nloop {\n\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루프는 코드를 여러 번 반복해서 실행하는 데 정말 좋은 도구에요. 계속해서 반복해서 반복해서 반복해서 반복해서 반복해서 반복해서 반복해서… 이렇게 이해하시죠. '...' 안에 있는 내용이 계속해서 반복되죠. 멋지죠! 로봇이 끊임없이 작업을 실행하도록 원할 때 매우 유용한 기능이에요.\n\n로봇 명령어: 이제 로봇 명령어에 대해 이야기해볼게요! 여기서 우리는 로봇이 원하는 일을 하도록 지정할 수 있어요. 이 코드 블록에서 레이다 모듈이 활성화될 준비가 될 때까지 기다리도록 로봇에게 지시하는 거에요. 이걸 안하면 레이다를 호출했을 때 실패하고 대신 에러를 반환할 수도 있어요 (에러에 대해서는 나중에 더 설명할게요).\n\n```js\nrbot::modules::await_module(rbot::modules::Module::Radar);\n```\n\n로봇 명령어: 이제 레이다를 안전하게 사용하고 로봇으로부터 센서의 읽기 값이 돌아올 수 있어요. 이 메시지에는 적 로봇의 위치에 대한 정보가 포함되어 있어요. 이 정보를 통해 그 적을 조준하고 파괴할 수 있어요! 😈\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet radar_msg = rbot::modules::radar().unwrap();\n```\n\n로봇 명령: 이 메시지로부터 적에 대한 x와 y 좌표를 상대적으로 얻습니다. 이 정보를 적이 있는 각도로 변환할 수 있습니다. 각도와 좌표에 대해 아무것도 모른다면 일단 받아들이세요. 우리는 앞으로 수학적인 내용에 더 깊이 들어갈 것입니다! 이것은 로봇공학을 할 때 이해해야 하는 매우 중요한 개념으로, 여기서 배우고자 하는 것입니다!\n\n```js\nlet angle = rbot::conversions::xy_to_angle(radar_msg.x, radar_msg.y);\n```\n\nFor-loop: Loop와 비슷하게, for-loop는 코드를 여러 번 반복해서 호출하는 데 사용됩니다. Loop와 for-loop의 차이점은 우리가 블록을 몇 번 실행할지를 지정할 수 있다는 것입니다. 이 경우에는 블록을 4번 실행할 것입니다. 또한 몇 번째 반복 중에 있는지를 나타내는 변수 i를 가지고 있을 것입니다. 이렇게 하면 모든 컴포넌트(조준하고 발사하는 등)에 대해 동일한 절차를 수행할 수 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로봇 명령: 이 명령은 로봇이 지정된 각도를 향하도록 하는 것을 명령합니다. 로봇이 각도를 향할 때까지 코드는 실행을 멈추며, 허용 오차는 0.5도입니다. 한 번 로봇이 각도를 향했을 때, 코드는 계속 실행됩니다. 우리는 조준한 후에만 발포하길 원하기 때문에 정말 좋은 방법이죠! for 루프에서 i에 주목해주세요! 이전에 기사에서 설명한 대로 '0,1,2,3' 구성요소를 사용 중입니다.\n\n```js\nrbot::await_aim(i, angle, 0.5);\n```\n\n로봇 명령: 이제 거의 적을 공격할 준비가 된 상태입니다. 그러나 무기가 준비된 상태인지 확인해야 합니다. 무기에 총알이 없는 상태에서 쏘려고 한다면 어색할 테니까요? 그래서 이 명령은 로봇에게 코드 실행을 계속하기 전에 구성 요소가 준비될 때까지 기다리라고 지시하는 것입니다!\n\n```js\nrbot::await_component(i);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로봇 명령: 발사! 이제 우리는 소총으로 쏠 수 있어요! 우리 총알이 적에 맞아 가는 걸 지켜보고 승리의 달콤함을 누려보세요! 참고로, \"false\"는 로봇에게 소총을 계속 발사하지 말라고 말해요. 우리는 한 번만 쏘기를 원해요!\n\n```js\nrbot::use_component(i, false);\n```\n\n준비를 마친 우리 로봇은 이제 투기장에 들어가 다른 로봇과 싸울 준비가 돼 있어요!\n\n친절하게, 로봇을 컴파일하는 것을 기억해 주세요!!! 코드를 업데이트하더라도 아무것도 바뀌지 않는다고 생각하신다면, 아마 컴파일을 잊은 것일 겁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서버에 코드를 업로드하려면 뒤로 가기 버튼을 누르고 실행 버튼을 눌러주세요! 당신의 로봇은 랭킹에 따라 실력에 맞는 로봇과 대결하게 될 것입니다. 이기면 이기는 만큼 로봇의 랭킹이 올라갑니다.\n\n![로봇 대결](https://miro.medium.com/v2/resize:fit:1152/1*YYOoeiUS00hHvJd9-twJUg.gif)\n\n당신의 로봇이 승리할 수 있기를 바랍니다!\n\n이 기사는 많이 진전되었죠. 제가 알고 있어요! 우리는 일어날 수 있는 최소한의 장벽을 넘어야 했을 뿐입니다. 걱정하지 마세요, 앞으로 우리는 천천히 속도를 줄여 뒤로 한 걸음 물러서며 천천히 전진할 겁니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 기사를 기대해주세요! 거기에서는 Rust, 프로그래밍 및 로봇 공학 세계를 더 깊이 파헤쳐볼 예정이에요!\n\n코딩 즐겁게 하세요!\n\n참고: 이 게임은 초기 액세스 중이며 개발 중에 있습니다. 이해하기 어려운 부분이 있다면, https://botbeats.net에서 찾을 수 있는 디스코드 채널로 이동해보세요. 개발자들은 여러분의 모든 질문에 즐겁게 답변해주고 버그를 가능한 한 모두 해결하려 할 거에요!","ogImage":{"url":"/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_0.png"},"coverImage":"/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e1부를 아직 안 읽으셨나요? 확인해보세요!\u003c/p\u003e\n\u003cp\u003e자, 이제 우리는 Rust 로봇을 세팅했어요. 그럼 이제는 뭘 해야 할까요?\u003c/p\u003e\n\u003cp\u003e목표는 최고의 로봇 킬러를 만드는 것입니다. 순위 시스템에서 다른 플레이어들의 로봇과 경쟁할 겁니다 — 더 많은 경기에서 승리하면 순위가 올라가요. 이게 다예요! 덤으로 매월 대회가 열려 최종 우승자를 가립니다. 👑\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e멋져요! 이제 우리가 만들고 있는 로봇을 이해해야 합니다. 로봇은 빌딩 화면에서 선택할 4개의 구성 요소가 있습니다. 현재 우리 로봇은 4개의 라이플을 가지고 있습니다. 이러한 구성 요소는 아래 이미지에 표시된 대로 숫자로 식별됩니다. 여기서 0은 앞, 1은 위, 2는 왼쪽, 3은 아래를 나타냅니다. 이는 머리의 방향에 기반합니다. 나중에 머리를 회전시킬 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_1.png\" alt=\"로봇 구성요소\"\u003e\u003c/p\u003e\n\u003cp\u003e구성 요소 외에도 모듈이 있습니다. 이러한 모듈은 특별한 기능을 수행하여 로봇이 주변을 관찰하고 독특한 능력을 실행할 수 있도록 합니다. 실제 로봇을 프로그래밍해본 적이 있다면 센서가 세계를 인식하는 데 중요한 역할을 한다는 것을 이해할 것입니다. 이 게임은 모듈을 통해 비슷한 개념을 적용합니다. 레이더, 레이저 및 힘-필드 모듈로 시작할 것입니다요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_2.png\" alt=\"로봇 모듈\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그럼, 첫 번째 강력한 머신을 만드는 것으로 들어가 봅시다.\u003c/p\u003e\n\u003cp\u003e이 머신의 계획은, 우리의 위치를 기반으로 적이 어디에 있는지 감지하기 위해 레이더 모듈을 사용할 것입니다. 그런 다음 우리는 적에게 모든 구성 요소(소총)를 조준하여 사용할 것입니다. 그리고 계속 발포하도록 반복할 것입니다!\u003c/p\u003e\n\u003cp\u003e나는 코드를 모두 넣어둘 것인데, 한 번 살펴봐 주겠니? 러스트에 완전히 처음이신 분들은 조금 무서울 수 있습니다. 하지만 우리는 모든 것을 살펴보고 기사의 끝에는 더 잘 이해하실 수 있기를 희망합니다!\u003c/p\u003e\n\u003cp\u003e그래서 여기 커다란 무서운 코드 덤프 입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-meta\"\u003e#![allow(unused_must_use)]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e rbot;\n\n\u003cspan class=\"hljs-comment\"\u003e// 코드의 진입점입니다. lib.rs 파일에 main 함수가 필요합니다. 사용자 정의 코드와 상호작용하는 게임의 인터페이스로 작동합니다. 새 파일, 모듈을 생성하고 온라인 패키지를 사용하십시오. 코드는 WebAssembly로 컴파일되어야 합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 문서는 다음에서 확인할 수 있습니다: https://docs.rs/rbot/latest/rbot/\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003eloop\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 레이더를 사용 가능할 때까지 기다립니다. 쿨다운이 있으므로 항상 호출할 수 없습니다. await_module을 사용하여 준비되었음을 확인합니다.\u003c/span\u003e\n        rbot::modules::\u003cspan class=\"hljs-title function_ invoke__\"\u003eawait_module\u003c/span\u003e(rbot::modules::Module::Radar);\n\n        \u003cspan class=\"hljs-comment\"\u003e// 적 위치를 알아내기 위해 레이더 모듈을 사용합니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eradar_msg\u003c/span\u003e = rbot::modules::\u003cspan class=\"hljs-title function_ invoke__\"\u003eradar\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e();\n\n        \u003cspan class=\"hljs-comment\"\u003e// 적의 위치에 대한 각도를 x와 y를 각도로 변환하여 구합니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eangle\u003c/span\u003e = rbot::conversions::\u003cspan class=\"hljs-title function_ invoke__\"\u003exy_to_angle\u003c/span\u003e(radar_msg.x, radar_msg.y);\n\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ei\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e..\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e {\n            \u003cspan class=\"hljs-comment\"\u003e// 특정 구성 요소를 적 방향으로 조준합니다.\u003c/span\u003e\n            rbot::\u003cspan class=\"hljs-title function_ invoke__\"\u003eawait_aim\u003c/span\u003e(i, angle, \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e);\n\n            \u003cspan class=\"hljs-comment\"\u003e// 구성 요소가 사용할 준비가 될 때까지 기다립니다.\u003c/span\u003e\n            rbot::\u003cspan class=\"hljs-title function_ invoke__\"\u003eawait_component\u003c/span\u003e(i);\n\n            \u003cspan class=\"hljs-comment\"\u003e// 특정 구성 요소를 사용합니다.\u003c/span\u003e\n            rbot::\u003cspan class=\"hljs-title function_ invoke__\"\u003euse_component\u003c/span\u003e(i, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1152/1*hDUUgh1Dy2iWkOXtpkviBQ.gif\"\u003e\n\u003cp\u003e아아아아!? 무서워!! 하지만 걱정 마세요, 모두 함께 해결해 나갈 거에요. 한 걸음씩.\u003c/p\u003e\n\u003cp\u003e메인: 먼저, 우리의 main 함수를 살펴봅시다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n  \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이게 뭐지? 우리 프로그램의 진입점이야. 똑똑한 사람이 이렇게 해야 한다고 결정하고, 우리는 단순히 받아들일 뿐이야. 대부분의 프로그래밍 언어에서 비슷한 구조를 찾을 수 있어. 오늘은 여기서 우리 모든 코드를 작성할 거야.\u003c/p\u003e\n\u003cp\u003eLoop: 다음 코드 블록은 loop야.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003eloop\u003c/span\u003e {\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e루프는 코드를 여러 번 반복해서 실행하는 데 정말 좋은 도구에요. 계속해서 반복해서 반복해서 반복해서 반복해서 반복해서 반복해서 반복해서… 이렇게 이해하시죠. '...' 안에 있는 내용이 계속해서 반복되죠. 멋지죠! 로봇이 끊임없이 작업을 실행하도록 원할 때 매우 유용한 기능이에요.\u003c/p\u003e\n\u003cp\u003e로봇 명령어: 이제 로봇 명령어에 대해 이야기해볼게요! 여기서 우리는 로봇이 원하는 일을 하도록 지정할 수 있어요. 이 코드 블록에서 레이다 모듈이 활성화될 준비가 될 때까지 기다리도록 로봇에게 지시하는 거에요. 이걸 안하면 레이다를 호출했을 때 실패하고 대신 에러를 반환할 수도 있어요 (에러에 대해서는 나중에 더 설명할게요).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003erbot\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003emodules\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003eawait_module\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003erbot\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003emodules\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eModule\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eRadar\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e로봇 명령어: 이제 레이다를 안전하게 사용하고 로봇으로부터 센서의 읽기 값이 돌아올 수 있어요. 이 메시지에는 적 로봇의 위치에 대한 정보가 포함되어 있어요. 이 정보를 통해 그 적을 조준하고 파괴할 수 있어요! 😈\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e radar_msg = \u003cspan class=\"hljs-attr\"\u003erbot\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003emodules\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003eradar\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eunwrap\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e로봇 명령: 이 메시지로부터 적에 대한 x와 y 좌표를 상대적으로 얻습니다. 이 정보를 적이 있는 각도로 변환할 수 있습니다. 각도와 좌표에 대해 아무것도 모른다면 일단 받아들이세요. 우리는 앞으로 수학적인 내용에 더 깊이 들어갈 것입니다! 이것은 로봇공학을 할 때 이해해야 하는 매우 중요한 개념으로, 여기서 배우고자 하는 것입니다!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e angle = \u003cspan class=\"hljs-attr\"\u003erbot\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003econversions\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003exy_to_angle\u003c/span\u003e(radar_msg.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e, radar_msg.\u003cspan class=\"hljs-property\"\u003ey\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor-loop: Loop와 비슷하게, for-loop는 코드를 여러 번 반복해서 호출하는 데 사용됩니다. Loop와 for-loop의 차이점은 우리가 블록을 몇 번 실행할지를 지정할 수 있다는 것입니다. 이 경우에는 블록을 4번 실행할 것입니다. 또한 몇 번째 반복 중에 있는지를 나타내는 변수 i를 가지고 있을 것입니다. 이렇게 하면 모든 컴포넌트(조준하고 발사하는 등)에 대해 동일한 절차를 수행할 수 있습니다!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e로봇 명령: 이 명령은 로봇이 지정된 각도를 향하도록 하는 것을 명령합니다. 로봇이 각도를 향할 때까지 코드는 실행을 멈추며, 허용 오차는 0.5도입니다. 한 번 로봇이 각도를 향했을 때, 코드는 계속 실행됩니다. 우리는 조준한 후에만 발포하길 원하기 때문에 정말 좋은 방법이죠! for 루프에서 i에 주목해주세요! 이전에 기사에서 설명한 대로 '0,1,2,3' 구성요소를 사용 중입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003erbot\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003eawait_aim\u003c/span\u003e(i, angle, \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e로봇 명령: 이제 거의 적을 공격할 준비가 된 상태입니다. 그러나 무기가 준비된 상태인지 확인해야 합니다. 무기에 총알이 없는 상태에서 쏘려고 한다면 어색할 테니까요? 그래서 이 명령은 로봇에게 코드 실행을 계속하기 전에 구성 요소가 준비될 때까지 기다리라고 지시하는 것입니다!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003erbot\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003eawait_component\u003c/span\u003e(i);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e로봇 명령: 발사! 이제 우리는 소총으로 쏠 수 있어요! 우리 총알이 적에 맞아 가는 걸 지켜보고 승리의 달콤함을 누려보세요! 참고로, \"false\"는 로봇에게 소총을 계속 발사하지 말라고 말해요. 우리는 한 번만 쏘기를 원해요!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003erbot\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003euse_component\u003c/span\u003e(i, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e준비를 마친 우리 로봇은 이제 투기장에 들어가 다른 로봇과 싸울 준비가 돼 있어요!\u003c/p\u003e\n\u003cp\u003e친절하게, 로봇을 컴파일하는 것을 기억해 주세요!!! 코드를 업데이트하더라도 아무것도 바뀌지 않는다고 생각하신다면, 아마 컴파일을 잊은 것일 겁니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e서버에 코드를 업로드하려면 뒤로 가기 버튼을 누르고 실행 버튼을 눌러주세요! 당신의 로봇은 랭킹에 따라 실력에 맞는 로봇과 대결하게 될 것입니다. 이기면 이기는 만큼 로봇의 랭킹이 올라갑니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1152/1*YYOoeiUS00hHvJd9-twJUg.gif\" alt=\"로봇 대결\"\u003e\u003c/p\u003e\n\u003cp\u003e당신의 로봇이 승리할 수 있기를 바랍니다!\u003c/p\u003e\n\u003cp\u003e이 기사는 많이 진전되었죠. 제가 알고 있어요! 우리는 일어날 수 있는 최소한의 장벽을 넘어야 했을 뿐입니다. 걱정하지 마세요, 앞으로 우리는 천천히 속도를 줄여 뒤로 한 걸음 물러서며 천천히 전진할 겁니다!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다음 기사를 기대해주세요! 거기에서는 Rust, 프로그래밍 및 로봇 공학 세계를 더 깊이 파헤쳐볼 예정이에요!\u003c/p\u003e\n\u003cp\u003e코딩 즐겁게 하세요!\u003c/p\u003e\n\u003cp\u003e참고: 이 게임은 초기 액세스 중이며 개발 중에 있습니다. 이해하기 어려운 부분이 있다면, \u003ca href=\"https://botbeats.net%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://botbeats.net에서\u003c/a\u003e 찾을 수 있는 디스코드 채널로 이동해보세요. 개발자들은 여러분의 모든 질문에 즐겁게 답변해주고 버그를 가능한 한 모두 해결하려 할 거에요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics"},"buildId":"27A9ztIgBqdXqyYJG3uHv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>