<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>임베디드 AI  머신 러닝을 사용하여 배터리 충전 상태 확인 방법 | design-news</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://design-news.github.io///post/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="임베디드 AI  머신 러닝을 사용하여 배터리 충전 상태 확인 방법 | design-news" data-gatsby-head="true"/><meta property="og:title" content="임베디드 AI  머신 러닝을 사용하여 배터리 충전 상태 확인 방법 | design-news" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://design-news.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://design-news.github.io///post/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning" data-gatsby-head="true"/><meta name="twitter:title" content="임베디드 AI  머신 러닝을 사용하여 배터리 충전 상태 확인 방법 | design-news" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | design-news" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-30 23:36" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-3b19b133b17efefe.js" defer=""></script><script src="/_next/static/eK_Db2btow8fB-QoZ_pMH/_buildManifest.js" defer=""></script><script src="/_next/static/eK_Db2btow8fB-QoZ_pMH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Design News</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">임베디드 AI  머신 러닝을 사용하여 배터리 충전 상태 확인 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="임베디드 AI  머신 러닝을 사용하여 배터리 충전 상태 확인 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Design News</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 30, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>배터리 충전 상태(SOC)는 배터리의 잔여 전하를 총 용량의 백분율로 표시합니다. 이 정보는 내장 장치의 에너지 관리에 매우 중요합니다. SOC를 정확하게 추정하는 것은 리튬이온 배터리의 복잡한 행동에 영향을 받아 어려운 작업입니다. 이는 온도, 배터리 건강 상태, 그리고 SOC 자체와 같은 요소들에 의해 영향을 받기 때문입니다. SOC를 추정하기 위한 전통적인 방법인 전기화학 모델은 정확한 매개변수와 배터리의 조성 및 물리적 특성에 대한 심층적인 이해를 요구합니다. 반면, 머신 러닝 모델은 데이터 기반 접근 방식을 제공하여 배터리의 행동에 대해 덜 자세한 지식만으로도 SOC 추정을 단순화시키므로 내장 시스템에 구현하기에 적합합니다.</h2>
<p><img src="/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_0.png" alt="이미지"></p>
<h2>머신 러닝 과정</h2>
<p>내장형 AI 시리즈의 제1부에서, ML을 사용하여 값들을 예측하는 과정을 설명했습니다 (그림 1).</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_1.png" alt="이미지"></p>
<p>Part 2에서 설명한 것처럼, 배터리 방전 곡선은 대부분의 사용 가능 범위에 걸쳐 거의 선형입니다. 그러므로 우리는 Part 1에서 설명한 선형 회귀 모델을 사용할 수 있을 것입니다. 그러나 출력물은 룩업 테이블 및 보간 방법과 매우 유사할 것입니다. 더 정확하고 유연한 예측을 제공해야 할 다른 접근 방식이 있습니다.</p>
<p>이러한 옵션을 탐색하기 위해 ML 프로세스 플로우차트의 단계를 따를 것입니다.</p>
<h2>단계 1 — 문제 정의</h2>
<div class="content-ad"></div>
<p>배터리의 SOC를 정확하게 예측하는 ML 모델을 개발하는 것이 목표입니다. 이 모델은 전압을 기반으로 배터리의 SOC를 예측하는 데 사용되며 전류, 온도, 그리고 시간과 같은 관련 특징도 함께 고려됩니다 (Figure 2). 모델은 다양한 작동 조건과 배터리 상태에 걸쳐 잘 일반화되어야 하며, 이는 실시간 응용 프로그램에서 신뢰할 수 있는 SOC 추정을 보장합니다.</p>
<p>Inputs and Features</p>
<ul>
<li>Voltage (V): 배터리의 순간 전압을 나타내는 주요 입력 특징입니다.</li>
<li>Current (I): 배터리에 공급되거나 공급되는 전류로, 전압 값에 영향을 줄 수 있습니다.</li>
<li>Temperature (T): 주변 온도 또는 배터리의 온도로, 온도 변화가 배터리 성능에 영향을 줍니다.</li>
<li>Time (t): 전압이 측정된 시간으로, 배터리의 방전 또는 충전 주기를 이해하는 데 도움이 됩니다.</li>
</ul>
<div class="content-ad"></div>
<ul>
<li>전하 상태 (SOC): 배터리의 예상 SOC로서 총 용량의 백분율로 표시됩니다.</li>
</ul>
<p><img src="/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_2.png" alt="image"></p>
<h2>단계 2 — 훈련 데이터 수집 및 정리</h2>
<p>이 단계에서 가장 많은 작업을 수행하게 될 것입니다. 모델을 훈련시킬 데이터가 더 좋을수록 예측이 더 좋아질 것입니다. 우리는 맥마스터 대학교에서 발행한 LG 18650HG2 리튬이온 배터리에 대한 Digital Commons 데이터를 사용할 것입니다. 아래의 Python 스크립트를 사용하여 이 데이터셋을 다운로드할 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">import</span> zipfile
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

# 다운로드 할 파일의 <span class="hljs-variable constant_">URL</span>
url = <span class="hljs-string">"https://data.mendeley.com/public-files/datasets/cp3473x7xv/files/ad7ac5c9-2b9e-458a-a91f-6f3da449bdfb/file_downloaded"</span>

# 추출된 <span class="hljs-variable constant_">ZIP</span> 파일이 들어 있는 출력 폴더
output_folder = os.<span class="hljs-property">path</span>.<span class="hljs-title function_">expanduser</span>(<span class="hljs-string">"~/Documents/GitHub/Embedded-AI/data/LGHG2@n10C_to_25degC"</span>)
os.<span class="hljs-title function_">makedirs</span>(output_folder, exist_ok=<span class="hljs-title class_">True</span>)

# 데이터 세트 다운로드 및 추출
train_folder = os.<span class="hljs-property">path</span>.<span class="hljs-title function_">join</span>(output_folder, <span class="hljs-string">"Train"</span>)
test_folder = os.<span class="hljs-property">path</span>.<span class="hljs-title function_">join</span>(output_folder, <span class="hljs-string">"Test"</span>)
<span class="hljs-keyword">if</span> not os.<span class="hljs-property">path</span>.<span class="hljs-title function_">exists</span>(train_folder) or not os.<span class="hljs-property">path</span>.<span class="hljs-title function_">exists</span>(test_folder):
    <span class="hljs-title function_">print</span>(<span class="hljs-string">"LGHG2@n10C_to_25degC.zip (56 MB) 다운로드 중... "</span>)
    download_folder = os.<span class="hljs-property">path</span>.<span class="hljs-title function_">dirname</span>(output_folder)
    filename = os.<span class="hljs-property">path</span>.<span class="hljs-title function_">join</span>(download_folder, <span class="hljs-string">"LGHG2@n10C_to_25degC.zip"</span>)
    response = requests.<span class="hljs-title function_">get</span>(url)
    <span class="hljs-keyword">with</span> <span class="hljs-title function_">open</span>(filename, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> <span class="hljs-attr">file</span>:
        file.<span class="hljs-title function_">write</span>(response.<span class="hljs-property">content</span>)
    <span class="hljs-keyword">with</span> zipfile.<span class="hljs-title class_">ZipFile</span>(filename, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> <span class="hljs-attr">zip_ref</span>:
        zip_ref.<span class="hljs-title function_">extractall</span>(output_folder)
</code></pre>
<p>이 스크립트에서 output_folder를 수정하여 데이터를 저장할 위치를 지정하십시오. 이 데이터를 사용하기 전에 데이터가 어떻게 구성되어 있는지 이해해야 합니다. Figure 3는 추출된 데이터 세트의 내용을 보여줍니다.</p>
<img src="/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_3.png">
<p>각 파일에는 다섯 가지 예측 변수(전압, 전류, 온도, 평균 전압 및 평균 전류)로 이루어진 시계열 X와 하나의 대상 SOC로 이루어진 시계열 Y가 포함되어 있습니다. 서로 다른 환경 온도에서 수집된 데이터를 나타내는 하나의 훈련 파일과 네 개의 테스트 파일이 있습니다. 유일한 문제는 데이터가 MATLAB 형식(.mat)으로 저장되어 있다는 것입니다.</p>
<div class="content-ad"></div>
<p>.mat 파일은 MATLAB에서 변수를 저장하는 데 사용되는 이진 데이터 파일입니다. 배열, 행렬 및 기타 데이터 유형을 저장할 수 있습니다. 이진 파일이기 때문에 텍스트 편집기에서는 읽을 수 없지만, Python의 scipy.io 모듈을 사용하여 이러한 파일을 읽고 쓸 수 있습니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> scipy.io
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

<span class="hljs-comment"># .mat 파일의 처음 10줄을 읽어 출력</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">read_and_print_mat_files</span>(<span class="hljs-params">folder</span>):
    <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> os.listdir(folder):
        <span class="hljs-keyword">if</span> filename.endswith(<span class="hljs-string">".mat"</span>):
            filepath = os.path.join(folder, filename)
            mat_data = scipy.io.loadmat(filepath)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{filename}</span> 내용:"</span>)
            <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> mat_data:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> key.startswith(<span class="hljs-string">"__"</span>):
                    data = mat_data[key]
                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data, np.ndarray) <span class="hljs-keyword">and</span> data.ndim > <span class="hljs-number">1</span>:  
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{key}</span>:"</span>)
                        <span class="hljs-built_in">print</span>(data[:<span class="hljs-number">10</span>])  
                    <span class="hljs-keyword">else</span>:
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{key}</span>: <span class="hljs-subst">{data}</span>"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n"</span>)

<span class="hljs-comment"># 폴더 경로</span>
train_folder = os.path.expanduser(<span class="hljs-string">"~/Documents/GitHub/Embedded-AI/data/LGHG2@n10C_to_25degC/Train"</span>)
test_folder = os.path.expanduser(<span class="hljs-string">"~/Documents/GitHub/Embedded-AI/data/LGHG2@n10C_to_25degC/Test"</span>)

<span class="hljs-comment"># Train 및 Test 파일의 내용 읽고 출력</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"훈련 데이터 파일:"</span>)
read_and_print_mat_files(train_folder)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n테스트 데이터 파일:"</span>)
read_and_print_mat_files(test_folder)
</code></pre>
<p>훈련 데이터의 처음 다섯 행의 내용은 아래와 같이 표시됩니다.</p>
<pre><code class="hljs language-python">TRAIN_LGHG2@n10degC_to_25degC_Norm_5Inputs.mat 내용:
X:
[[<span class="hljs-number">0.38514793</span> <span class="hljs-number">0.38515183</span> <span class="hljs-number">0.38515573</span> ... <span class="hljs-number">0.47884278</span> <span class="hljs-number">0.4789612</span>  <span class="hljs-number">0.4789612</span> ]
 [<span class="hljs-number">0.75102009</span> <span class="hljs-number">0.75102009</span> <span class="hljs-number">0.75102009</span> ... <span class="hljs-number">0.75102009</span> <span class="hljs-number">0.75102009</span> <span class="hljs-number">0.75102009</span>]
 [<span class="hljs-number">0.30310108</span> <span class="hljs-number">0.30459129</span> <span class="hljs-number">0.3060815</span>  ... <span class="hljs-number">0.00847709</span> <span class="hljs-number">0.00847709</span> <span class="hljs-number">0.00847709</span>]
 [<span class="hljs-number">0.38514793</span> <span class="hljs-number">0.38514988</span> <span class="hljs-number">0.38515183</span> ... <span class="hljs-number">0.45983939</span> <span class="hljs-number">0.45997861</span> <span class="hljs-number">0.46011672</span>]
 [<span class="hljs-number">0.75102009</span> <span class="hljs-number">0.75102009</span> <span class="hljs-number">0.75102009</span> ... <span class="hljs-number">0.75102009</span> <span class="hljs-number">0.75102009</span> <span class="hljs-number">0.75102009</span>]]
Y:
[[<span class="hljs-number">0.20641667</span> <span class="hljs-number">0.20641667</span> <span class="hljs-number">0.20641667</span> ... <span class="hljs-number">0.28324333</span> <span class="hljs-number">0.28324333</span> <span class="hljs-number">0.28324333</span>]]
</code></pre>
<div class="content-ad"></div>
<p>X는 각 행이 다음 다섯 개의 예측변수 중 하나에 해당하는 2D 배열입니다:</p>
<ul>
<li>전압</li>
<li>전류</li>
<li>온도</li>
<li>평균 전압</li>
<li>평균 전류</li>
</ul>
<p>각 열은 Series에서 다른 시간점을 나타내며, 측정은 1초마다 이루어졌습니다. 예를 들어, 첫 번째 행은 전압: [0.38514793, 0.38515183, 0.38515573, …, 0.47884278, 0.4789612, 0.4789612]이고, 두 번째 행은 전류: [0.75102009, 0.75102009, 0.75102009, …, 0.75102009, 0.75102009, 0.75102009]이며, 나머지 예측변수에 대한 내용도 같은 방식입니다.</p>
<p>Y도 하나의 행으로 이루어진 2D 배열이지만, SOC가 단일 대상 변수임을 나타냅니다. 각 열은 해당 시간점에서의 SOC를 나타냅니다.</p>
<div class="content-ad"></div>
<p>이제 파일 내용을 이해했으므로 훈련 및 테스트를 위해 데이터 저장소를 로드할 수 있습니다.</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">read_mat_files</span>(folder):
    data = []
    <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> os.<span class="hljs-title function_">listdir</span>(folder):
        <span class="hljs-keyword">if</span> filename.<span class="hljs-title function_">endswith</span>(<span class="hljs-string">".mat"</span>):
            filepath = os.<span class="hljs-property">path</span>.<span class="hljs-title function_">join</span>(folder, filename)
            mat_data = scipy.<span class="hljs-property">io</span>.<span class="hljs-title function_">loadmat</span>(filepath)
            data.<span class="hljs-title function_">append</span>(mat_data)
    <span class="hljs-keyword">return</span> data

# 훈련 데이터와 테스트 데이터를 위한 파일 데이터 저장소 생성
fds_train = <span class="hljs-title function_">read_mat_files</span>(train_folder)
fds_test = <span class="hljs-title function_">read_mat_files</span>(test_folder)

# 데이터 저장소에 있는 모든 데이터 읽기
train_data_full = fds_train[<span class="hljs-number">0</span>]
test_data_full_n10deg = fds_test[<span class="hljs-number">0</span>]
test_data_full_0deg = fds_test[<span class="hljs-number">1</span>]
test_data_full_10deg = fds_test[<span class="hljs-number">2</span>]
test_data_full_25deg = fds_test[<span class="hljs-number">3</span>]

# 데이터 배열의 모양 출력하여 구조를 이해하기
<span class="hljs-title function_">print</span>(<span class="hljs-string">"train_data_full['X']의 모양: "</span>, train_data_full[<span class="hljs-string">'X'</span>].<span class="hljs-property">shape</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-string">"train_data_full['Y']의 모양: "</span>, train_data_full[<span class="hljs-string">'Y'</span>].<span class="hljs-property">shape</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-string">"test_data_full_n10deg['X']의 모양: "</span>, test_data_full_n10deg[<span class="hljs-string">'X'</span>].<span class="hljs-property">shape</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-string">"test_data_full_n10deg['Y']의 모양: "</span>, test_data_full_n10deg[<span class="hljs-string">'Y'</span>].<span class="hljs-property">shape</span>)
</code></pre>
<p>shape 속성은 배열의 차원을 나타내는 튜플을 반환합니다. 2D 배열의 경우 shape는 (행, 열)로 이루어진 튜플을 반환합니다.</p>
<pre><code class="hljs language-js">train_data_full[<span class="hljs-string">'X'</span>]의 모양:  (<span class="hljs-number">5</span>, <span class="hljs-number">669956</span>)
train_data_full[<span class="hljs-string">'Y'</span>]의 모양:  (<span class="hljs-number">1</span>, <span class="hljs-number">669956</span>)
test_data_full_n10deg[<span class="hljs-string">'X'</span>]의 모양:  (<span class="hljs-number">5</span>, <span class="hljs-number">47517</span>)
test_data_full_n10deg[<span class="hljs-string">'Y'</span>]의 모양:  (<span class="hljs-number">1</span>, <span class="hljs-number">47517</span>)
</code></pre>
<div class="content-ad"></div>
<p>훈련 데이터 파일 내에서, 주변 온도 측정 값은 다음과 같이 분할되어 있습니다:</p>
<pre><code class="hljs language-js">idx0   = <span class="hljs-number">1</span> - <span class="hljs-number">184257</span>        # 온도 = <span class="hljs-number">0</span>°C
idx10  = <span class="hljs-number">184258</span> - <span class="hljs-number">337973</span>   # 온도 = <span class="hljs-number">10</span>°C
idx25  = <span class="hljs-number">337974</span> - <span class="hljs-number">510530</span>   # 온도 = <span class="hljs-number">25</span>°C
idxN10 = <span class="hljs-number">510531</span> - <span class="hljs-number">669956</span>   # 온도 = -<span class="hljs-number">10</span>°C
</code></pre>
<p>우리가 출력한 훈련 데이터의 첫 5개 행을 살펴보면, X의 3번째 행이 온도를 나타냅니다. 이 값이 0이 될 것으로 예상할 수 있지만, 이 값들은 측정되고 정규화된 값입니다. 모든 예측 변수는 모델 수렴 및 성능을 향상시키기 위해 정규화되었습니다.</p>
<p>훈련 온도 데이터 세트를 분리하려면, 아래 코드를 로딩 스크립트에 추가하십시오.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># train_data_full에서 X와 Y 추출하기
X = train_data_full[<span class="hljs-string">'X'</span>]
Y = train_data_full[<span class="hljs-string">'Y'</span>]

# 인덱스 범위 정의
idx0 = <span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">184257</span>)
idx10 = <span class="hljs-title function_">slice</span>(<span class="hljs-number">184257</span>, <span class="hljs-number">337973</span>)
idx25 = <span class="hljs-title function_">slice</span>(<span class="hljs-number">337973</span>, <span class="hljs-number">510530</span>)
idxN10 = <span class="hljs-title function_">slice</span>(<span class="hljs-number">510530</span>, <span class="hljs-number">669956</span>)

# 데이터 세그먼트 추출
X_idx0 = X[:, idx0]
Y_idx0 = Y[:, idx0]

X_idx10 = X[:, idx10]
Y_idx10 = Y[:, idx10]

X_idx25 = X[:, idx25]
Y_idx25 = Y[:, idx25]

X_idxN10 = X[:, idxN10]
Y_idxN10 = Y[:, idxN10]

# 추출 확인을 위해 형태 출력
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'X_idx0 형태: {X_idx0.shape}, Y_idx0 형태: {Y_idx0.shape}'</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'X_idx10 형태: {X_idx10.shape}, Y_idx10 형태: {Y_idx10.shape}'</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'X_idx25 형태: {X_idx25.shape}, Y_idx25 형태: {Y_idx25.shape}'</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'X_idxN10 형태: {X_idxN10.shape}, Y_idxN10 형태: {Y_idxN10.shape}'</span>)
</code></pre>
<p>트레이닝 데이터에는 총 669,956개의 열이 있어서 처리하기에는 조금 많습니다. 간단하게 만들기 위해 데이터를 다시 샘플링하여 매 100번째 점을 가져와 평균 전압 및 평균 전류 예측 변수의 새로운 이동 평균값을 계산할 것입니다. 재계산된 이동 평균은 각 포인트에 대해 최근 5개 샘플을 사용합니다. 이는 i-5부터 i까지의 값들의 평균을 계산하기 위해 루프를 사용하여 수행됩니다. 이동 평균을 계산하는 데 최근 5개 샘플을 사용하는 것은 시계열 분석에서 일반적인 기술입니다. 이 접근 방식은 데이터를 부드럽게 만들면서 최근 변화에 반응성을 유지하는 균형을 제공합니다.</p>
<p>데이터 전처리를 돕기 위해 파이썬 함수를 작성했습니다.</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">resample_and_compute_moving_averages</span>(X, Y, step=<span class="hljs-number">100</span>):
    # 데이터 재샘플링 (매 <span class="hljs-string">`step`</span>번째 포인트 가져오기)
    X_resampled = X[:, ::step]
    Y_resampled = Y[:, ::step]
    
    # 새로운 이동 평균 계산
    n = X_resampled.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>]
    avg_voltage_idx = <span class="hljs-number">3</span>  # <span class="hljs-number">4</span>번째 열이 평균 전압이라고 가정
    avg_current_idx = <span class="hljs-number">4</span>  # <span class="hljs-number">5</span>번째 열이 평균 전류이라고 가정
    
    new_avg_voltage = np.<span class="hljs-title function_">empty</span>(n)
    new_avg_current = np.<span class="hljs-title function_">empty</span>(n)
    
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(n):
        new_avg_voltage[i] = np.<span class="hljs-title function_">mean</span>(X_resampled[<span class="hljs-number">0</span>, <span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, i-<span class="hljs-number">5</span>):i+<span class="hljs-number">1</span>])
        new_avg_current[i] = np.<span class="hljs-title function_">mean</span>(X_resampled[<span class="hljs-number">1</span>, <span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, i-<span class="hljs-number">5</span>):i+<span class="hljs-number">1</span>])
    
    X_resampled[avg_voltage_idx, :n] = new_avg_voltage
    X_resampled[avg_current_idx, :n] = new_avg_current
    
    <span class="hljs-keyword">return</span> X_resampled, Y_resampled
</code></pre>
<div class="content-ad"></div>
<p>학습 및 테스트 데이터 재샘플링은 이제 간단합니다.</p>
<pre><code class="hljs language-js"># 학습 데이터를 재샘플링하고 새로운 이동 평균 계산
X_train_resampled, Y_train_resampled = <span class="hljs-title function_">resample_and_compute_moving_averages</span>(X_train, Y_train)

# 테스트 데이터 추출 및 재샘플링
X_test_n10deg = test_data_full_n10deg[<span class="hljs-string">'X'</span>]
Y_test_n10deg = test_data_full_n10deg[<span class="hljs-string">'Y'</span>]
X_test_n10deg_resampled, Y_test_n10deg_resampled = <span class="hljs-title function_">resample_and_compute_moving_averages</span>(X_test_n10deg, Y_test_n10deg)

X_test_0deg = test_data_full_0deg[<span class="hljs-string">'X'</span>]
Y_test_0deg = test_data_full_0deg[<span class="hljs-string">'Y'</span>]
X_test_0deg_resampled, Y_test_0deg_resampled = <span class="hljs-title function_">resample_and_compute_moving_averages</span>(X_test_0deg, Y_test_0deg)

X_test_10deg = test_data_full_10deg[<span class="hljs-string">'X'</span>]
Y_test_10deg = test_data_full_10deg[<span class="hljs-string">'Y'</span>]
X_test_10deg_resampled, Y_test_10deg_resampled = <span class="hljs-title function_">resample_and_compute_moving_averages</span>(X_test_10deg, Y_test_10deg)

X_test_25deg = test_data_full_25deg[<span class="hljs-string">'X'</span>]
Y_test_25deg = test_data_full_25deg[<span class="hljs-string">'Y'</span>]
X_test_25deg_resampled, Y_test_25deg_resampled = <span class="hljs-title function_">resample_and_compute_moving_averages</span>(X_test_25deg, Y_test_25deg)

# 재샘플링 확인을 위해 형태 출력
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'재샘플링 후 학습 데이터 형태: X={X_train_resampled.shape}, Y={Y_train_resampled.shape}'</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'n10degC 테스트 데이터 형태: X={X_test_n10deg_resampled.shape}, Y={Y_test_n10deg_resampled.shape}'</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'0degC 테스트 데이터 형태: X={X_test_0deg_resampled.shape}, Y={Y_test_0deg_resampled.shape}'</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'10degC 테스트 데이터 형태: X={X_test_10deg_resampled.shape}, Y={Y_test_10deg_resampled.shape}'</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'25degC 테스트 데이터 형태: X={X_test_25deg_resampled.shape}, Y={Y_test_25deg_resampled.shape}'</span>)
</code></pre>
<p>데이터 처리 스케치의 전체 버전은 Reefwing Gist에서 제공됩니다. 데이터셋 크기를 재샘플링한 후에는 아래와 같은 크기가 됩니다.</p>
<pre><code class="hljs language-js">재샘플링 후 학습 데이터 형태: X=(<span class="hljs-number">5</span>, <span class="hljs-number">6700</span>), Y=(<span class="hljs-number">1</span>, <span class="hljs-number">6700</span>)
n10degC 테스트 데이터 형태: X=(<span class="hljs-number">5</span>, <span class="hljs-number">476</span>), Y=(<span class="hljs-number">1</span>, <span class="hljs-number">476</span>)
0degC 테스트 데이터 형태: X=(<span class="hljs-number">5</span>, <span class="hljs-number">443</span>), Y=(<span class="hljs-number">1</span>, <span class="hljs-number">443</span>)
10degC 테스트 데이터 형태: X=(<span class="hljs-number">5</span>, <span class="hljs-number">426</span>), Y=(<span class="hljs-number">1</span>, <span class="hljs-number">426</span>)
25degC 테스트 데이터 형태: X=(<span class="hljs-number">5</span>, <span class="hljs-number">393</span>), Y=(<span class="hljs-number">1</span>, <span class="hljs-number">393</span>)
</code></pre>
<div class="content-ad"></div>
<p>저희는 모든 전처리된 학습 및 테스트 데이터를 Preprocessed라는 새 하위 디렉토리에 저장할 거에요. 이 파일들은 CSV 형식으로 저장되며, 쉽게 읽고 쓸 수 있어서 사용자가 쉽게 확인할 수 있어요. 더 큰 데이터셋의 경우 HDF5 (계층적 데이터 형식)를 사용하면 효율적으로 대량의 데이터를 저장할 수 있고 복잡한 데이터 구조를 지원해요. 이는 과학 계산에서도 널리 사용되고 있어요. 관련 추가 코드는 아래에 나와 있어요.</p>
<pre><code class="hljs language-js">preprocessed_folder = os.<span class="hljs-property">path</span>.<span class="hljs-title function_">join</span>(output_folder, <span class="hljs-string">'Preprocessed'</span>)
os.<span class="hljs-title function_">makedirs</span>(preprocessed_folder, exist_ok=<span class="hljs-title class_">True</span>)

...

# 학습 데이터를 리샘플링하고 새로운 이동 평균을 계산합니다.
X_train_resampled, Y_train_resampled = <span class="hljs-title function_">resample_and_compute_moving_averages</span>(X_train, Y_train)

# <span class="hljs-title class_">DataFrame</span>을 생성하고 <span class="hljs-variable constant_">CSV</span>로 저장합니다.
train_df = pd.<span class="hljs-title class_">DataFrame</span>(np.<span class="hljs-title function_">vstack</span>((X_train_resampled, Y_train_resampled)).<span class="hljs-property">T</span>,
                        columns=[<span class="hljs-string">'Voltage'</span>, <span class="hljs-string">'Current'</span>, <span class="hljs-string">'Temperature'</span>, <span class="hljs-string">'Average Voltage'</span>, <span class="hljs-string">'Average Current'</span>, <span class="hljs-string">'SOC'</span>])
train_df.<span class="hljs-title function_">to_csv</span>(os.<span class="hljs-property">path</span>.<span class="hljs-title function_">join</span>(preprocessed_folder, <span class="hljs-string">'resampled_training_data.csv'</span>), index=<span class="hljs-title class_">False</span>)

# 테스트 데이터를 추출하고 리샘플링합니다.
test_data_files = [<span class="hljs-string">'n10degC'</span>, <span class="hljs-string">'0degC'</span>, <span class="hljs-string">'10degC'</span>, <span class="hljs-string">'25degC'</span>]
resampled_test_data_shapes = {}

<span class="hljs-keyword">for</span> i, test_data_full <span class="hljs-keyword">in</span> <span class="hljs-title function_">enumerate</span>(fds_test):
    X_test = test_data_full[<span class="hljs-string">'X'</span>]
    Y_test = test_data_full[<span class="hljs-string">'Y'</span>]
    X_test_resampled, Y_test_resampled = <span class="hljs-title function_">resample_and_compute_moving_averages</span>(X_test, Y_test)
    test_df = pd.<span class="hljs-title class_">DataFrame</span>(np.<span class="hljs-title function_">vstack</span>((X_test_resampled, Y_test_resampled)).<span class="hljs-property">T</span>,
                           columns=[<span class="hljs-string">'Voltage'</span>, <span class="hljs-string">'Current'</span>, <span class="hljs-string">'Temperature'</span>, <span class="hljs-string">'Average Voltage'</span>, <span class="hljs-string">'Average Current'</span>, <span class="hljs-string">'SOC'</span>])
    test_df.<span class="hljs-title function_">to_csv</span>(os.<span class="hljs-property">path</span>.<span class="hljs-title function_">join</span>(preprocessed_folder, f<span class="hljs-string">'resampled_test_data_{test_data_files[i]}.csv'</span>), index=<span class="hljs-title class_">False</span>)
    resampled_test_data_shapes[test_data_files[i]] = (X_test_resampled.<span class="hljs-property">shape</span>, Y_test_resampled.<span class="hljs-property">shape</span>)
</code></pre>
<h2>단계 3 — 모델 선택</h2>
<p>배터리 충전 상태 (SOC) 및 건강 상태 (SOH)를 추정하기 위해 여러 머신러닝 알고리즘이 광범위하게 연구되어 왔습니다. 네 가지 가장 탁월한 유형은 얕은 신경망 (NN), 딥러닝 (DL), 서포트 벡터 머신 (SVM), 그리고 가우시안 프로세스 회귀 (GPR)입니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_4.png" alt="이미지"></p>
<p>얕은 신경망(SNN)
얕은 신경망(Figure 4)은 한 개 또는 두 개의 은닉층으로 구성됩니다. 딥 러닝과 비교하면 비교적 단순하지만 전력 특성의 비선형성을 모델링하기에 충분히 강력합니다. 단층 신경망은 더 간단한 구조로, 계산 능력과 메모리가 덜 필요하여 자원 제한적인 임베디드 장치에서 실시간 SOC 및 SOH 추정에 적합합니다. 이러한 모델은 전압, 전류, 온도와 같은 다양한 입력 특성으로부터 SOC 및 SOH를 예측하는 데 학습될 수 있습니다.</p>
<p><img src="/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_5.png" alt="이미지"></p>
<p>딥 러닝(DL)
딥 러닝 모델인 딥 신경망(DNNs — Figure 5) 및 합성곱 신경망(CNNs)과 같이 여러 층을 가지고 있어 데이터의 복잡한 패턴과 상호작용을 포착할 수 있습니다. DL 모델은 입력 특성과 SOC 또는 SOH 사이의 복잡한 관계를 학습하여 매우 정확한 추정을 제공할 수 있습니다. 그러나 그들의 복잡성은 더 많은 계산 자원과 메모리를 필요로 하며, 이는 일부 임베디드 시스템에 제약 요인이 될 수 있습니다. 그러나 임베디드 하드웨어의 발전으로 실시간 응용 프로그램에서 딥 러닝 모델을 배포하긴 점점 더 가능해지고 있습니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_6.png" alt="SVM"></p>
<p>서포트 벡터 머신(SVM)
서포트 벡터 머신(도표 6)은 분류와 회귀 작업 모두에 사용할 수 있는 지도 학습 모델입니다. SOC 및 SOH 추정을 위해 SVM은 고차원 데이터를 효과적으로 처리할 수 있으며, 특히 훈련 데이터가 제한적인 상황에서 과적합에 강합니다. SVM은 데이터를 서로 다른 클래스로 분리하거나 연속 값을 예측하는 데 최적의 초평면을 찾아 작동합니다. 상대적으로 낮은 계산 요구로 인해 리소스가 제한된 임베디드 응용 프로그램에 적합합니다.</p>
<p><img src="/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_7.png" alt="GPR"></p>
<p>가우시안 프로세스 회귀(GPR)
가우시안 프로세스 회귀(도표 7)는 예측 뿐만 아니라 불확실성 추정을 제공하는 비모수적인 확률적 접근 방식입니다. SOC 및 SOH 추정에 특히 유용한 GPR은 운영 조건 및 노화로 인한 배터리 행동의 기저 불확실성을 모델링할 수 있습니다. GPR 모델은 유연하며 새로운 데이터로 업데이트할 수 있어, 배터리 수명 주기 내의 변화에 적응할 수 있습니다. 이러한 이유로 GPR 모델을 채택하여 구현하기로 결정했습니다.</p>
<div class="content-ad"></div>
<p>하지만 GPR은 계산이 많이 필요하며, 실시간 임베디드 애플리케이션에 적합하게 만들기 위해 효율적인 구현이 필요합니다. 또는 장치 외부에서 처리를 수행하고 최적화된 후에 훈련된 모델을 배포할 수도 있습니다. 이것이 우리가 취할 접근 방식입니다.</p>
<h2>파트 4</h2>
<p>시리즈의 제 4부에서 배터리 SOC 예측기의 ML 프로세스를 계속할 것입니다. 이는 모델을 훈련하고 evaluate하는 데 중점을 둘 것입니다.</p>
<h2>참고문헌</h2>
<div class="content-ad"></div>
<p>[1] Kollmeyer, Philip; Vidal, Carlos; Naguib, Mina; Skells, Michael (2020), “LG 18650HG2 Li-ion Battery Data and Example Deep Neural Network xEV SOC Estimator Script”, Mendeley Data, V3, doi: 10.17632/cp3473x7xv.3</p>
<p>만약 이 글을 즐겁게 보셨고 제 글쓰기를 지원하고 싶으시다면, 팔로우를 누르거나 (최대 50번), 강조하기, 혹은 댓글을 남겨주세요! 혹은 다른 방법으로 커피를 사주시거나 구독해주셔도 됩니다. 새 글이 올라올 때마다 이메일을 받아보실 수 있습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"임베디드 AI  머신 러닝을 사용하여 배터리 충전 상태 확인 방법","description":"","date":"2024-06-30 23:36","slug":"2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning","content":"\n\n## 배터리 충전 상태(SOC)는 배터리의 잔여 전하를 총 용량의 백분율로 표시합니다. 이 정보는 내장 장치의 에너지 관리에 매우 중요합니다. SOC를 정확하게 추정하는 것은 리튬이온 배터리의 복잡한 행동에 영향을 받아 어려운 작업입니다. 이는 온도, 배터리 건강 상태, 그리고 SOC 자체와 같은 요소들에 의해 영향을 받기 때문입니다. SOC를 추정하기 위한 전통적인 방법인 전기화학 모델은 정확한 매개변수와 배터리의 조성 및 물리적 특성에 대한 심층적인 이해를 요구합니다. 반면, 머신 러닝 모델은 데이터 기반 접근 방식을 제공하여 배터리의 행동에 대해 덜 자세한 지식만으로도 SOC 추정을 단순화시키므로 내장 시스템에 구현하기에 적합합니다.\n\n![이미지](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_0.png)\n\n## 머신 러닝 과정\n\n내장형 AI 시리즈의 제1부에서, ML을 사용하여 값들을 예측하는 과정을 설명했습니다 (그림 1).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_1.png)\n\nPart 2에서 설명한 것처럼, 배터리 방전 곡선은 대부분의 사용 가능 범위에 걸쳐 거의 선형입니다. 그러므로 우리는 Part 1에서 설명한 선형 회귀 모델을 사용할 수 있을 것입니다. 그러나 출력물은 룩업 테이블 및 보간 방법과 매우 유사할 것입니다. 더 정확하고 유연한 예측을 제공해야 할 다른 접근 방식이 있습니다.\n\n이러한 옵션을 탐색하기 위해 ML 프로세스 플로우차트의 단계를 따를 것입니다.\n\n## 단계 1 — 문제 정의\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n배터리의 SOC를 정확하게 예측하는 ML 모델을 개발하는 것이 목표입니다. 이 모델은 전압을 기반으로 배터리의 SOC를 예측하는 데 사용되며 전류, 온도, 그리고 시간과 같은 관련 특징도 함께 고려됩니다 (Figure 2). 모델은 다양한 작동 조건과 배터리 상태에 걸쳐 잘 일반화되어야 하며, 이는 실시간 응용 프로그램에서 신뢰할 수 있는 SOC 추정을 보장합니다.\n\nInputs and Features\n\n- Voltage (V): 배터리의 순간 전압을 나타내는 주요 입력 특징입니다.\n- Current (I): 배터리에 공급되거나 공급되는 전류로, 전압 값에 영향을 줄 수 있습니다.\n- Temperature (T): 주변 온도 또는 배터리의 온도로, 온도 변화가 배터리 성능에 영향을 줍니다.\n- Time (t): 전압이 측정된 시간으로, 배터리의 방전 또는 충전 주기를 이해하는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 전하 상태 (SOC): 배터리의 예상 SOC로서 총 용량의 백분율로 표시됩니다.\n\n![image](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_2.png)\n\n## 단계 2 — 훈련 데이터 수집 및 정리\n\n이 단계에서 가장 많은 작업을 수행하게 될 것입니다. 모델을 훈련시킬 데이터가 더 좋을수록 예측이 더 좋아질 것입니다. 우리는 맥마스터 대학교에서 발행한 LG 18650HG2 리튬이온 배터리에 대한 Digital Commons 데이터를 사용할 것입니다. 아래의 Python 스크립트를 사용하여 이 데이터셋을 다운로드할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport os\nimport requests\nimport zipfile\nimport numpy as np\n\n# 다운로드 할 파일의 URL\nurl = \"https://data.mendeley.com/public-files/datasets/cp3473x7xv/files/ad7ac5c9-2b9e-458a-a91f-6f3da449bdfb/file_downloaded\"\n\n# 추출된 ZIP 파일이 들어 있는 출력 폴더\noutput_folder = os.path.expanduser(\"~/Documents/GitHub/Embedded-AI/data/LGHG2@n10C_to_25degC\")\nos.makedirs(output_folder, exist_ok=True)\n\n# 데이터 세트 다운로드 및 추출\ntrain_folder = os.path.join(output_folder, \"Train\")\ntest_folder = os.path.join(output_folder, \"Test\")\nif not os.path.exists(train_folder) or not os.path.exists(test_folder):\n    print(\"LGHG2@n10C_to_25degC.zip (56 MB) 다운로드 중... \")\n    download_folder = os.path.dirname(output_folder)\n    filename = os.path.join(download_folder, \"LGHG2@n10C_to_25degC.zip\")\n    response = requests.get(url)\n    with open(filename, 'wb') as file:\n        file.write(response.content)\n    with zipfile.ZipFile(filename, 'r') as zip_ref:\n        zip_ref.extractall(output_folder)\n```\n\n이 스크립트에서 output_folder를 수정하여 데이터를 저장할 위치를 지정하십시오. 이 데이터를 사용하기 전에 데이터가 어떻게 구성되어 있는지 이해해야 합니다. Figure 3는 추출된 데이터 세트의 내용을 보여줍니다.\n\n\u003cimg src=\"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_3.png\" /\u003e\n\n각 파일에는 다섯 가지 예측 변수(전압, 전류, 온도, 평균 전압 및 평균 전류)로 이루어진 시계열 X와 하나의 대상 SOC로 이루어진 시계열 Y가 포함되어 있습니다. 서로 다른 환경 온도에서 수집된 데이터를 나타내는 하나의 훈련 파일과 네 개의 테스트 파일이 있습니다. 유일한 문제는 데이터가 MATLAB 형식(.mat)으로 저장되어 있다는 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n.mat 파일은 MATLAB에서 변수를 저장하는 데 사용되는 이진 데이터 파일입니다. 배열, 행렬 및 기타 데이터 유형을 저장할 수 있습니다. 이진 파일이기 때문에 텍스트 편집기에서는 읽을 수 없지만, Python의 scipy.io 모듈을 사용하여 이러한 파일을 읽고 쓸 수 있습니다.\n\n```python\nimport os\nimport scipy.io\nimport numpy as np\n\n# .mat 파일의 처음 10줄을 읽어 출력\ndef read_and_print_mat_files(folder):\n    for filename in os.listdir(folder):\n        if filename.endswith(\".mat\"):\n            filepath = os.path.join(folder, filename)\n            mat_data = scipy.io.loadmat(filepath)\n            print(f\"{filename} 내용:\")\n            for key in mat_data:\n                if not key.startswith(\"__\"):\n                    data = mat_data[key]\n                    if isinstance(data, np.ndarray) and data.ndim \u003e 1:  \n                        print(f\"{key}:\")\n                        print(data[:10])  \n                    else:\n                        print(f\"{key}: {data}\")\n            print(\"\\n\")\n\n# 폴더 경로\ntrain_folder = os.path.expanduser(\"~/Documents/GitHub/Embedded-AI/data/LGHG2@n10C_to_25degC/Train\")\ntest_folder = os.path.expanduser(\"~/Documents/GitHub/Embedded-AI/data/LGHG2@n10C_to_25degC/Test\")\n\n# Train 및 Test 파일의 내용 읽고 출력\nprint(\"훈련 데이터 파일:\")\nread_and_print_mat_files(train_folder)\nprint(\"\\n테스트 데이터 파일:\")\nread_and_print_mat_files(test_folder)\n```\n\n훈련 데이터의 처음 다섯 행의 내용은 아래와 같이 표시됩니다.\n\n```python\nTRAIN_LGHG2@n10degC_to_25degC_Norm_5Inputs.mat 내용:\nX:\n[[0.38514793 0.38515183 0.38515573 ... 0.47884278 0.4789612  0.4789612 ]\n [0.75102009 0.75102009 0.75102009 ... 0.75102009 0.75102009 0.75102009]\n [0.30310108 0.30459129 0.3060815  ... 0.00847709 0.00847709 0.00847709]\n [0.38514793 0.38514988 0.38515183 ... 0.45983939 0.45997861 0.46011672]\n [0.75102009 0.75102009 0.75102009 ... 0.75102009 0.75102009 0.75102009]]\nY:\n[[0.20641667 0.20641667 0.20641667 ... 0.28324333 0.28324333 0.28324333]]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nX는 각 행이 다음 다섯 개의 예측변수 중 하나에 해당하는 2D 배열입니다:\n\n- 전압\n- 전류\n- 온도\n- 평균 전압\n- 평균 전류\n\n각 열은 Series에서 다른 시간점을 나타내며, 측정은 1초마다 이루어졌습니다. 예를 들어, 첫 번째 행은 전압: [0.38514793, 0.38515183, 0.38515573, …, 0.47884278, 0.4789612, 0.4789612]이고, 두 번째 행은 전류: [0.75102009, 0.75102009, 0.75102009, …, 0.75102009, 0.75102009, 0.75102009]이며, 나머지 예측변수에 대한 내용도 같은 방식입니다.\n\nY도 하나의 행으로 이루어진 2D 배열이지만, SOC가 단일 대상 변수임을 나타냅니다. 각 열은 해당 시간점에서의 SOC를 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 파일 내용을 이해했으므로 훈련 및 테스트를 위해 데이터 저장소를 로드할 수 있습니다.\n\n```js\ndef read_mat_files(folder):\n    data = []\n    for filename in os.listdir(folder):\n        if filename.endswith(\".mat\"):\n            filepath = os.path.join(folder, filename)\n            mat_data = scipy.io.loadmat(filepath)\n            data.append(mat_data)\n    return data\n\n# 훈련 데이터와 테스트 데이터를 위한 파일 데이터 저장소 생성\nfds_train = read_mat_files(train_folder)\nfds_test = read_mat_files(test_folder)\n\n# 데이터 저장소에 있는 모든 데이터 읽기\ntrain_data_full = fds_train[0]\ntest_data_full_n10deg = fds_test[0]\ntest_data_full_0deg = fds_test[1]\ntest_data_full_10deg = fds_test[2]\ntest_data_full_25deg = fds_test[3]\n\n# 데이터 배열의 모양 출력하여 구조를 이해하기\nprint(\"train_data_full['X']의 모양: \", train_data_full['X'].shape)\nprint(\"train_data_full['Y']의 모양: \", train_data_full['Y'].shape)\nprint(\"test_data_full_n10deg['X']의 모양: \", test_data_full_n10deg['X'].shape)\nprint(\"test_data_full_n10deg['Y']의 모양: \", test_data_full_n10deg['Y'].shape)\n```\n\nshape 속성은 배열의 차원을 나타내는 튜플을 반환합니다. 2D 배열의 경우 shape는 (행, 열)로 이루어진 튜플을 반환합니다.\n\n```js\ntrain_data_full['X']의 모양:  (5, 669956)\ntrain_data_full['Y']의 모양:  (1, 669956)\ntest_data_full_n10deg['X']의 모양:  (5, 47517)\ntest_data_full_n10deg['Y']의 모양:  (1, 47517)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n훈련 데이터 파일 내에서, 주변 온도 측정 값은 다음과 같이 분할되어 있습니다:\n\n```js\nidx0   = 1 - 184257        # 온도 = 0°C\nidx10  = 184258 - 337973   # 온도 = 10°C\nidx25  = 337974 - 510530   # 온도 = 25°C\nidxN10 = 510531 - 669956   # 온도 = -10°C\n```\n\n우리가 출력한 훈련 데이터의 첫 5개 행을 살펴보면, X의 3번째 행이 온도를 나타냅니다. 이 값이 0이 될 것으로 예상할 수 있지만, 이 값들은 측정되고 정규화된 값입니다. 모든 예측 변수는 모델 수렴 및 성능을 향상시키기 위해 정규화되었습니다.\n\n훈련 온도 데이터 세트를 분리하려면, 아래 코드를 로딩 스크립트에 추가하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n# train_data_full에서 X와 Y 추출하기\nX = train_data_full['X']\nY = train_data_full['Y']\n\n# 인덱스 범위 정의\nidx0 = slice(0, 184257)\nidx10 = slice(184257, 337973)\nidx25 = slice(337973, 510530)\nidxN10 = slice(510530, 669956)\n\n# 데이터 세그먼트 추출\nX_idx0 = X[:, idx0]\nY_idx0 = Y[:, idx0]\n\nX_idx10 = X[:, idx10]\nY_idx10 = Y[:, idx10]\n\nX_idx25 = X[:, idx25]\nY_idx25 = Y[:, idx25]\n\nX_idxN10 = X[:, idxN10]\nY_idxN10 = Y[:, idxN10]\n\n# 추출 확인을 위해 형태 출력\nprint(f'X_idx0 형태: {X_idx0.shape}, Y_idx0 형태: {Y_idx0.shape}')\nprint(f'X_idx10 형태: {X_idx10.shape}, Y_idx10 형태: {Y_idx10.shape}')\nprint(f'X_idx25 형태: {X_idx25.shape}, Y_idx25 형태: {Y_idx25.shape}')\nprint(f'X_idxN10 형태: {X_idxN10.shape}, Y_idxN10 형태: {Y_idxN10.shape}')\r\n```\n\n트레이닝 데이터에는 총 669,956개의 열이 있어서 처리하기에는 조금 많습니다. 간단하게 만들기 위해 데이터를 다시 샘플링하여 매 100번째 점을 가져와 평균 전압 및 평균 전류 예측 변수의 새로운 이동 평균값을 계산할 것입니다. 재계산된 이동 평균은 각 포인트에 대해 최근 5개 샘플을 사용합니다. 이는 i-5부터 i까지의 값들의 평균을 계산하기 위해 루프를 사용하여 수행됩니다. 이동 평균을 계산하는 데 최근 5개 샘플을 사용하는 것은 시계열 분석에서 일반적인 기술입니다. 이 접근 방식은 데이터를 부드럽게 만들면서 최근 변화에 반응성을 유지하는 균형을 제공합니다.\n\n데이터 전처리를 돕기 위해 파이썬 함수를 작성했습니다.\n\n```js\r\ndef resample_and_compute_moving_averages(X, Y, step=100):\r\n    # 데이터 재샘플링 (매 `step`번째 포인트 가져오기)\r\n    X_resampled = X[:, ::step]\r\n    Y_resampled = Y[:, ::step]\r\n    \r\n    # 새로운 이동 평균 계산\r\n    n = X_resampled.shape[1]\r\n    avg_voltage_idx = 3  # 4번째 열이 평균 전압이라고 가정\r\n    avg_current_idx = 4  # 5번째 열이 평균 전류이라고 가정\r\n    \r\n    new_avg_voltage = np.empty(n)\r\n    new_avg_current = np.empty(n)\r\n    \r\n    for i in range(n):\r\n        new_avg_voltage[i] = np.mean(X_resampled[0, max(0, i-5):i+1])\r\n        new_avg_current[i] = np.mean(X_resampled[1, max(0, i-5):i+1])\r\n    \r\n    X_resampled[avg_voltage_idx, :n] = new_avg_voltage\r\n    X_resampled[avg_current_idx, :n] = new_avg_current\r\n    \r\n    return X_resampled, Y_resampled\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n학습 및 테스트 데이터 재샘플링은 이제 간단합니다.\n\n```js\n# 학습 데이터를 재샘플링하고 새로운 이동 평균 계산\nX_train_resampled, Y_train_resampled = resample_and_compute_moving_averages(X_train, Y_train)\n\n# 테스트 데이터 추출 및 재샘플링\nX_test_n10deg = test_data_full_n10deg['X']\nY_test_n10deg = test_data_full_n10deg['Y']\nX_test_n10deg_resampled, Y_test_n10deg_resampled = resample_and_compute_moving_averages(X_test_n10deg, Y_test_n10deg)\n\nX_test_0deg = test_data_full_0deg['X']\nY_test_0deg = test_data_full_0deg['Y']\nX_test_0deg_resampled, Y_test_0deg_resampled = resample_and_compute_moving_averages(X_test_0deg, Y_test_0deg)\n\nX_test_10deg = test_data_full_10deg['X']\nY_test_10deg = test_data_full_10deg['Y']\nX_test_10deg_resampled, Y_test_10deg_resampled = resample_and_compute_moving_averages(X_test_10deg, Y_test_10deg)\n\nX_test_25deg = test_data_full_25deg['X']\nY_test_25deg = test_data_full_25deg['Y']\nX_test_25deg_resampled, Y_test_25deg_resampled = resample_and_compute_moving_averages(X_test_25deg, Y_test_25deg)\n\n# 재샘플링 확인을 위해 형태 출력\nprint(f'재샘플링 후 학습 데이터 형태: X={X_train_resampled.shape}, Y={Y_train_resampled.shape}')\nprint(f'n10degC 테스트 데이터 형태: X={X_test_n10deg_resampled.shape}, Y={Y_test_n10deg_resampled.shape}')\nprint(f'0degC 테스트 데이터 형태: X={X_test_0deg_resampled.shape}, Y={Y_test_0deg_resampled.shape}')\nprint(f'10degC 테스트 데이터 형태: X={X_test_10deg_resampled.shape}, Y={Y_test_10deg_resampled.shape}')\nprint(f'25degC 테스트 데이터 형태: X={X_test_25deg_resampled.shape}, Y={Y_test_25deg_resampled.shape}')\n```\n\n데이터 처리 스케치의 전체 버전은 Reefwing Gist에서 제공됩니다. 데이터셋 크기를 재샘플링한 후에는 아래와 같은 크기가 됩니다.\n\n```js\n재샘플링 후 학습 데이터 형태: X=(5, 6700), Y=(1, 6700)\nn10degC 테스트 데이터 형태: X=(5, 476), Y=(1, 476)\n0degC 테스트 데이터 형태: X=(5, 443), Y=(1, 443)\n10degC 테스트 데이터 형태: X=(5, 426), Y=(1, 426)\n25degC 테스트 데이터 형태: X=(5, 393), Y=(1, 393)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 모든 전처리된 학습 및 테스트 데이터를 Preprocessed라는 새 하위 디렉토리에 저장할 거에요. 이 파일들은 CSV 형식으로 저장되며, 쉽게 읽고 쓸 수 있어서 사용자가 쉽게 확인할 수 있어요. 더 큰 데이터셋의 경우 HDF5 (계층적 데이터 형식)를 사용하면 효율적으로 대량의 데이터를 저장할 수 있고 복잡한 데이터 구조를 지원해요. 이는 과학 계산에서도 널리 사용되고 있어요. 관련 추가 코드는 아래에 나와 있어요.\n\n```js\npreprocessed_folder = os.path.join(output_folder, 'Preprocessed')\nos.makedirs(preprocessed_folder, exist_ok=True)\n\n...\n\n# 학습 데이터를 리샘플링하고 새로운 이동 평균을 계산합니다.\nX_train_resampled, Y_train_resampled = resample_and_compute_moving_averages(X_train, Y_train)\n\n# DataFrame을 생성하고 CSV로 저장합니다.\ntrain_df = pd.DataFrame(np.vstack((X_train_resampled, Y_train_resampled)).T,\n                        columns=['Voltage', 'Current', 'Temperature', 'Average Voltage', 'Average Current', 'SOC'])\ntrain_df.to_csv(os.path.join(preprocessed_folder, 'resampled_training_data.csv'), index=False)\n\n# 테스트 데이터를 추출하고 리샘플링합니다.\ntest_data_files = ['n10degC', '0degC', '10degC', '25degC']\nresampled_test_data_shapes = {}\n\nfor i, test_data_full in enumerate(fds_test):\n    X_test = test_data_full['X']\n    Y_test = test_data_full['Y']\n    X_test_resampled, Y_test_resampled = resample_and_compute_moving_averages(X_test, Y_test)\n    test_df = pd.DataFrame(np.vstack((X_test_resampled, Y_test_resampled)).T,\n                           columns=['Voltage', 'Current', 'Temperature', 'Average Voltage', 'Average Current', 'SOC'])\n    test_df.to_csv(os.path.join(preprocessed_folder, f'resampled_test_data_{test_data_files[i]}.csv'), index=False)\n    resampled_test_data_shapes[test_data_files[i]] = (X_test_resampled.shape, Y_test_resampled.shape)\n```\n\n## 단계 3 — 모델 선택\n\n배터리 충전 상태 (SOC) 및 건강 상태 (SOH)를 추정하기 위해 여러 머신러닝 알고리즘이 광범위하게 연구되어 왔습니다. 네 가지 가장 탁월한 유형은 얕은 신경망 (NN), 딥러닝 (DL), 서포트 벡터 머신 (SVM), 그리고 가우시안 프로세스 회귀 (GPR)입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_4.png)\n\n얕은 신경망(SNN)\n얕은 신경망(Figure 4)은 한 개 또는 두 개의 은닉층으로 구성됩니다. 딥 러닝과 비교하면 비교적 단순하지만 전력 특성의 비선형성을 모델링하기에 충분히 강력합니다. 단층 신경망은 더 간단한 구조로, 계산 능력과 메모리가 덜 필요하여 자원 제한적인 임베디드 장치에서 실시간 SOC 및 SOH 추정에 적합합니다. 이러한 모델은 전압, 전류, 온도와 같은 다양한 입력 특성으로부터 SOC 및 SOH를 예측하는 데 학습될 수 있습니다.\n\n![이미지](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_5.png)\n\n딥 러닝(DL)\n딥 러닝 모델인 딥 신경망(DNNs — Figure 5) 및 합성곱 신경망(CNNs)과 같이 여러 층을 가지고 있어 데이터의 복잡한 패턴과 상호작용을 포착할 수 있습니다. DL 모델은 입력 특성과 SOC 또는 SOH 사이의 복잡한 관계를 학습하여 매우 정확한 추정을 제공할 수 있습니다. 그러나 그들의 복잡성은 더 많은 계산 자원과 메모리를 필요로 하며, 이는 일부 임베디드 시스템에 제약 요인이 될 수 있습니다. 그러나 임베디드 하드웨어의 발전으로 실시간 응용 프로그램에서 딥 러닝 모델을 배포하긴 점점 더 가능해지고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![SVM](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_6.png)\n\n서포트 벡터 머신(SVM)\n서포트 벡터 머신(도표 6)은 분류와 회귀 작업 모두에 사용할 수 있는 지도 학습 모델입니다. SOC 및 SOH 추정을 위해 SVM은 고차원 데이터를 효과적으로 처리할 수 있으며, 특히 훈련 데이터가 제한적인 상황에서 과적합에 강합니다. SVM은 데이터를 서로 다른 클래스로 분리하거나 연속 값을 예측하는 데 최적의 초평면을 찾아 작동합니다. 상대적으로 낮은 계산 요구로 인해 리소스가 제한된 임베디드 응용 프로그램에 적합합니다.\n\n![GPR](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_7.png)\n\n가우시안 프로세스 회귀(GPR)\n가우시안 프로세스 회귀(도표 7)는 예측 뿐만 아니라 불확실성 추정을 제공하는 비모수적인 확률적 접근 방식입니다. SOC 및 SOH 추정에 특히 유용한 GPR은 운영 조건 및 노화로 인한 배터리 행동의 기저 불확실성을 모델링할 수 있습니다. GPR 모델은 유연하며 새로운 데이터로 업데이트할 수 있어, 배터리 수명 주기 내의 변화에 적응할 수 있습니다. 이러한 이유로 GPR 모델을 채택하여 구현하기로 결정했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 GPR은 계산이 많이 필요하며, 실시간 임베디드 애플리케이션에 적합하게 만들기 위해 효율적인 구현이 필요합니다. 또는 장치 외부에서 처리를 수행하고 최적화된 후에 훈련된 모델을 배포할 수도 있습니다. 이것이 우리가 취할 접근 방식입니다.\n\n## 파트 4\n\n시리즈의 제 4부에서 배터리 SOC 예측기의 ML 프로세스를 계속할 것입니다. 이는 모델을 훈련하고 evaluate하는 데 중점을 둘 것입니다.\n\n## 참고문헌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[1] Kollmeyer, Philip; Vidal, Carlos; Naguib, Mina; Skells, Michael (2020), “LG 18650HG2 Li-ion Battery Data and Example Deep Neural Network xEV SOC Estimator Script”, Mendeley Data, V3, doi: 10.17632/cp3473x7xv.3\n\n만약 이 글을 즐겁게 보셨고 제 글쓰기를 지원하고 싶으시다면, 팔로우를 누르거나 (최대 50번), 강조하기, 혹은 댓글을 남겨주세요! 혹은 다른 방법으로 커피를 사주시거나 구독해주셔도 됩니다. 새 글이 올라올 때마다 이메일을 받아보실 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_0.png"},"coverImage":"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_0.png","tag":["Tech"],"readingTime":15},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e배터리 충전 상태(SOC)는 배터리의 잔여 전하를 총 용량의 백분율로 표시합니다. 이 정보는 내장 장치의 에너지 관리에 매우 중요합니다. SOC를 정확하게 추정하는 것은 리튬이온 배터리의 복잡한 행동에 영향을 받아 어려운 작업입니다. 이는 온도, 배터리 건강 상태, 그리고 SOC 자체와 같은 요소들에 의해 영향을 받기 때문입니다. SOC를 추정하기 위한 전통적인 방법인 전기화학 모델은 정확한 매개변수와 배터리의 조성 및 물리적 특성에 대한 심층적인 이해를 요구합니다. 반면, 머신 러닝 모델은 데이터 기반 접근 방식을 제공하여 배터리의 행동에 대해 덜 자세한 지식만으로도 SOC 추정을 단순화시키므로 내장 시스템에 구현하기에 적합합니다.\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e머신 러닝 과정\u003c/h2\u003e\n\u003cp\u003e내장형 AI 시리즈의 제1부에서, ML을 사용하여 값들을 예측하는 과정을 설명했습니다 (그림 1).\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003ePart 2에서 설명한 것처럼, 배터리 방전 곡선은 대부분의 사용 가능 범위에 걸쳐 거의 선형입니다. 그러므로 우리는 Part 1에서 설명한 선형 회귀 모델을 사용할 수 있을 것입니다. 그러나 출력물은 룩업 테이블 및 보간 방법과 매우 유사할 것입니다. 더 정확하고 유연한 예측을 제공해야 할 다른 접근 방식이 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 옵션을 탐색하기 위해 ML 프로세스 플로우차트의 단계를 따를 것입니다.\u003c/p\u003e\n\u003ch2\u003e단계 1 — 문제 정의\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e배터리의 SOC를 정확하게 예측하는 ML 모델을 개발하는 것이 목표입니다. 이 모델은 전압을 기반으로 배터리의 SOC를 예측하는 데 사용되며 전류, 온도, 그리고 시간과 같은 관련 특징도 함께 고려됩니다 (Figure 2). 모델은 다양한 작동 조건과 배터리 상태에 걸쳐 잘 일반화되어야 하며, 이는 실시간 응용 프로그램에서 신뢰할 수 있는 SOC 추정을 보장합니다.\u003c/p\u003e\n\u003cp\u003eInputs and Features\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVoltage (V): 배터리의 순간 전압을 나타내는 주요 입력 특징입니다.\u003c/li\u003e\n\u003cli\u003eCurrent (I): 배터리에 공급되거나 공급되는 전류로, 전압 값에 영향을 줄 수 있습니다.\u003c/li\u003e\n\u003cli\u003eTemperature (T): 주변 온도 또는 배터리의 온도로, 온도 변화가 배터리 성능에 영향을 줍니다.\u003c/li\u003e\n\u003cli\u003eTime (t): 전압이 측정된 시간으로, 배터리의 방전 또는 충전 주기를 이해하는 데 도움이 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e전하 상태 (SOC): 배터리의 예상 SOC로서 총 용량의 백분율로 표시됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003e단계 2 — 훈련 데이터 수집 및 정리\u003c/h2\u003e\n\u003cp\u003e이 단계에서 가장 많은 작업을 수행하게 될 것입니다. 모델을 훈련시킬 데이터가 더 좋을수록 예측이 더 좋아질 것입니다. 우리는 맥마스터 대학교에서 발행한 LG 18650HG2 리튬이온 배터리에 대한 Digital Commons 데이터를 사용할 것입니다. 아래의 Python 스크립트를 사용하여 이 데이터셋을 다운로드할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e requests\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e zipfile\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\n# 다운로드 할 파일의 \u003cspan class=\"hljs-variable constant_\"\u003eURL\u003c/span\u003e\nurl = \u003cspan class=\"hljs-string\"\u003e\"https://data.mendeley.com/public-files/datasets/cp3473x7xv/files/ad7ac5c9-2b9e-458a-a91f-6f3da449bdfb/file_downloaded\"\u003c/span\u003e\n\n# 추출된 \u003cspan class=\"hljs-variable constant_\"\u003eZIP\u003c/span\u003e 파일이 들어 있는 출력 폴더\noutput_folder = os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexpanduser\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"~/Documents/GitHub/Embedded-AI/data/LGHG2@n10C_to_25degC\"\u003c/span\u003e)\nos.\u003cspan class=\"hljs-title function_\"\u003emakedirs\u003c/span\u003e(output_folder, exist_ok=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\n# 데이터 세트 다운로드 및 추출\ntrain_folder = os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(output_folder, \u003cspan class=\"hljs-string\"\u003e\"Train\"\u003c/span\u003e)\ntest_folder = os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(output_folder, \u003cspan class=\"hljs-string\"\u003e\"Test\"\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexists\u003c/span\u003e(train_folder) or not os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexists\u003c/span\u003e(test_folder):\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"LGHG2@n10C_to_25degC.zip (56 MB) 다운로드 중... \"\u003c/span\u003e)\n    download_folder = os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edirname\u003c/span\u003e(output_folder)\n    filename = os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(download_folder, \u003cspan class=\"hljs-string\"\u003e\"LGHG2@n10C_to_25degC.zip\"\u003c/span\u003e)\n    response = requests.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(url)\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(filename, \u003cspan class=\"hljs-string\"\u003e'wb'\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efile\u003c/span\u003e:\n        file.\u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e(response.\u003cspan class=\"hljs-property\"\u003econtent\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e zipfile.\u003cspan class=\"hljs-title class_\"\u003eZipFile\u003c/span\u003e(filename, \u003cspan class=\"hljs-string\"\u003e'r'\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ezip_ref\u003c/span\u003e:\n        zip_ref.\u003cspan class=\"hljs-title function_\"\u003eextractall\u003c/span\u003e(output_folder)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 스크립트에서 output_folder를 수정하여 데이터를 저장할 위치를 지정하십시오. 이 데이터를 사용하기 전에 데이터가 어떻게 구성되어 있는지 이해해야 합니다. Figure 3는 추출된 데이터 세트의 내용을 보여줍니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_3.png\"\u003e\n\u003cp\u003e각 파일에는 다섯 가지 예측 변수(전압, 전류, 온도, 평균 전압 및 평균 전류)로 이루어진 시계열 X와 하나의 대상 SOC로 이루어진 시계열 Y가 포함되어 있습니다. 서로 다른 환경 온도에서 수집된 데이터를 나타내는 하나의 훈련 파일과 네 개의 테스트 파일이 있습니다. 유일한 문제는 데이터가 MATLAB 형식(.mat)으로 저장되어 있다는 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e.mat 파일은 MATLAB에서 변수를 저장하는 데 사용되는 이진 데이터 파일입니다. 배열, 행렬 및 기타 데이터 유형을 저장할 수 있습니다. 이진 파일이기 때문에 텍스트 편집기에서는 읽을 수 없지만, Python의 scipy.io 모듈을 사용하여 이러한 파일을 읽고 쓸 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e scipy.io\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\n\u003cspan class=\"hljs-comment\"\u003e# .mat 파일의 처음 10줄을 읽어 출력\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eread_and_print_mat_files\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efolder\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e filename \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e os.listdir(folder):\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e filename.endswith(\u003cspan class=\"hljs-string\"\u003e\".mat\"\u003c/span\u003e):\n            filepath = os.path.join(folder, filename)\n            mat_data = scipy.io.loadmat(filepath)\n            \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"\u003cspan class=\"hljs-subst\"\u003e{filename}\u003c/span\u003e 내용:\"\u003c/span\u003e)\n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e mat_data:\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enot\u003c/span\u003e key.startswith(\u003cspan class=\"hljs-string\"\u003e\"__\"\u003c/span\u003e):\n                    data = mat_data[key]\n                    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eisinstance\u003c/span\u003e(data, np.ndarray) \u003cspan class=\"hljs-keyword\"\u003eand\u003c/span\u003e data.ndim \u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:  \n                        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"\u003cspan class=\"hljs-subst\"\u003e{key}\u003c/span\u003e:\"\u003c/span\u003e)\n                        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(data[:\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e])  \n                    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n                        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"\u003cspan class=\"hljs-subst\"\u003e{key}\u003c/span\u003e: \u003cspan class=\"hljs-subst\"\u003e{data}\u003c/span\u003e\"\u003c/span\u003e)\n            \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e# 폴더 경로\u003c/span\u003e\ntrain_folder = os.path.expanduser(\u003cspan class=\"hljs-string\"\u003e\"~/Documents/GitHub/Embedded-AI/data/LGHG2@n10C_to_25degC/Train\"\u003c/span\u003e)\ntest_folder = os.path.expanduser(\u003cspan class=\"hljs-string\"\u003e\"~/Documents/GitHub/Embedded-AI/data/LGHG2@n10C_to_25degC/Test\"\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e# Train 및 Test 파일의 내용 읽고 출력\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"훈련 데이터 파일:\"\u003c/span\u003e)\nread_and_print_mat_files(train_folder)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\n테스트 데이터 파일:\"\u003c/span\u003e)\nread_and_print_mat_files(test_folder)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e훈련 데이터의 처음 다섯 행의 내용은 아래와 같이 표시됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003eTRAIN_LGHG2@n10degC_to_25degC_Norm_5Inputs.mat 내용:\nX:\n[[\u003cspan class=\"hljs-number\"\u003e0.38514793\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.38515183\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.38515573\u003c/span\u003e ... \u003cspan class=\"hljs-number\"\u003e0.47884278\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.4789612\u003c/span\u003e  \u003cspan class=\"hljs-number\"\u003e0.4789612\u003c/span\u003e ]\n [\u003cspan class=\"hljs-number\"\u003e0.75102009\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.75102009\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.75102009\u003c/span\u003e ... \u003cspan class=\"hljs-number\"\u003e0.75102009\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.75102009\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.75102009\u003c/span\u003e]\n [\u003cspan class=\"hljs-number\"\u003e0.30310108\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.30459129\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.3060815\u003c/span\u003e  ... \u003cspan class=\"hljs-number\"\u003e0.00847709\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.00847709\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.00847709\u003c/span\u003e]\n [\u003cspan class=\"hljs-number\"\u003e0.38514793\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.38514988\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.38515183\u003c/span\u003e ... \u003cspan class=\"hljs-number\"\u003e0.45983939\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.45997861\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.46011672\u003c/span\u003e]\n [\u003cspan class=\"hljs-number\"\u003e0.75102009\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.75102009\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.75102009\u003c/span\u003e ... \u003cspan class=\"hljs-number\"\u003e0.75102009\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.75102009\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.75102009\u003c/span\u003e]]\nY:\n[[\u003cspan class=\"hljs-number\"\u003e0.20641667\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.20641667\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.20641667\u003c/span\u003e ... \u003cspan class=\"hljs-number\"\u003e0.28324333\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.28324333\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.28324333\u003c/span\u003e]]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eX는 각 행이 다음 다섯 개의 예측변수 중 하나에 해당하는 2D 배열입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e전압\u003c/li\u003e\n\u003cli\u003e전류\u003c/li\u003e\n\u003cli\u003e온도\u003c/li\u003e\n\u003cli\u003e평균 전압\u003c/li\u003e\n\u003cli\u003e평균 전류\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e각 열은 Series에서 다른 시간점을 나타내며, 측정은 1초마다 이루어졌습니다. 예를 들어, 첫 번째 행은 전압: [0.38514793, 0.38515183, 0.38515573, …, 0.47884278, 0.4789612, 0.4789612]이고, 두 번째 행은 전류: [0.75102009, 0.75102009, 0.75102009, …, 0.75102009, 0.75102009, 0.75102009]이며, 나머지 예측변수에 대한 내용도 같은 방식입니다.\u003c/p\u003e\n\u003cp\u003eY도 하나의 행으로 이루어진 2D 배열이지만, SOC가 단일 대상 변수임을 나타냅니다. 각 열은 해당 시간점에서의 SOC를 나타냅니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 파일 내용을 이해했으므로 훈련 및 테스트를 위해 데이터 저장소를 로드할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eread_mat_files\u003c/span\u003e(folder):\n    data = []\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e filename \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e os.\u003cspan class=\"hljs-title function_\"\u003elistdir\u003c/span\u003e(folder):\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e filename.\u003cspan class=\"hljs-title function_\"\u003eendswith\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\".mat\"\u003c/span\u003e):\n            filepath = os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(folder, filename)\n            mat_data = scipy.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eloadmat\u003c/span\u003e(filepath)\n            data.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(mat_data)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e data\n\n# 훈련 데이터와 테스트 데이터를 위한 파일 데이터 저장소 생성\nfds_train = \u003cspan class=\"hljs-title function_\"\u003eread_mat_files\u003c/span\u003e(train_folder)\nfds_test = \u003cspan class=\"hljs-title function_\"\u003eread_mat_files\u003c/span\u003e(test_folder)\n\n# 데이터 저장소에 있는 모든 데이터 읽기\ntrain_data_full = fds_train[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\ntest_data_full_n10deg = fds_test[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\ntest_data_full_0deg = fds_test[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\ntest_data_full_10deg = fds_test[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]\ntest_data_full_25deg = fds_test[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]\n\n# 데이터 배열의 모양 출력하여 구조를 이해하기\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"train_data_full['X']의 모양: \"\u003c/span\u003e, train_data_full[\u003cspan class=\"hljs-string\"\u003e'X'\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"train_data_full['Y']의 모양: \"\u003c/span\u003e, train_data_full[\u003cspan class=\"hljs-string\"\u003e'Y'\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"test_data_full_n10deg['X']의 모양: \"\u003c/span\u003e, test_data_full_n10deg[\u003cspan class=\"hljs-string\"\u003e'X'\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"test_data_full_n10deg['Y']의 모양: \"\u003c/span\u003e, test_data_full_n10deg[\u003cspan class=\"hljs-string\"\u003e'Y'\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eshape 속성은 배열의 차원을 나타내는 튜플을 반환합니다. 2D 배열의 경우 shape는 (행, 열)로 이루어진 튜플을 반환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etrain_data_full[\u003cspan class=\"hljs-string\"\u003e'X'\u003c/span\u003e]의 모양:  (\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e669956\u003c/span\u003e)\ntrain_data_full[\u003cspan class=\"hljs-string\"\u003e'Y'\u003c/span\u003e]의 모양:  (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e669956\u003c/span\u003e)\ntest_data_full_n10deg[\u003cspan class=\"hljs-string\"\u003e'X'\u003c/span\u003e]의 모양:  (\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e47517\u003c/span\u003e)\ntest_data_full_n10deg[\u003cspan class=\"hljs-string\"\u003e'Y'\u003c/span\u003e]의 모양:  (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e47517\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e훈련 데이터 파일 내에서, 주변 온도 측정 값은 다음과 같이 분할되어 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eidx0   = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e184257\u003c/span\u003e        # 온도 = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e°C\nidx10  = \u003cspan class=\"hljs-number\"\u003e184258\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e337973\u003c/span\u003e   # 온도 = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e°C\nidx25  = \u003cspan class=\"hljs-number\"\u003e337974\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e510530\u003c/span\u003e   # 온도 = \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e°C\nidxN10 = \u003cspan class=\"hljs-number\"\u003e510531\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e669956\u003c/span\u003e   # 온도 = -\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e°C\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리가 출력한 훈련 데이터의 첫 5개 행을 살펴보면, X의 3번째 행이 온도를 나타냅니다. 이 값이 0이 될 것으로 예상할 수 있지만, 이 값들은 측정되고 정규화된 값입니다. 모든 예측 변수는 모델 수렴 및 성능을 향상시키기 위해 정규화되었습니다.\u003c/p\u003e\n\u003cp\u003e훈련 온도 데이터 세트를 분리하려면, 아래 코드를 로딩 스크립트에 추가하십시오.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# train_data_full에서 X와 Y 추출하기\nX = train_data_full[\u003cspan class=\"hljs-string\"\u003e'X'\u003c/span\u003e]\nY = train_data_full[\u003cspan class=\"hljs-string\"\u003e'Y'\u003c/span\u003e]\n\n# 인덱스 범위 정의\nidx0 = \u003cspan class=\"hljs-title function_\"\u003eslice\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e184257\u003c/span\u003e)\nidx10 = \u003cspan class=\"hljs-title function_\"\u003eslice\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e184257\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e337973\u003c/span\u003e)\nidx25 = \u003cspan class=\"hljs-title function_\"\u003eslice\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e337973\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e510530\u003c/span\u003e)\nidxN10 = \u003cspan class=\"hljs-title function_\"\u003eslice\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e510530\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e669956\u003c/span\u003e)\n\n# 데이터 세그먼트 추출\nX_idx0 = X[:, idx0]\nY_idx0 = Y[:, idx0]\n\nX_idx10 = X[:, idx10]\nY_idx10 = Y[:, idx10]\n\nX_idx25 = X[:, idx25]\nY_idx25 = Y[:, idx25]\n\nX_idxN10 = X[:, idxN10]\nY_idxN10 = Y[:, idxN10]\n\n# 추출 확인을 위해 형태 출력\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'X_idx0 형태: {X_idx0.shape}, Y_idx0 형태: {Y_idx0.shape}'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'X_idx10 형태: {X_idx10.shape}, Y_idx10 형태: {Y_idx10.shape}'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'X_idx25 형태: {X_idx25.shape}, Y_idx25 형태: {Y_idx25.shape}'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'X_idxN10 형태: {X_idxN10.shape}, Y_idxN10 형태: {Y_idxN10.shape}'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e트레이닝 데이터에는 총 669,956개의 열이 있어서 처리하기에는 조금 많습니다. 간단하게 만들기 위해 데이터를 다시 샘플링하여 매 100번째 점을 가져와 평균 전압 및 평균 전류 예측 변수의 새로운 이동 평균값을 계산할 것입니다. 재계산된 이동 평균은 각 포인트에 대해 최근 5개 샘플을 사용합니다. 이는 i-5부터 i까지의 값들의 평균을 계산하기 위해 루프를 사용하여 수행됩니다. 이동 평균을 계산하는 데 최근 5개 샘플을 사용하는 것은 시계열 분석에서 일반적인 기술입니다. 이 접근 방식은 데이터를 부드럽게 만들면서 최근 변화에 반응성을 유지하는 균형을 제공합니다.\u003c/p\u003e\n\u003cp\u003e데이터 전처리를 돕기 위해 파이썬 함수를 작성했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eresample_and_compute_moving_averages\u003c/span\u003e(X, Y, step=\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e):\r\n    # 데이터 재샘플링 (매 \u003cspan class=\"hljs-string\"\u003e`step`\u003c/span\u003e번째 포인트 가져오기)\r\n    X_resampled = X[:, ::step]\r\n    Y_resampled = Y[:, ::step]\r\n    \r\n    # 새로운 이동 평균 계산\r\n    n = X_resampled.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\r\n    avg_voltage_idx = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e  # \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e번째 열이 평균 전압이라고 가정\r\n    avg_current_idx = \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e  # \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e번째 열이 평균 전류이라고 가정\r\n    \r\n    new_avg_voltage = np.\u003cspan class=\"hljs-title function_\"\u003eempty\u003c/span\u003e(n)\r\n    new_avg_current = np.\u003cspan class=\"hljs-title function_\"\u003eempty\u003c/span\u003e(n)\r\n    \r\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(n):\r\n        new_avg_voltage[i] = np.\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e(X_resampled[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, i-\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e):i+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e])\r\n        new_avg_current[i] = np.\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e(X_resampled[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, i-\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e):i+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e])\r\n    \r\n    X_resampled[avg_voltage_idx, :n] = new_avg_voltage\r\n    X_resampled[avg_current_idx, :n] = new_avg_current\r\n    \r\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e X_resampled, Y_resampled\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e학습 및 테스트 데이터 재샘플링은 이제 간단합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 학습 데이터를 재샘플링하고 새로운 이동 평균 계산\nX_train_resampled, Y_train_resampled = \u003cspan class=\"hljs-title function_\"\u003eresample_and_compute_moving_averages\u003c/span\u003e(X_train, Y_train)\n\n# 테스트 데이터 추출 및 재샘플링\nX_test_n10deg = test_data_full_n10deg[\u003cspan class=\"hljs-string\"\u003e'X'\u003c/span\u003e]\nY_test_n10deg = test_data_full_n10deg[\u003cspan class=\"hljs-string\"\u003e'Y'\u003c/span\u003e]\nX_test_n10deg_resampled, Y_test_n10deg_resampled = \u003cspan class=\"hljs-title function_\"\u003eresample_and_compute_moving_averages\u003c/span\u003e(X_test_n10deg, Y_test_n10deg)\n\nX_test_0deg = test_data_full_0deg[\u003cspan class=\"hljs-string\"\u003e'X'\u003c/span\u003e]\nY_test_0deg = test_data_full_0deg[\u003cspan class=\"hljs-string\"\u003e'Y'\u003c/span\u003e]\nX_test_0deg_resampled, Y_test_0deg_resampled = \u003cspan class=\"hljs-title function_\"\u003eresample_and_compute_moving_averages\u003c/span\u003e(X_test_0deg, Y_test_0deg)\n\nX_test_10deg = test_data_full_10deg[\u003cspan class=\"hljs-string\"\u003e'X'\u003c/span\u003e]\nY_test_10deg = test_data_full_10deg[\u003cspan class=\"hljs-string\"\u003e'Y'\u003c/span\u003e]\nX_test_10deg_resampled, Y_test_10deg_resampled = \u003cspan class=\"hljs-title function_\"\u003eresample_and_compute_moving_averages\u003c/span\u003e(X_test_10deg, Y_test_10deg)\n\nX_test_25deg = test_data_full_25deg[\u003cspan class=\"hljs-string\"\u003e'X'\u003c/span\u003e]\nY_test_25deg = test_data_full_25deg[\u003cspan class=\"hljs-string\"\u003e'Y'\u003c/span\u003e]\nX_test_25deg_resampled, Y_test_25deg_resampled = \u003cspan class=\"hljs-title function_\"\u003eresample_and_compute_moving_averages\u003c/span\u003e(X_test_25deg, Y_test_25deg)\n\n# 재샘플링 확인을 위해 형태 출력\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'재샘플링 후 학습 데이터 형태: X={X_train_resampled.shape}, Y={Y_train_resampled.shape}'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'n10degC 테스트 데이터 형태: X={X_test_n10deg_resampled.shape}, Y={Y_test_n10deg_resampled.shape}'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'0degC 테스트 데이터 형태: X={X_test_0deg_resampled.shape}, Y={Y_test_0deg_resampled.shape}'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'10degC 테스트 데이터 형태: X={X_test_10deg_resampled.shape}, Y={Y_test_10deg_resampled.shape}'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'25degC 테스트 데이터 형태: X={X_test_25deg_resampled.shape}, Y={Y_test_25deg_resampled.shape}'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e데이터 처리 스케치의 전체 버전은 Reefwing Gist에서 제공됩니다. 데이터셋 크기를 재샘플링한 후에는 아래와 같은 크기가 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e재샘플링 후 학습 데이터 형태: X=(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6700\u003c/span\u003e), Y=(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6700\u003c/span\u003e)\nn10degC 테스트 데이터 형태: X=(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e476\u003c/span\u003e), Y=(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e476\u003c/span\u003e)\n0degC 테스트 데이터 형태: X=(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e443\u003c/span\u003e), Y=(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e443\u003c/span\u003e)\n10degC 테스트 데이터 형태: X=(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e426\u003c/span\u003e), Y=(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e426\u003c/span\u003e)\n25degC 테스트 데이터 형태: X=(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e393\u003c/span\u003e), Y=(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e393\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e저희는 모든 전처리된 학습 및 테스트 데이터를 Preprocessed라는 새 하위 디렉토리에 저장할 거에요. 이 파일들은 CSV 형식으로 저장되며, 쉽게 읽고 쓸 수 있어서 사용자가 쉽게 확인할 수 있어요. 더 큰 데이터셋의 경우 HDF5 (계층적 데이터 형식)를 사용하면 효율적으로 대량의 데이터를 저장할 수 있고 복잡한 데이터 구조를 지원해요. 이는 과학 계산에서도 널리 사용되고 있어요. 관련 추가 코드는 아래에 나와 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epreprocessed_folder = os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(output_folder, \u003cspan class=\"hljs-string\"\u003e'Preprocessed'\u003c/span\u003e)\nos.\u003cspan class=\"hljs-title function_\"\u003emakedirs\u003c/span\u003e(preprocessed_folder, exist_ok=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\n...\n\n# 학습 데이터를 리샘플링하고 새로운 이동 평균을 계산합니다.\nX_train_resampled, Y_train_resampled = \u003cspan class=\"hljs-title function_\"\u003eresample_and_compute_moving_averages\u003c/span\u003e(X_train, Y_train)\n\n# \u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e을 생성하고 \u003cspan class=\"hljs-variable constant_\"\u003eCSV\u003c/span\u003e로 저장합니다.\ntrain_df = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003evstack\u003c/span\u003e((X_train_resampled, Y_train_resampled)).\u003cspan class=\"hljs-property\"\u003eT\u003c/span\u003e,\n                        columns=[\u003cspan class=\"hljs-string\"\u003e'Voltage'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Current'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Temperature'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Average Voltage'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Average Current'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'SOC'\u003c/span\u003e])\ntrain_df.\u003cspan class=\"hljs-title function_\"\u003eto_csv\u003c/span\u003e(os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(preprocessed_folder, \u003cspan class=\"hljs-string\"\u003e'resampled_training_data.csv'\u003c/span\u003e), index=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\n\n# 테스트 데이터를 추출하고 리샘플링합니다.\ntest_data_files = [\u003cspan class=\"hljs-string\"\u003e'n10degC'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'0degC'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'10degC'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'25degC'\u003c/span\u003e]\nresampled_test_data_shapes = {}\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i, test_data_full \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eenumerate\u003c/span\u003e(fds_test):\n    X_test = test_data_full[\u003cspan class=\"hljs-string\"\u003e'X'\u003c/span\u003e]\n    Y_test = test_data_full[\u003cspan class=\"hljs-string\"\u003e'Y'\u003c/span\u003e]\n    X_test_resampled, Y_test_resampled = \u003cspan class=\"hljs-title function_\"\u003eresample_and_compute_moving_averages\u003c/span\u003e(X_test, Y_test)\n    test_df = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003evstack\u003c/span\u003e((X_test_resampled, Y_test_resampled)).\u003cspan class=\"hljs-property\"\u003eT\u003c/span\u003e,\n                           columns=[\u003cspan class=\"hljs-string\"\u003e'Voltage'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Current'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Temperature'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Average Voltage'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Average Current'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'SOC'\u003c/span\u003e])\n    test_df.\u003cspan class=\"hljs-title function_\"\u003eto_csv\u003c/span\u003e(os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(preprocessed_folder, f\u003cspan class=\"hljs-string\"\u003e'resampled_test_data_{test_data_files[i]}.csv'\u003c/span\u003e), index=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\n    resampled_test_data_shapes[test_data_files[i]] = (X_test_resampled.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e, Y_test_resampled.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e단계 3 — 모델 선택\u003c/h2\u003e\n\u003cp\u003e배터리 충전 상태 (SOC) 및 건강 상태 (SOH)를 추정하기 위해 여러 머신러닝 알고리즘이 광범위하게 연구되어 왔습니다. 네 가지 가장 탁월한 유형은 얕은 신경망 (NN), 딥러닝 (DL), 서포트 벡터 머신 (SVM), 그리고 가우시안 프로세스 회귀 (GPR)입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e얕은 신경망(SNN)\n얕은 신경망(Figure 4)은 한 개 또는 두 개의 은닉층으로 구성됩니다. 딥 러닝과 비교하면 비교적 단순하지만 전력 특성의 비선형성을 모델링하기에 충분히 강력합니다. 단층 신경망은 더 간단한 구조로, 계산 능력과 메모리가 덜 필요하여 자원 제한적인 임베디드 장치에서 실시간 SOC 및 SOH 추정에 적합합니다. 이러한 모델은 전압, 전류, 온도와 같은 다양한 입력 특성으로부터 SOC 및 SOH를 예측하는 데 학습될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e딥 러닝(DL)\n딥 러닝 모델인 딥 신경망(DNNs — Figure 5) 및 합성곱 신경망(CNNs)과 같이 여러 층을 가지고 있어 데이터의 복잡한 패턴과 상호작용을 포착할 수 있습니다. DL 모델은 입력 특성과 SOC 또는 SOH 사이의 복잡한 관계를 학습하여 매우 정확한 추정을 제공할 수 있습니다. 그러나 그들의 복잡성은 더 많은 계산 자원과 메모리를 필요로 하며, 이는 일부 임베디드 시스템에 제약 요인이 될 수 있습니다. 그러나 임베디드 하드웨어의 발전으로 실시간 응용 프로그램에서 딥 러닝 모델을 배포하긴 점점 더 가능해지고 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_6.png\" alt=\"SVM\"\u003e\u003c/p\u003e\n\u003cp\u003e서포트 벡터 머신(SVM)\n서포트 벡터 머신(도표 6)은 분류와 회귀 작업 모두에 사용할 수 있는 지도 학습 모델입니다. SOC 및 SOH 추정을 위해 SVM은 고차원 데이터를 효과적으로 처리할 수 있으며, 특히 훈련 데이터가 제한적인 상황에서 과적합에 강합니다. SVM은 데이터를 서로 다른 클래스로 분리하거나 연속 값을 예측하는 데 최적의 초평면을 찾아 작동합니다. 상대적으로 낮은 계산 요구로 인해 리소스가 제한된 임베디드 응용 프로그램에 적합합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_7.png\" alt=\"GPR\"\u003e\u003c/p\u003e\n\u003cp\u003e가우시안 프로세스 회귀(GPR)\n가우시안 프로세스 회귀(도표 7)는 예측 뿐만 아니라 불확실성 추정을 제공하는 비모수적인 확률적 접근 방식입니다. SOC 및 SOH 추정에 특히 유용한 GPR은 운영 조건 및 노화로 인한 배터리 행동의 기저 불확실성을 모델링할 수 있습니다. GPR 모델은 유연하며 새로운 데이터로 업데이트할 수 있어, 배터리 수명 주기 내의 변화에 적응할 수 있습니다. 이러한 이유로 GPR 모델을 채택하여 구현하기로 결정했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e하지만 GPR은 계산이 많이 필요하며, 실시간 임베디드 애플리케이션에 적합하게 만들기 위해 효율적인 구현이 필요합니다. 또는 장치 외부에서 처리를 수행하고 최적화된 후에 훈련된 모델을 배포할 수도 있습니다. 이것이 우리가 취할 접근 방식입니다.\u003c/p\u003e\n\u003ch2\u003e파트 4\u003c/h2\u003e\n\u003cp\u003e시리즈의 제 4부에서 배터리 SOC 예측기의 ML 프로세스를 계속할 것입니다. 이는 모델을 훈련하고 evaluate하는 데 중점을 둘 것입니다.\u003c/p\u003e\n\u003ch2\u003e참고문헌\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e[1] Kollmeyer, Philip; Vidal, Carlos; Naguib, Mina; Skells, Michael (2020), “LG 18650HG2 Li-ion Battery Data and Example Deep Neural Network xEV SOC Estimator Script”, Mendeley Data, V3, doi: 10.17632/cp3473x7xv.3\u003c/p\u003e\n\u003cp\u003e만약 이 글을 즐겁게 보셨고 제 글쓰기를 지원하고 싶으시다면, 팔로우를 누르거나 (최대 50번), 강조하기, 혹은 댓글을 남겨주세요! 혹은 다른 방법으로 커피를 사주시거나 구독해주셔도 됩니다. 새 글이 올라올 때마다 이메일을 받아보실 수 있습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning"},"buildId":"eK_Db2btow8fB-QoZ_pMH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>