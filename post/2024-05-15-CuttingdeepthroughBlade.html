<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>칼날로 깊게 베어 가는 것 | design-news</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://design-news.github.io///post/2024-05-15-CuttingdeepthroughBlade" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="칼날로 깊게 베어 가는 것 | design-news" data-gatsby-head="true"/><meta property="og:title" content="칼날로 깊게 베어 가는 것 | design-news" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-15-CuttingdeepthroughBlade_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://design-news.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://design-news.github.io///post/2024-05-15-CuttingdeepthroughBlade" data-gatsby-head="true"/><meta name="twitter:title" content="칼날로 깊게 베어 가는 것 | design-news" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-15-CuttingdeepthroughBlade_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | design-news" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-15 12:34" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-159f9c3f558c220e.js" defer=""></script><script src="/_next/static/bcl7D5eEo4s3Ou6aXCZKZ/_buildManifest.js" defer=""></script><script src="/_next/static/bcl7D5eEo4s3Ou6aXCZKZ/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Design News</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">칼날로 깊게 베어 가는 것</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="칼날로 깊게 베어 가는 것" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Design News</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 15, 2024</span><span class="posts_reading_time__f7YPP">14<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-15-CuttingdeepthroughBlade&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>디자인 시스템 채택 사례 연구</h2>
<p>2022년 3월에 Razorpay 엔지니어링의 플랫폼 프론트엔드 인프라 팀에서 엔지니어링 매니저로 면접을 보았을 때, 지금은 동료인 Kamlesh Chandnani 및 Chaitanya Deorukhkar가 나에게 한 간단한 질문이 있었습니다.</p>
<p>그 질문에 흥미롭다고 생각했습니다. 나는 개인 기여자로서 골드만삭스에서 UI 도구 키트와 디자인 시스템의 기초를 구축한 경험을 갖고 있었습니다. 내 대답은 간단했습니다 - 좋은 제품을 만들어 빠르게 출시하고 지원을 제공하면 소비자들이 자동으로 디자인 시스템을 사용하기 시작할 것이라고. 그로부터 2년이 지난 지금, 이 면접관들이 납득할 만한 이유를 이해하게 되었습니다. 이 단일 문제는 내 전문 경험 중 가장 어려우면서 신비로운 퍼즐 중 하나로 나타났습니다. 그 이후 우리는 많은 발전을 이루었고 리더십 조정, 측정 가능한 채택 지표, 조직 전반적인 목표 설정 및 소비자 만족을 통해 디자인 시스템 채택의 수수께끼를 풀어나가는 우리의 경험을 기반으로 몇 가지 원칙을 제시하겠습니다.</p>
<h1>Blade 소개</h1>
<p>Razorpay은 인도에서 가장 큰 성장을 이루고 있는 금융 서비스 회사 중 하나로, 1000만 대의 비즈니스를 지원하며 다양한 플랫폼을 통해 다양한 제품을 제공하고 있습니다.</p>
<p>금융 산업은 사용자 인식과 신뢰가 가장 중요한 도메인이 될 수 있습니다. 브랜드와 연관 짓는 경우 사용자는 결제 버튼을 클릭할 가능성이 더 높습니다. 저희는 Razorpay의 디자인 시스템인 Blade를 구축하여 디자인 일관성, 개발자 생산성, 크로스 플랫폼 호환성, 데스크탑, mweb 및 React Native 간의 코드 재사용성, 반응성 및 접근성과 같은 핵심 기반에 대한 다수의 문제를 해결하기 위해 노력했습니다. Blade가 어떤 기본 원칙에 기반하여 구축되었는지에 대해 많은 이야기가 있지만, 이 글의 초점은 단순히 Blade의 채택에만 두고 있습니다. 그러나 Blade가 처음부터 어떻게 구축되었는지 자세히 알고 싶다면 몇 가지 참고 자료를 첨부할 것입니다.</p>
<ul>
<li>플랫폼 팀과의 프런트엔드 기반</li>
<li>유연성 대 제약 사항을 균형 있게 유지하면서 재사용 가능한 UI 구성 요소 구축</li>
<li>디자인 시스템 구성</li>
<li>디자인 시스템 컴포넌트 디자인</li>
</ul>
<p>Blade의 기술적 측면과 구현 방법을 더 자세히 알고 싶다면 아래의 참고 자료를 추천드립니다.</p>
<ul>
<li>블레이드의 스토리북 문서</li>
<li>블레이드의 기반 RFC</li>
</ul>
<h2>채택</h2>
<p>모두가 원칙적으로 디자인 시스템의 혜택과 필요성에 동의한다 하더라도, 디자인 시스템 채택이 왜 어려운지에 대한 근본적인 질문이 제기됩니다. 아마도 몇 가지 가능한 이유를 설명해보겠습니다.</p>
<ul>
<li>제품 및 기능 팀은 종종 비즈니스 지표 목표를 추구하며 인프라에 대한 부담이나 제약 없이 동일한 목표를 달성하려 합니다.</li>
<li>개발자는 작업 흐름에 대해 자신의 방식을 가지고 있으며 변화에 저항합니다.</li>
<li>디자이너는 디자인 시스템이 창의성을 제한한다고 느낍니다.</li>
<li>리더십은 디자인 시스템을 프로젝트에 통합하는 것이 제품의 일정에 영향을 미칠 수 있다고 생각합니다.</li>
<li>사람들은 게으릅니다. 개발자와 디자이너 모두가 학습 곡선을 가지고 있으며 새로운 도구나 시스템을 이해하는 데 마찬가지로 마찰을 피하려 합니다.</li>
<li>플랫폼 팀은 디자인 시스템을 잘 홍보하는 데 추가적인 노력을 기울이지 않습니다.</li>
</ul>
<p>위의 모든 이유들은 소비자의 관점에서 이해할 만하지만, 덧없고 기술 부채를 축적하게 됩니다. 장기적으로, 디자인 시스템의 채택은 컴포넌트 표준화로 인한 제품 개발 가속화를 통해 개발자 생산성을 해결하고, 디자인과 개발 간의 일관성을 높이며 브랜드 일관성을 추구하는 데 중요합니다. 초기 언급한 장애물을 넘어선다면 조직에는 훨씬 큰 혜택이 있습니다.</p>
<p>디자인 시스템 채용을 마스터하는 일반적인 규칙은 없습니다. 종류, 규모 및 조직의 성숙도에 따라 각자의 여정이 있습니다. Blade의 채용 여정을 자세히 설명하겠습니다. 일부는 표준으로 받아들여지는 것이지만, 다른 일부는 여러 해 동안 세밀한 조정이 필요했습니다.</p>
<h2>문서화</h2>
<p>나는 종종 문서화가 개발자의 빵의 버터라고 말합니다. 훌륭한 엔지니어링 솔루션의 기반으로 사용되는 중심축입니다. 디자인 시스템 팀은 보통 작습니다. 시스템 빌드 중에 여러 팀과 제품을 개별적으로 지원하는 것은 신체적으로 힘들고 작은 그룹에서는 현실적으로 불가능합니다. 그래서 좋은 디자인 시스템 문서는 사용자들이 기초, 컴포넌트 및 패턴에 대해 자주 묻는 일반적인 질문들을 처리하여 소비자 지원을 유지하고 많은 문제에 대응합니다. Blade에서는 문서를 다음과 같이 구성했습니다.</p>
<p>스토리북</p>
<p>블레이드의 개발자 문서는 스토리북을 기반으로 만들어졌습니다. 스토리북은 UI 컴포넌트 예제를 분리하여 문서화하는 훌륭한 도구로, 데이터와 비즈니스 로직을 추출해내는 방법을 제공합니다. Blade의 문서에는 설치 방법에 대한 개발자 친화적 가이드, 로컬 개발을 위한 안내, 컴포넌트 상태, 기본 토큰, 유틸리티 및 컴포넌트에 대한 내용이 포함되어 있습니다. 팀은 컴포넌트 문서에 특별히 신경을 씁니다. 컴포넌트 설명, Figma를 통한 컴포넌트 유형 및 사용법의 삽입, 컴포넌트를 조작해볼 수 있는 실시간 코드 편집기, API 결정 (아래 참조), 속성 이름, 설명 및 기본값이 포함된 API 테이블, 그리고 컴포넌트의 다양한 변형에 대한 실제 예제 등이 기술되어 있습니다.</p>
<p><img src="/assets/img/2024-05-15-CuttingdeepthroughBlade_0.png" alt="이미지"></p>
<p>블레이드의 디자인 문서는 Figma에 호스팅되어있으며, 컴포넌트의 구조, 밝은/어두운 모드에서의 시각화, 사용된 다양한 속성과 기본 토큰, 의도 및 변형, 컴포넌트의 유사 상태(호버, 포커스, 활성, 비활성) 등이 포함된 매우 상세한 내용을 제공합니다. 또한, Do's 와 Don'ts, 콘텐츠 지침, 모션과 접근성에 대한 지침도 포함되어 있습니다.</p>
<p>컴포넌트 API 결정</p>
<p>블레이드가 기반으로 하는 기본 원칙 중 하나는 "디자인에서 본 대로 코드로 얻을 수 있다"는 것입니다. 이 내러티브를 더 잘 설명하기 위해서는, 우리의 이상적인 미래 상태는 디자이너와 개발자 간의 마찰을 제로로 줄이는 것이라고 강조하고 싶습니다. Figma의 모든 컴포넌트 속성은 React props로의 쉬운 변환을 위해 1:1 매핑이 되어 있으며, 이 철학에는 예외가 없습니다.</p>
<p>그러므로, 우리는 컴포넌트 API, 기본값, 컴포넌트 네이밍 규칙 등을 어떻게 만드는지에 특별한 주의를 기울입니다. 팀은 이들 결정을 문서화하고 이유를 제시하며, 모든 다른 제품의 팀장들과 함께 이를 검토하는 것을 원칙으로 합니다. 이는 결정에 대한 집단 책임을 보장하고, 팀이 제품에 대한 가장자리 사례를 놓치지 않았는지를 확인하는 데 도움이 됩니다. 모든 사람으로부터 승인을 받으면 팀은 구현을 시작합니다.</p>
<p>여러 API 결정이 논의되었고 이들의 장단점이 나열된 카드 API 결정의 예를 들어 보겠습니다. 컴포넌트/_decisions 폴더에서 다른 API 결정들을 찾아볼 수 있습니다.</p>
<h1>공지사항</h1>
<p>이전에 언급했듯이, DS 채택에 있어서 한 가지 장애물은 플랫폼 팀이 시스템을 충분히 마케팅하지 않는 것입니다. 제품 팀은 종종 기능, 릴리스, 버그, 인시던트 등에 집중되어 있어서 인프라 향상의 가능성에 즉각적으로 주의를 기울이지 않을 수 있습니다. 따라서 DS 팀은 주목받는 위치에 있도록 새로운 업그레이드, 구성 요소 추가, DS 버그 해결 등에 대해 지나치게 발표해야 합니다. 이곳에서 Blade Progress Bar 출시의 예를 들어 보세요.
Chaitanya Deorukhkar
가 필요한 구성 요소의 기능을 강조하며, 동영상은 소비자들이 해당 구성 요소를 시도하고 싶어하는 호기심을 자극합니다.</p>
<p><img src="/assets/img/2024-05-15-CuttingdeepthroughBlade_1.png" alt="Blade Progress Bar"></p>
<p>온보딩의 편리함</p>
<p>회사가 성장하고 DS 소비자 베이스가 커짐에 따라, 새로 입사한 직원의 온보딩에 지식 전이 워크플로우를 통합하는 것이 매우 중요합니다. 이를 통해 정보 체인이 DS 팀에 부담을 주지 않고 소비자로부터 다른 소비자로 흐를 수 있습니다. Razorpay에서 우리는 각 디자이너가 프로젝트를 시작하기 전에 회사에 입사하기 전에 필수적으로 사용하는 내부 도구 위에 워크플로우를 만들었습니다.</p>
<h2>내부 사용 메트릭</h2>
<p>Razorpay는 OKR 방법론을 따르는 조직으로, 각 목표나 결정은 성공 기준을 정의하기 위해 숫자 메트릭으로 뒷받침되어야 합니다. Blade에서 결정한 모든 결정에 대해 동일한 형식을 확장하고, 결론은 데이터를 통해 도출되어야 했습니다.</p>
<p>이 아이디어를 향해 첫 번째 단계는 팀이 사용 정보 계측을 통해 소비자가 컴포넌트를 어떻게 사용하는지 이해하는 것이었습니다. 우리는 react-scanner를 활용하여 컴포넌트의 총 발생 횟수, 프로젝트별 사용, 흔히 사용되는 속성 대적게 사용되는 속성 등의 카테고리화된 사용 사례를 파악하는 데 도움이 되는 실용적인 유틸리티를 활용했습니다. 이를 통해 팀은 컴포넌트 사용 패턴을 이해하고 사용되지 않는 속성/토큰을 제거하고, 더 많이 사용되는 컴포넌트 그룹(input, feedback 등)에 투자하는 등의 결정을 내릴 수 있었습니다.</p>
<p><img src="/assets/img/2024-05-15-CuttingdeepthroughBlade_2.png" alt="이미지1"></p>
<p><img src="/assets/img/2024-05-15-CuttingdeepthroughBlade_3.png" alt="이미지2"></p>
<h2>페이지 % 커버리지</h2>
<p>우리 공동 창업자인 Shashank Kumar와의 회의 중에는 디자인 시스템에 대한 그의 비전에 대해 아이디어를 내고 있었습니다. 그의 질문은 간단하고 타당했어요 - "나는 현재 조직이 Blade를 어떻게 사용하는지 모릅니다. 디자인 시스템을 사용하는 프로젝트가 4-5개라고 말한다면, 그게 좋은 숫자인지 아닌지 모릅니다. 그들이 실제로 Blade를 얼마나 사용하고 있습니까?"</p>
<p>우리는 컴포넌트의 내부 계측을 해결했지만, 블레이드를 사용하는 소비자들이 정확히 어떻게 사용하는지는 알 수 없었습니다. 제품 A가 버튼 컴포넌트를 100번 사용했다고 말할 수는 있지만(대부분의 디자인 시스템에서 가능한 일), 모든 버튼이 Blade에서 왔는지 아니면 빠진 것이 있는지 확신할 수는 없었습니다. 우리는 디자인 시스템 채택 OKR을 위한 프레임워크를 수립하고 그에 지표를 부여하고 목표를 설정하고자 했습니다.</p>
<p>그러나 곧 채택률을 측정하는 명확한 표준이 없다는 사실을 깨달았습니다. 개발 생산성 목표를 세우면서, 컴포넌트 사용 횟수에 기반하여 개발자들이 작성하는 JS 및 CSS 코드 양이 얼마나 줄어들었는지 알아보려고 했지만, 이는 막다른 골목이라는 것을 깨달았습니다. 컴포넌트가 없을 경우 개발자들이 어떤 코드를 작성했을지를 사업 로직과 분리하여 추적하는 것은 현실적이지 않았습니다.</p>
<p>다수의 해결책에 대해 아이디어를 모아보는 도중 팀은 결국 "유레카" 순간을 맞이했습니다 - 만약 HTML 노드를 기본 분자로 삼아 Blade에서 나온 노드의 개수를 전체 페이지 노드 수와 비교하여 측정할 수 있는 메커니즘을 개발할 수 있다면 어떨까요? 그렇게 하면 Blade 컴포넌트의 노드를 사용하여 페이지의 몇 %가 구성되었는지를 측정하는 프레임워크를 가질 수 있을 것입니다!</p>
<p>아누라그 하즈라는 이 간단한 아이디어를 숨겨진 및 비어 있는 노드를 무시하고, 디자인 시스템 범위에 없는 노드(예: img, svg, 미디어 요소 등)를 무시함으로써 작은 스크립트로 변환했습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/**
 * DOM 노드가 숨겨져 있는지 여부를 확인합니다.
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">isElementHidden</span> = (<span class="hljs-params">element</span>) => {
  <span class="hljs-keyword">if</span> (element.<span class="hljs-property">parentElement</span> &#x26;&#x26; <span class="hljs-title function_">isElementHidden</span>(element.<span class="hljs-property">parentElement</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">if</span> (!(element <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">HTMLElement</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">if</span> (element.<span class="hljs-property">hidden</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">const</span> style = <span class="hljs-title function_">getComputedStyle</span>(element);
  <span class="hljs-keyword">return</span> style.<span class="hljs-property">display</span> === <span class="hljs-string">"none"</span> || style.<span class="hljs-property">visibility</span> === <span class="hljs-string">"hidden"</span> || style.<span class="hljs-property">opacity</span> === <span class="hljs-string">"0"</span>;
};

<span class="hljs-comment">/**
 * DOM 엘리먼트가 비어 있는지 여부를 확인합니다.
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">isElementEmpty</span> = (<span class="hljs-params">element</span>) => {
  <span class="hljs-keyword">if</span> (!element) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">if</span> (!element.<span class="hljs-property">childNodes</span>.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};

<span class="hljs-comment">/**
 * DOM 노드가 미디어 엘리먼트인지 여부를 확인합니다.
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">isMediaElement</span> = (<span class="hljs-params">element</span>) => {
  <span class="hljs-keyword">const</span> mediaTags = [<span class="hljs-string">"img"</span>, <span class="hljs-string">"video"</span>, <span class="hljs-string">"audio"</span>, <span class="hljs-string">"source"</span>, <span class="hljs-string">"picture"</span>];
  <span class="hljs-keyword">return</span> mediaTags.<span class="hljs-title function_">includes</span>(element.<span class="hljs-property">tagName</span>.<span class="hljs-title function_">toLowerCase</span>());
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">calculateBladeCoverage</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> allDomElements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">"body *"</span>);
  <span class="hljs-keyword">const</span> bladeNodeElements = [];
  <span class="hljs-keyword">const</span> totalNodeElements = [];
  allDomElements.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">elm</span>) =></span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isElementHidden</span>(elm)) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isElementEmpty</span>(elm)) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isMediaElement</span>(elm)) <span class="hljs-keyword">return</span>;

    totalNodeElements.<span class="hljs-title function_">push</span>(elm);
    <span class="hljs-keyword">if</span> (elm.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-string">"data-blade-component"</span>)) {
      bladeNodeElements.<span class="hljs-title function_">push</span>(elm);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (elm.<span class="hljs-title function_">closest</span>(<span class="hljs-string">"[data-blade-component]"</span>)) {
      bladeNodeElements.<span class="hljs-title function_">push</span>(elm);
    }
  });

  <span class="hljs-keyword">const</span> totalNodes = totalNodeElements.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> bladeNodes = bladeNodeElements.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> bladeCoverage = <span class="hljs-title class_">Number</span>(((bladeNodes / totalNodes) * <span class="hljs-number">100</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>));
  <span class="hljs-keyword">return</span> {
    bladeCoverage,
    totalNodes,
    bladeNodes,
    bladeNodeElements,
  };
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">calculateBladeCoverage</span>());
</code></pre>
<p>팁: 위 스니펫을 개발자 콘솔에서 실행하여 razorpay.com의 Blade % 커버리지를 확인할 수 있습니다.</p>
<p>한때 우리는 프레임워크를 갖추고 이론을 검증했습니다! Blade를 사용하여 제작된 많은 현재 페이지 중 일부는 미미한 커버리지를 갖고 있었습니다. 우리는 이 스크립트를 모든 앱에 통합하여 주기적으로 이 데이터를 기기 이벤트로 전달하고 지속적인 모니터링을 위한 대시보드를 구축했습니다. 이제 우리는 쫓아갈 지표를 갖게 되었습니다!</p>
<p>페이지 % 커버리지 메트릭은 곧 조직에서 표준이 되어 새로운 모듈 및 앱이 평가되었습니다. 개발자가 스크립트를 사용하기 쉽고 이를 통해 이 페이지의 어떤 섹션이 Blade에서 왔는지 여부를 스테이크 홀더(리더, 제품 매니저, 디자이너 등)가 쉽게 파악할 수 있도록 하기 위해
Sumit Gupta
&#x26;
Anurag Hazra
Chrome 확장 프로그램과 통합하여 페이지의 % 커버리지를 제공하고 Blade가 아닌 노드를 강조했습니다.</p>
<p>공학 분야에서 % 페이지 커버리지 메트릭의 성공을 고려하여, 디자인 분야로 확장하기로 결정했습니다. 개발이 시작되기 전에 충분한 Blade 커버리지가 디자인 인계와 함께 이루어지도록 하는 것이 의미가 있다는 점에서 체크포인트를 설정하는 것이 합리적이었습니다.</p>
<p>Kamlesh Chandnani는 Figma Blade 커버리지 플러그인을 만들었으며, 디자인 레이어를 평가하고 각 디자인 프레임 위에 작은 카드를 부착하여 디자인 인계 전에 커버리지를 계산합니다.</p>
<p>Chaitanya Deorukhkar는 내부 사용 메트릭과 % 페이지 커버리지에 대한 상기 구현 사항을 설명하는 Measuring A Design System’s Success라는 강의에서 자세히 설명합니다.</p>
<p>또한, 유나이티드 항공 홈페이지에 대한 디자인 시스템 커버리지에 관한 Dan Mall의 기사도 참조하십시오. 이는 이 구현에 영감을 준 것입니다.</p>
<h2>중앙 기관 목표</h2>
<p>블레이드 커버리지를 측정하기 위한 프레임워크를 수립하는 것은 디자인 시스템 채택을 위한 기반을 마련하는 일이었습니다. 페이지를 블레이드 노드와 블레이드 노드가 아닌 것으로 이분화하고 앱에서 블레이드 % 페이지의 평균을 집계하여 앱별 기준을 단일 메트릭으로 정의하고 있습니다. 기준이 마련되면 디자인 시스템 채택, 미래 상태, 위험 및 디자인 및 엔지니어링을 위한 가능한 조직 전체 목표에 대한 전략을 개발하고 작성할 수 있었습니다.</p>
<p>채택 목표를 개발하고 전략을 세울 때 주의해야 할 두 가지가 있었습니다. 새로운 앱은 모두 블레이드를 이용하여 구축되어야 하며 기존 앱의 이전 모듈도 일관성을 유지하기 위해 블레이드로 이ꁼ되어야 했습니다. 이는 Razorpay를 위한 조직 목표로 이어졌습니다.</p>
<p>모든 앱을 대상으로 한 전체 목표는 모든 페이지 또는 모듈의 평균을 20%로 설정하는 것이었습니다. 이는 70%의 새로운 페이지를 커버하여 달성해야 하는 당연한 일이었습니다. 그러나 더 까다로운 부분은 이전 페이지를 이전하는 것으로, 특정 페이지 수에 초점을 맞추기보다는 고객의 시각에서 시각적 일관성을 유지하기 위해 많은 트래픽을 가진 페이지에 초점을 맞추기로 결정했습니다.</p>
<p>디자인 시스템 전략을 작성할 때 디자인 전략, 기여 및 이ꁼ 가이드 등과 같이 세부 정보를 자세히 작성하여 팀, 애플리케이션 소유주 또는 새로운 이해 관계자 간의 불일치를 해소하는 것이 중요합니다. 첨부된 예시를 확인하세요.</p>
<p><img src="/assets/img/2024-05-15-CuttingdeepthroughBlade_4.png" alt="Cutting deep through Blade"></p>
<h2>지원</h2>
<p>디자인 시스템 채택에 있어 성숙성, 완성도 또는 철저한 문서 작성 여부와 관계없이, 소비자들이 블로커(blockers) 상황에서 가능하게 하거나 지원하는 잘 정의된 지원 프로세스가 중요합니다. Blade의 경우, 우리는 소비자들을 다음과 같은 방법으로 지원했습니다.</p>
<ul>
<li>엔지니어 및 디자이너들이 의심 사항이나 새로운 사용 사례를 논의하는 오픈 오피스 시간 (주당 두 번)</li>
<li>잘 정의된 레이블이 있는 Github Issues</li>
<li>JIRA의 즉시 지원 요청</li>
<li>빠른 쿼리를 위한 전용 Slack 채널</li>
</ul>
<p><img src="/assets/img/2024-05-15-CuttingdeepthroughBlade_5.png" alt="Cutting deep through Blade"></p>
<p>저희 지원 구조는 디자인 시스템의 기반 및 구성 요소를 탐색하는 데 소비자들을 다양한 방법으로 지원하는 데 그치지 않고, 플랫폼 팀이 신규 패턴, 일반적 용법 또는 기존 구성 요소의 향상에 대해 더 많이 학습할 수 있도록 함으로써 Blade의 지속적인 개선에 이바지하고 있습니다.</p>
<h2>전도사들</h2>
<p>이전에 우리는 디자인 시스템 팀이 작고 조직의 모든 신규 제품 요구 사항에 대해 모든 해결책을 제시하거나 개념을 도출할 수 있는 단일 연락 대상이 될 수 없다고 결정했습니다. 따라서 조직 내에서 각 비즈니스 부서를 대표하는 기둥 또는 전도사가 존재하는 것이 중요하며, 이들이 디자인 시스템에 관한 문제나 쿼리를 해결하거나 새로운 구성 요소나 구성 요소의 변형에 대해 아이디어를 제기하는 데 사용되는 자리로 활약할 수 있도록 하는 것이 중요합니다. 우리는 이들을 "Blade 대변인"이라고 부릅니다.</p>
<p>Blade 대변인은 Razorpay의 각 비즈니스 부서에서 온 제품 디자이너들의 그룹으로, 해당 제품의 각 Blade 구성 요소에 대한 감사, 사용 사례 및 입력을 제공하고 최종 결과물을 검토합니다. 모든 Blade 구성 요소의 디자인 단계 동안 우리는 대변인들에게 각자의 제품에서 사용 사례를 제공하도록 요청하고 디자인이 완료된 후에는 그룹과 함께 구성 요소를 검토합니다. 이는 구성 요소가 조직의 요구 사항을 충족시키는지 확인하는 데 도움이 되는 것 뿐만 아니라 디자이너가 승인하면 최종 구성 요소가 최종적으로 채택될 것임을 확인하는 데 도움이 됩니다. 이 연습의 부작용 중 하나는 대변인 그룹이 지속적으로 새로운 구성 요소와 디자인 시스템의 토큰에 대해 교육받으면서 플랫폼과 제품 사이의 간극을 줄이게 되며 그들은 차후 동료들 사이에 지식을 전파할 수 있습니다.</p>
<h2>FGD 및 설문 조사</h2>
<p>소비자에 직접적으로 노출되지 않는 제품의 경우 성공 지표를 정의하기 어렵습니다. 대부분의 경우 팀은 소비자들이 그들의 제품에 대한 인식을 이해하기 위해 설문조사 및 집중 토론 그룹(FGD)을 활용하여 NPS(순 수익률 지수)를 생성합니다. 우리는 생산성, 개발자-디자이너 간 마찰, UI 반복 감소, Figma와 코드 간의 일치, 문서 작성, 효율적인 의사 소통 등과 관련된 다양한 범주에 대한 질문을 포함하여 개발자와 디자이너 모두를 대상으로 설문 조사를 적극적으로 실시했습니다. 또한, 팀은 비즈니스 부문이나 툴 유형(React/ReactNative/Svelte)별로 구분된 다양한 집단과 FGD를 진행하는데, 이 때 질문은 자주 설문조사 결과에서 나오는 주제에 대해 더 심층적으로 들어갑니다. 블레이드의 유연성 대 제약, 디자인에서 개발로 컴포넌트/토큰 매핑, 신규 개발자의 진입 장벽, 다른 UI 라이브러리와의 비교, 기존 컴포넌트 대 사용자 지정 컴포넌트 등의 주제를 다룹니다.</p>
<p>표면적으로 이런 방대한 설문조사나 FGD를 실시하는 것은 지루할 수 있지만, 이로 인해 상당한 성과를 거두게 됩니다.</p>
<ul>
<li>설문 조사는 디자인 시스템을 사용하는 디자이너와 개발자들이 느끼는 전반적 인식에 대한 NPS를 제공합니다. 이는 플랫폼 팀이 매년 추구할 수 있는 점수를 제공하고 개선을 시도할 수 있게 합니다.</li>
<li>설문 조사 결과는 리더십에게 디자인 시스템에 대한 투자를 정당화하는 효과적인 시각을 제시합니다.</li>
<li>개선 및 도입 과제에 대해 소비자와 대화하는 것은 어떻게 지속할지에 대한 좋은 통찰을 제공할 수 있으며, 결과적으로 더 나은 채택 OKRs로 이어질 수 있습니다.</li>
<li>소비자가 자유롭게 의견을 피력할 수 있는 플랫폼을 제공함으로써, 플랫폼 팀이 관심을 가지고 디자인 시스템의 개발에 대한 협력적인 태도를 강화할 수 있습니다.</li>
</ul>
<h2>브랜딩</h2>
<p>어떤 제품에 개성을 부여하는 것은 중요합니다. 그래서 여러분이 '파이트 클럽'에서 브래드 피트를 에드워드 노튼보다 더 기억하는 이유죠 (스포일러 주의!). 이와 같은 이유로 우리는 Blade와 관련된 견고한 브랜드를 구축하면 조직 및 세계와의 연관이 쉬워질 것이라고 결정했습니다. 우리는 로고를 만들고, 로고 내에서 돋보이는 글꼴, 명확한 색상 팔레트 등 여러 요소를 고려했습니다. 이 결과는 강렬하며, 브랜드에 대한 시각적인 이해를 제공하여 소통을 용이하게 했습니다 (생각보다 많은 Slack 이모티콘 반응들).</p>
<p><img src="/assets/img/2024-05-15-CuttingdeepthroughBlade_6.png" alt="image"></p>
<h2>상품</h2>
<p>브랜드가 확립되자마자, 우리는 소비자와 초기 채택자들을 보상하고 기업 전반에서 블레이드의 전도를 돕는 목표를 가지고 주변 상품을 만들기로 하였습니다.</p>
<p><img src="/assets/img/2024-05-15-CuttingdeepthroughBlade_7.png" alt="이미지"></p>
<h2>보상 및 인정</h2>
<p>성공적인 디자인 시스템 채택 과정은 종종 기업 전반의 노력이 필요하며 플랫폼 팀에만 할애되어서는 안 됩니다. 따라서 목표를 믿고 이를 실현하기 위해 노력하는 개인들을 인정하는 것이 중요합니다. 이는 전체 조직에 이들을 축하시키고 다른 이들에게 미래를 위한 유사한 노력을 기울이도록 영감을 주면서 간접적으로 시스템의 영향력을 강조합니다. 우리는 많은 이러한 개인들을 축하하며 팀의 성취를 강조하고 노력 중에 긍정적인 문화적 영향을 창출하였습니다.</p>
<h1>결론</h1>
<p>Blade는 Razorpay의 약 13개 제품에 속해 있다. Blade는 설립 이후 많은 발전을 거쳐 현재는 통합되고 성숙한 제품이 되었습니다. 회사의 규모와 운영이 커지면서 다른 사업을 인수할 때, 정교한 디자인 언어를 사용하면 모든 제품을 하나의 우산 아래로 모을 수 있습니다. 또한 견고한 기반 덕분에 Blade는 기업이 요구할 때 용이하게 시각적 화장 도구를 통해 시각적 활기를 불어넣었으며 이는 우리의 Figma 라이브러리 오픈 소스화로 이어졌습니다.</p>
<p>몇 년 동안 Blade는 업계에서 많은 호평을 받았지만 Figma가 디자인 시스템 채택과 디자인 개발 협업의 증진에 대해 협력한 Boosting design system adoption에 대해 우리와 협업했을 때 이에 최고조를 달렸습니다. 또한 그들은 위에서 논의한 주제들을 How Razorpay sharpened developer workflows라는 기사에서 게재했습니다. 이제까지 오신 분들에게 추천드리는 글입니다.</p>
<p>디자인 시스템의 도입은 도전적이었지만 결과는 모범적이었습니다. 이러한 성과의 대부분은 팀에게 돌아가지만, 여기서의 한계는 없으며 팀이 미래에 어떤 것을 만들어내는지 기다릴 수 없습니다.</p>
<p>디자인 -
Saurav Rastogi, Rama Krushna Behera, Abhishek Bhardwaj, Gopi Bhatnagar, Aditi Arora, Pingal Kakati, Saurabh Soni</p>
<p>엔지니어링 -
Kamlesh Chandnani, Chaitanya Deorukhkar, Anurag Hazra, Saurabh Daware, Nitin Kumar, Divyanshu Maithani, Dhruvdutt Jadhav, Abinash Shaw, Varun Achar</p>
<h2>블레이드 참조</h2>
<p>Figma 라이브러리
GitHub 코드베이스
문서화</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"칼날로 깊게 베어 가는 것","description":"","date":"2024-05-15 12:34","slug":"2024-05-15-CuttingdeepthroughBlade","content":"\n## 디자인 시스템 채택 사례 연구\n\n2022년 3월에 Razorpay 엔지니어링의 플랫폼 프론트엔드 인프라 팀에서 엔지니어링 매니저로 면접을 보았을 때, 지금은 동료인 Kamlesh Chandnani 및 Chaitanya Deorukhkar가 나에게 한 간단한 질문이 있었습니다.\n\n그 질문에 흥미롭다고 생각했습니다. 나는 개인 기여자로서 골드만삭스에서 UI 도구 키트와 디자인 시스템의 기초를 구축한 경험을 갖고 있었습니다. 내 대답은 간단했습니다 - 좋은 제품을 만들어 빠르게 출시하고 지원을 제공하면 소비자들이 자동으로 디자인 시스템을 사용하기 시작할 것이라고. 그로부터 2년이 지난 지금, 이 면접관들이 납득할 만한 이유를 이해하게 되었습니다. 이 단일 문제는 내 전문 경험 중 가장 어려우면서 신비로운 퍼즐 중 하나로 나타났습니다. 그 이후 우리는 많은 발전을 이루었고 리더십 조정, 측정 가능한 채택 지표, 조직 전반적인 목표 설정 및 소비자 만족을 통해 디자인 시스템 채택의 수수께끼를 풀어나가는 우리의 경험을 기반으로 몇 가지 원칙을 제시하겠습니다.\n\n# Blade 소개\n\nRazorpay은 인도에서 가장 큰 성장을 이루고 있는 금융 서비스 회사 중 하나로, 1000만 대의 비즈니스를 지원하며 다양한 플랫폼을 통해 다양한 제품을 제공하고 있습니다.\n\n금융 산업은 사용자 인식과 신뢰가 가장 중요한 도메인이 될 수 있습니다. 브랜드와 연관 짓는 경우 사용자는 결제 버튼을 클릭할 가능성이 더 높습니다. 저희는 Razorpay의 디자인 시스템인 Blade를 구축하여 디자인 일관성, 개발자 생산성, 크로스 플랫폼 호환성, 데스크탑, mweb 및 React Native 간의 코드 재사용성, 반응성 및 접근성과 같은 핵심 기반에 대한 다수의 문제를 해결하기 위해 노력했습니다. Blade가 어떤 기본 원칙에 기반하여 구축되었는지에 대해 많은 이야기가 있지만, 이 글의 초점은 단순히 Blade의 채택에만 두고 있습니다. 그러나 Blade가 처음부터 어떻게 구축되었는지 자세히 알고 싶다면 몇 가지 참고 자료를 첨부할 것입니다.\n\n- 플랫폼 팀과의 프런트엔드 기반\n- 유연성 대 제약 사항을 균형 있게 유지하면서 재사용 가능한 UI 구성 요소 구축\n- 디자인 시스템 구성\n- 디자인 시스템 컴포넌트 디자인\n\nBlade의 기술적 측면과 구현 방법을 더 자세히 알고 싶다면 아래의 참고 자료를 추천드립니다.\n\n- 블레이드의 스토리북 문서\n- 블레이드의 기반 RFC\n\n## 채택\n\n모두가 원칙적으로 디자인 시스템의 혜택과 필요성에 동의한다 하더라도, 디자인 시스템 채택이 왜 어려운지에 대한 근본적인 질문이 제기됩니다. 아마도 몇 가지 가능한 이유를 설명해보겠습니다.\n\n- 제품 및 기능 팀은 종종 비즈니스 지표 목표를 추구하며 인프라에 대한 부담이나 제약 없이 동일한 목표를 달성하려 합니다.\n- 개발자는 작업 흐름에 대해 자신의 방식을 가지고 있으며 변화에 저항합니다.\n- 디자이너는 디자인 시스템이 창의성을 제한한다고 느낍니다.\n- 리더십은 디자인 시스템을 프로젝트에 통합하는 것이 제품의 일정에 영향을 미칠 수 있다고 생각합니다.\n- 사람들은 게으릅니다. 개발자와 디자이너 모두가 학습 곡선을 가지고 있으며 새로운 도구나 시스템을 이해하는 데 마찬가지로 마찰을 피하려 합니다.\n- 플랫폼 팀은 디자인 시스템을 잘 홍보하는 데 추가적인 노력을 기울이지 않습니다.\n\n위의 모든 이유들은 소비자의 관점에서 이해할 만하지만, 덧없고 기술 부채를 축적하게 됩니다. 장기적으로, 디자인 시스템의 채택은 컴포넌트 표준화로 인한 제품 개발 가속화를 통해 개발자 생산성을 해결하고, 디자인과 개발 간의 일관성을 높이며 브랜드 일관성을 추구하는 데 중요합니다. 초기 언급한 장애물을 넘어선다면 조직에는 훨씬 큰 혜택이 있습니다.\n\n디자인 시스템 채용을 마스터하는 일반적인 규칙은 없습니다. 종류, 규모 및 조직의 성숙도에 따라 각자의 여정이 있습니다. Blade의 채용 여정을 자세히 설명하겠습니다. 일부는 표준으로 받아들여지는 것이지만, 다른 일부는 여러 해 동안 세밀한 조정이 필요했습니다.\n\n## 문서화\n\n나는 종종 문서화가 개발자의 빵의 버터라고 말합니다. 훌륭한 엔지니어링 솔루션의 기반으로 사용되는 중심축입니다. 디자인 시스템 팀은 보통 작습니다. 시스템 빌드 중에 여러 팀과 제품을 개별적으로 지원하는 것은 신체적으로 힘들고 작은 그룹에서는 현실적으로 불가능합니다. 그래서 좋은 디자인 시스템 문서는 사용자들이 기초, 컴포넌트 및 패턴에 대해 자주 묻는 일반적인 질문들을 처리하여 소비자 지원을 유지하고 많은 문제에 대응합니다. Blade에서는 문서를 다음과 같이 구성했습니다.\n\n스토리북\n\n블레이드의 개발자 문서는 스토리북을 기반으로 만들어졌습니다. 스토리북은 UI 컴포넌트 예제를 분리하여 문서화하는 훌륭한 도구로, 데이터와 비즈니스 로직을 추출해내는 방법을 제공합니다. Blade의 문서에는 설치 방법에 대한 개발자 친화적 가이드, 로컬 개발을 위한 안내, 컴포넌트 상태, 기본 토큰, 유틸리티 및 컴포넌트에 대한 내용이 포함되어 있습니다. 팀은 컴포넌트 문서에 특별히 신경을 씁니다. 컴포넌트 설명, Figma를 통한 컴포넌트 유형 및 사용법의 삽입, 컴포넌트를 조작해볼 수 있는 실시간 코드 편집기, API 결정 (아래 참조), 속성 이름, 설명 및 기본값이 포함된 API 테이블, 그리고 컴포넌트의 다양한 변형에 대한 실제 예제 등이 기술되어 있습니다.\n\n![이미지](/assets/img/2024-05-15-CuttingdeepthroughBlade_0.png)\n\n블레이드의 디자인 문서는 Figma에 호스팅되어있으며, 컴포넌트의 구조, 밝은/어두운 모드에서의 시각화, 사용된 다양한 속성과 기본 토큰, 의도 및 변형, 컴포넌트의 유사 상태(호버, 포커스, 활성, 비활성) 등이 포함된 매우 상세한 내용을 제공합니다. 또한, Do's 와 Don'ts, 콘텐츠 지침, 모션과 접근성에 대한 지침도 포함되어 있습니다.\n\n컴포넌트 API 결정\n\n블레이드가 기반으로 하는 기본 원칙 중 하나는 \"디자인에서 본 대로 코드로 얻을 수 있다\"는 것입니다. 이 내러티브를 더 잘 설명하기 위해서는, 우리의 이상적인 미래 상태는 디자이너와 개발자 간의 마찰을 제로로 줄이는 것이라고 강조하고 싶습니다. Figma의 모든 컴포넌트 속성은 React props로의 쉬운 변환을 위해 1:1 매핑이 되어 있으며, 이 철학에는 예외가 없습니다.\n\n그러므로, 우리는 컴포넌트 API, 기본값, 컴포넌트 네이밍 규칙 등을 어떻게 만드는지에 특별한 주의를 기울입니다. 팀은 이들 결정을 문서화하고 이유를 제시하며, 모든 다른 제품의 팀장들과 함께 이를 검토하는 것을 원칙으로 합니다. 이는 결정에 대한 집단 책임을 보장하고, 팀이 제품에 대한 가장자리 사례를 놓치지 않았는지를 확인하는 데 도움이 됩니다. 모든 사람으로부터 승인을 받으면 팀은 구현을 시작합니다.\n\n여러 API 결정이 논의되었고 이들의 장단점이 나열된 카드 API 결정의 예를 들어 보겠습니다. 컴포넌트/\\_decisions 폴더에서 다른 API 결정들을 찾아볼 수 있습니다.\n\n# 공지사항\n\n이전에 언급했듯이, DS 채택에 있어서 한 가지 장애물은 플랫폼 팀이 시스템을 충분히 마케팅하지 않는 것입니다. 제품 팀은 종종 기능, 릴리스, 버그, 인시던트 등에 집중되어 있어서 인프라 향상의 가능성에 즉각적으로 주의를 기울이지 않을 수 있습니다. 따라서 DS 팀은 주목받는 위치에 있도록 새로운 업그레이드, 구성 요소 추가, DS 버그 해결 등에 대해 지나치게 발표해야 합니다. 이곳에서 Blade Progress Bar 출시의 예를 들어 보세요.\nChaitanya Deorukhkar\n가 필요한 구성 요소의 기능을 강조하며, 동영상은 소비자들이 해당 구성 요소를 시도하고 싶어하는 호기심을 자극합니다.\n\n![Blade Progress Bar](/assets/img/2024-05-15-CuttingdeepthroughBlade_1.png)\n\n온보딩의 편리함\n\n회사가 성장하고 DS 소비자 베이스가 커짐에 따라, 새로 입사한 직원의 온보딩에 지식 전이 워크플로우를 통합하는 것이 매우 중요합니다. 이를 통해 정보 체인이 DS 팀에 부담을 주지 않고 소비자로부터 다른 소비자로 흐를 수 있습니다. Razorpay에서 우리는 각 디자이너가 프로젝트를 시작하기 전에 회사에 입사하기 전에 필수적으로 사용하는 내부 도구 위에 워크플로우를 만들었습니다.\n\n## 내부 사용 메트릭\n\nRazorpay는 OKR 방법론을 따르는 조직으로, 각 목표나 결정은 성공 기준을 정의하기 위해 숫자 메트릭으로 뒷받침되어야 합니다. Blade에서 결정한 모든 결정에 대해 동일한 형식을 확장하고, 결론은 데이터를 통해 도출되어야 했습니다.\n\n이 아이디어를 향해 첫 번째 단계는 팀이 사용 정보 계측을 통해 소비자가 컴포넌트를 어떻게 사용하는지 이해하는 것이었습니다. 우리는 react-scanner를 활용하여 컴포넌트의 총 발생 횟수, 프로젝트별 사용, 흔히 사용되는 속성 대적게 사용되는 속성 등의 카테고리화된 사용 사례를 파악하는 데 도움이 되는 실용적인 유틸리티를 활용했습니다. 이를 통해 팀은 컴포넌트 사용 패턴을 이해하고 사용되지 않는 속성/토큰을 제거하고, 더 많이 사용되는 컴포넌트 그룹(input, feedback 등)에 투자하는 등의 결정을 내릴 수 있었습니다.\n\n![이미지1](/assets/img/2024-05-15-CuttingdeepthroughBlade_2.png)\n\n![이미지2](/assets/img/2024-05-15-CuttingdeepthroughBlade_3.png)\n\n## 페이지 % 커버리지\n\n우리 공동 창업자인 Shashank Kumar와의 회의 중에는 디자인 시스템에 대한 그의 비전에 대해 아이디어를 내고 있었습니다. 그의 질문은 간단하고 타당했어요 - \"나는 현재 조직이 Blade를 어떻게 사용하는지 모릅니다. 디자인 시스템을 사용하는 프로젝트가 4-5개라고 말한다면, 그게 좋은 숫자인지 아닌지 모릅니다. 그들이 실제로 Blade를 얼마나 사용하고 있습니까?\"\n\n우리는 컴포넌트의 내부 계측을 해결했지만, 블레이드를 사용하는 소비자들이 정확히 어떻게 사용하는지는 알 수 없었습니다. 제품 A가 버튼 컴포넌트를 100번 사용했다고 말할 수는 있지만(대부분의 디자인 시스템에서 가능한 일), 모든 버튼이 Blade에서 왔는지 아니면 빠진 것이 있는지 확신할 수는 없었습니다. 우리는 디자인 시스템 채택 OKR을 위한 프레임워크를 수립하고 그에 지표를 부여하고 목표를 설정하고자 했습니다.\n\n그러나 곧 채택률을 측정하는 명확한 표준이 없다는 사실을 깨달았습니다. 개발 생산성 목표를 세우면서, 컴포넌트 사용 횟수에 기반하여 개발자들이 작성하는 JS 및 CSS 코드 양이 얼마나 줄어들었는지 알아보려고 했지만, 이는 막다른 골목이라는 것을 깨달았습니다. 컴포넌트가 없을 경우 개발자들이 어떤 코드를 작성했을지를 사업 로직과 분리하여 추적하는 것은 현실적이지 않았습니다.\n\n다수의 해결책에 대해 아이디어를 모아보는 도중 팀은 결국 \"유레카\" 순간을 맞이했습니다 - 만약 HTML 노드를 기본 분자로 삼아 Blade에서 나온 노드의 개수를 전체 페이지 노드 수와 비교하여 측정할 수 있는 메커니즘을 개발할 수 있다면 어떨까요? 그렇게 하면 Blade 컴포넌트의 노드를 사용하여 페이지의 몇 %가 구성되었는지를 측정하는 프레임워크를 가질 수 있을 것입니다!\n\n아누라그 하즈라는 이 간단한 아이디어를 숨겨진 및 비어 있는 노드를 무시하고, 디자인 시스템 범위에 없는 노드(예: img, svg, 미디어 요소 등)를 무시함으로써 작은 스크립트로 변환했습니다.\n\n```js\n/**\n * DOM 노드가 숨겨져 있는지 여부를 확인합니다.\n */\nconst isElementHidden = (element) =\u003e {\n  if (element.parentElement \u0026\u0026 isElementHidden(element.parentElement)) {\n    return true;\n  }\n  if (!(element instanceof HTMLElement)) {\n    return false;\n  }\n  if (element.hidden) {\n    return true;\n  }\n  const style = getComputedStyle(element);\n  return style.display === \"none\" || style.visibility === \"hidden\" || style.opacity === \"0\";\n};\n\n/**\n * DOM 엘리먼트가 비어 있는지 여부를 확인합니다.\n */\nconst isElementEmpty = (element) =\u003e {\n  if (!element) return true;\n  if (!element.childNodes.length) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * DOM 노드가 미디어 엘리먼트인지 여부를 확인합니다.\n */\nconst isMediaElement = (element) =\u003e {\n  const mediaTags = [\"img\", \"video\", \"audio\", \"source\", \"picture\"];\n  return mediaTags.includes(element.tagName.toLowerCase());\n};\n\nconst calculateBladeCoverage = () =\u003e {\n  const allDomElements = document.querySelectorAll(\"body *\");\n  const bladeNodeElements = [];\n  const totalNodeElements = [];\n  allDomElements.forEach((elm) =\u003e {\n    if (isElementHidden(elm)) return;\n    if (isElementEmpty(elm)) return;\n    if (isMediaElement(elm)) return;\n\n    totalNodeElements.push(elm);\n    if (elm.hasAttribute(\"data-blade-component\")) {\n      bladeNodeElements.push(elm);\n    } else if (elm.closest(\"[data-blade-component]\")) {\n      bladeNodeElements.push(elm);\n    }\n  });\n\n  const totalNodes = totalNodeElements.length;\n  const bladeNodes = bladeNodeElements.length;\n  const bladeCoverage = Number(((bladeNodes / totalNodes) * 100).toFixed(2));\n  return {\n    bladeCoverage,\n    totalNodes,\n    bladeNodes,\n    bladeNodeElements,\n  };\n};\n\nconsole.log(calculateBladeCoverage());\n```\n\n팁: 위 스니펫을 개발자 콘솔에서 실행하여 razorpay.com의 Blade % 커버리지를 확인할 수 있습니다.\n\n한때 우리는 프레임워크를 갖추고 이론을 검증했습니다! Blade를 사용하여 제작된 많은 현재 페이지 중 일부는 미미한 커버리지를 갖고 있었습니다. 우리는 이 스크립트를 모든 앱에 통합하여 주기적으로 이 데이터를 기기 이벤트로 전달하고 지속적인 모니터링을 위한 대시보드를 구축했습니다. 이제 우리는 쫓아갈 지표를 갖게 되었습니다!\n\n페이지 % 커버리지 메트릭은 곧 조직에서 표준이 되어 새로운 모듈 및 앱이 평가되었습니다. 개발자가 스크립트를 사용하기 쉽고 이를 통해 이 페이지의 어떤 섹션이 Blade에서 왔는지 여부를 스테이크 홀더(리더, 제품 매니저, 디자이너 등)가 쉽게 파악할 수 있도록 하기 위해\nSumit Gupta\n\u0026\nAnurag Hazra\nChrome 확장 프로그램과 통합하여 페이지의 % 커버리지를 제공하고 Blade가 아닌 노드를 강조했습니다.\n\n공학 분야에서 % 페이지 커버리지 메트릭의 성공을 고려하여, 디자인 분야로 확장하기로 결정했습니다. 개발이 시작되기 전에 충분한 Blade 커버리지가 디자인 인계와 함께 이루어지도록 하는 것이 의미가 있다는 점에서 체크포인트를 설정하는 것이 합리적이었습니다.\n\nKamlesh Chandnani는 Figma Blade 커버리지 플러그인을 만들었으며, 디자인 레이어를 평가하고 각 디자인 프레임 위에 작은 카드를 부착하여 디자인 인계 전에 커버리지를 계산합니다.\n\nChaitanya Deorukhkar는 내부 사용 메트릭과 % 페이지 커버리지에 대한 상기 구현 사항을 설명하는 Measuring A Design System’s Success라는 강의에서 자세히 설명합니다.\n\n또한, 유나이티드 항공 홈페이지에 대한 디자인 시스템 커버리지에 관한 Dan Mall의 기사도 참조하십시오. 이는 이 구현에 영감을 준 것입니다.\n\n## 중앙 기관 목표\n\n블레이드 커버리지를 측정하기 위한 프레임워크를 수립하는 것은 디자인 시스템 채택을 위한 기반을 마련하는 일이었습니다. 페이지를 블레이드 노드와 블레이드 노드가 아닌 것으로 이분화하고 앱에서 블레이드 % 페이지의 평균을 집계하여 앱별 기준을 단일 메트릭으로 정의하고 있습니다. 기준이 마련되면 디자인 시스템 채택, 미래 상태, 위험 및 디자인 및 엔지니어링을 위한 가능한 조직 전체 목표에 대한 전략을 개발하고 작성할 수 있었습니다.\n\n채택 목표를 개발하고 전략을 세울 때 주의해야 할 두 가지가 있었습니다. 새로운 앱은 모두 블레이드를 이용하여 구축되어야 하며 기존 앱의 이전 모듈도 일관성을 유지하기 위해 블레이드로 이ꁼ되어야 했습니다. 이는 Razorpay를 위한 조직 목표로 이어졌습니다.\n\n모든 앱을 대상으로 한 전체 목표는 모든 페이지 또는 모듈의 평균을 20%로 설정하는 것이었습니다. 이는 70%의 새로운 페이지를 커버하여 달성해야 하는 당연한 일이었습니다. 그러나 더 까다로운 부분은 이전 페이지를 이전하는 것으로, 특정 페이지 수에 초점을 맞추기보다는 고객의 시각에서 시각적 일관성을 유지하기 위해 많은 트래픽을 가진 페이지에 초점을 맞추기로 결정했습니다.\n\n디자인 시스템 전략을 작성할 때 디자인 전략, 기여 및 이ꁼ 가이드 등과 같이 세부 정보를 자세히 작성하여 팀, 애플리케이션 소유주 또는 새로운 이해 관계자 간의 불일치를 해소하는 것이 중요합니다. 첨부된 예시를 확인하세요.\n\n![Cutting deep through Blade](/assets/img/2024-05-15-CuttingdeepthroughBlade_4.png)\n\n## 지원\n\n디자인 시스템 채택에 있어 성숙성, 완성도 또는 철저한 문서 작성 여부와 관계없이, 소비자들이 블로커(blockers) 상황에서 가능하게 하거나 지원하는 잘 정의된 지원 프로세스가 중요합니다. Blade의 경우, 우리는 소비자들을 다음과 같은 방법으로 지원했습니다.\n\n- 엔지니어 및 디자이너들이 의심 사항이나 새로운 사용 사례를 논의하는 오픈 오피스 시간 (주당 두 번)\n- 잘 정의된 레이블이 있는 Github Issues\n- JIRA의 즉시 지원 요청\n- 빠른 쿼리를 위한 전용 Slack 채널\n\n![Cutting deep through Blade](/assets/img/2024-05-15-CuttingdeepthroughBlade_5.png)\n\n저희 지원 구조는 디자인 시스템의 기반 및 구성 요소를 탐색하는 데 소비자들을 다양한 방법으로 지원하는 데 그치지 않고, 플랫폼 팀이 신규 패턴, 일반적 용법 또는 기존 구성 요소의 향상에 대해 더 많이 학습할 수 있도록 함으로써 Blade의 지속적인 개선에 이바지하고 있습니다.\n\n## 전도사들\n\n이전에 우리는 디자인 시스템 팀이 작고 조직의 모든 신규 제품 요구 사항에 대해 모든 해결책을 제시하거나 개념을 도출할 수 있는 단일 연락 대상이 될 수 없다고 결정했습니다. 따라서 조직 내에서 각 비즈니스 부서를 대표하는 기둥 또는 전도사가 존재하는 것이 중요하며, 이들이 디자인 시스템에 관한 문제나 쿼리를 해결하거나 새로운 구성 요소나 구성 요소의 변형에 대해 아이디어를 제기하는 데 사용되는 자리로 활약할 수 있도록 하는 것이 중요합니다. 우리는 이들을 \"Blade 대변인\"이라고 부릅니다.\n\nBlade 대변인은 Razorpay의 각 비즈니스 부서에서 온 제품 디자이너들의 그룹으로, 해당 제품의 각 Blade 구성 요소에 대한 감사, 사용 사례 및 입력을 제공하고 최종 결과물을 검토합니다. 모든 Blade 구성 요소의 디자인 단계 동안 우리는 대변인들에게 각자의 제품에서 사용 사례를 제공하도록 요청하고 디자인이 완료된 후에는 그룹과 함께 구성 요소를 검토합니다. 이는 구성 요소가 조직의 요구 사항을 충족시키는지 확인하는 데 도움이 되는 것 뿐만 아니라 디자이너가 승인하면 최종 구성 요소가 최종적으로 채택될 것임을 확인하는 데 도움이 됩니다. 이 연습의 부작용 중 하나는 대변인 그룹이 지속적으로 새로운 구성 요소와 디자인 시스템의 토큰에 대해 교육받으면서 플랫폼과 제품 사이의 간극을 줄이게 되며 그들은 차후 동료들 사이에 지식을 전파할 수 있습니다.\n\n## FGD 및 설문 조사\n\n소비자에 직접적으로 노출되지 않는 제품의 경우 성공 지표를 정의하기 어렵습니다. 대부분의 경우 팀은 소비자들이 그들의 제품에 대한 인식을 이해하기 위해 설문조사 및 집중 토론 그룹(FGD)을 활용하여 NPS(순 수익률 지수)를 생성합니다. 우리는 생산성, 개발자-디자이너 간 마찰, UI 반복 감소, Figma와 코드 간의 일치, 문서 작성, 효율적인 의사 소통 등과 관련된 다양한 범주에 대한 질문을 포함하여 개발자와 디자이너 모두를 대상으로 설문 조사를 적극적으로 실시했습니다. 또한, 팀은 비즈니스 부문이나 툴 유형(React/ReactNative/Svelte)별로 구분된 다양한 집단과 FGD를 진행하는데, 이 때 질문은 자주 설문조사 결과에서 나오는 주제에 대해 더 심층적으로 들어갑니다. 블레이드의 유연성 대 제약, 디자인에서 개발로 컴포넌트/토큰 매핑, 신규 개발자의 진입 장벽, 다른 UI 라이브러리와의 비교, 기존 컴포넌트 대 사용자 지정 컴포넌트 등의 주제를 다룹니다.\n\n표면적으로 이런 방대한 설문조사나 FGD를 실시하는 것은 지루할 수 있지만, 이로 인해 상당한 성과를 거두게 됩니다.\n\n- 설문 조사는 디자인 시스템을 사용하는 디자이너와 개발자들이 느끼는 전반적 인식에 대한 NPS를 제공합니다. 이는 플랫폼 팀이 매년 추구할 수 있는 점수를 제공하고 개선을 시도할 수 있게 합니다.\n- 설문 조사 결과는 리더십에게 디자인 시스템에 대한 투자를 정당화하는 효과적인 시각을 제시합니다.\n- 개선 및 도입 과제에 대해 소비자와 대화하는 것은 어떻게 지속할지에 대한 좋은 통찰을 제공할 수 있으며, 결과적으로 더 나은 채택 OKRs로 이어질 수 있습니다.\n- 소비자가 자유롭게 의견을 피력할 수 있는 플랫폼을 제공함으로써, 플랫폼 팀이 관심을 가지고 디자인 시스템의 개발에 대한 협력적인 태도를 강화할 수 있습니다.\n\n## 브랜딩\n\n어떤 제품에 개성을 부여하는 것은 중요합니다. 그래서 여러분이 '파이트 클럽'에서 브래드 피트를 에드워드 노튼보다 더 기억하는 이유죠 (스포일러 주의!). 이와 같은 이유로 우리는 Blade와 관련된 견고한 브랜드를 구축하면 조직 및 세계와의 연관이 쉬워질 것이라고 결정했습니다. 우리는 로고를 만들고, 로고 내에서 돋보이는 글꼴, 명확한 색상 팔레트 등 여러 요소를 고려했습니다. 이 결과는 강렬하며, 브랜드에 대한 시각적인 이해를 제공하여 소통을 용이하게 했습니다 (생각보다 많은 Slack 이모티콘 반응들).\n\n![image](/assets/img/2024-05-15-CuttingdeepthroughBlade_6.png)\n\n## 상품\n\n브랜드가 확립되자마자, 우리는 소비자와 초기 채택자들을 보상하고 기업 전반에서 블레이드의 전도를 돕는 목표를 가지고 주변 상품을 만들기로 하였습니다.\n\n![이미지](/assets/img/2024-05-15-CuttingdeepthroughBlade_7.png)\n\n## 보상 및 인정\n\n성공적인 디자인 시스템 채택 과정은 종종 기업 전반의 노력이 필요하며 플랫폼 팀에만 할애되어서는 안 됩니다. 따라서 목표를 믿고 이를 실현하기 위해 노력하는 개인들을 인정하는 것이 중요합니다. 이는 전체 조직에 이들을 축하시키고 다른 이들에게 미래를 위한 유사한 노력을 기울이도록 영감을 주면서 간접적으로 시스템의 영향력을 강조합니다. 우리는 많은 이러한 개인들을 축하하며 팀의 성취를 강조하고 노력 중에 긍정적인 문화적 영향을 창출하였습니다.\n\n# 결론\n\nBlade는 Razorpay의 약 13개 제품에 속해 있다. Blade는 설립 이후 많은 발전을 거쳐 현재는 통합되고 성숙한 제품이 되었습니다. 회사의 규모와 운영이 커지면서 다른 사업을 인수할 때, 정교한 디자인 언어를 사용하면 모든 제품을 하나의 우산 아래로 모을 수 있습니다. 또한 견고한 기반 덕분에 Blade는 기업이 요구할 때 용이하게 시각적 화장 도구를 통해 시각적 활기를 불어넣었으며 이는 우리의 Figma 라이브러리 오픈 소스화로 이어졌습니다.\n\n몇 년 동안 Blade는 업계에서 많은 호평을 받았지만 Figma가 디자인 시스템 채택과 디자인 개발 협업의 증진에 대해 협력한 Boosting design system adoption에 대해 우리와 협업했을 때 이에 최고조를 달렸습니다. 또한 그들은 위에서 논의한 주제들을 How Razorpay sharpened developer workflows라는 기사에서 게재했습니다. 이제까지 오신 분들에게 추천드리는 글입니다.\n\n디자인 시스템의 도입은 도전적이었지만 결과는 모범적이었습니다. 이러한 성과의 대부분은 팀에게 돌아가지만, 여기서의 한계는 없으며 팀이 미래에 어떤 것을 만들어내는지 기다릴 수 없습니다.\n\n디자인 -\nSaurav Rastogi, Rama Krushna Behera, Abhishek Bhardwaj, Gopi Bhatnagar, Aditi Arora, Pingal Kakati, Saurabh Soni\n\n엔지니어링 -\nKamlesh Chandnani, Chaitanya Deorukhkar, Anurag Hazra, Saurabh Daware, Nitin Kumar, Divyanshu Maithani, Dhruvdutt Jadhav, Abinash Shaw, Varun Achar\n\n## 블레이드 참조\n\nFigma 라이브러리\nGitHub 코드베이스\n문서화\n","ogImage":{"url":"/assets/img/2024-05-15-CuttingdeepthroughBlade_0.png"},"coverImage":"/assets/img/2024-05-15-CuttingdeepthroughBlade_0.png","tag":["Tech"],"readingTime":14},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e디자인 시스템 채택 사례 연구\u003c/h2\u003e\n\u003cp\u003e2022년 3월에 Razorpay 엔지니어링의 플랫폼 프론트엔드 인프라 팀에서 엔지니어링 매니저로 면접을 보았을 때, 지금은 동료인 Kamlesh Chandnani 및 Chaitanya Deorukhkar가 나에게 한 간단한 질문이 있었습니다.\u003c/p\u003e\n\u003cp\u003e그 질문에 흥미롭다고 생각했습니다. 나는 개인 기여자로서 골드만삭스에서 UI 도구 키트와 디자인 시스템의 기초를 구축한 경험을 갖고 있었습니다. 내 대답은 간단했습니다 - 좋은 제품을 만들어 빠르게 출시하고 지원을 제공하면 소비자들이 자동으로 디자인 시스템을 사용하기 시작할 것이라고. 그로부터 2년이 지난 지금, 이 면접관들이 납득할 만한 이유를 이해하게 되었습니다. 이 단일 문제는 내 전문 경험 중 가장 어려우면서 신비로운 퍼즐 중 하나로 나타났습니다. 그 이후 우리는 많은 발전을 이루었고 리더십 조정, 측정 가능한 채택 지표, 조직 전반적인 목표 설정 및 소비자 만족을 통해 디자인 시스템 채택의 수수께끼를 풀어나가는 우리의 경험을 기반으로 몇 가지 원칙을 제시하겠습니다.\u003c/p\u003e\n\u003ch1\u003eBlade 소개\u003c/h1\u003e\n\u003cp\u003eRazorpay은 인도에서 가장 큰 성장을 이루고 있는 금융 서비스 회사 중 하나로, 1000만 대의 비즈니스를 지원하며 다양한 플랫폼을 통해 다양한 제품을 제공하고 있습니다.\u003c/p\u003e\n\u003cp\u003e금융 산업은 사용자 인식과 신뢰가 가장 중요한 도메인이 될 수 있습니다. 브랜드와 연관 짓는 경우 사용자는 결제 버튼을 클릭할 가능성이 더 높습니다. 저희는 Razorpay의 디자인 시스템인 Blade를 구축하여 디자인 일관성, 개발자 생산성, 크로스 플랫폼 호환성, 데스크탑, mweb 및 React Native 간의 코드 재사용성, 반응성 및 접근성과 같은 핵심 기반에 대한 다수의 문제를 해결하기 위해 노력했습니다. Blade가 어떤 기본 원칙에 기반하여 구축되었는지에 대해 많은 이야기가 있지만, 이 글의 초점은 단순히 Blade의 채택에만 두고 있습니다. 그러나 Blade가 처음부터 어떻게 구축되었는지 자세히 알고 싶다면 몇 가지 참고 자료를 첨부할 것입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e플랫폼 팀과의 프런트엔드 기반\u003c/li\u003e\n\u003cli\u003e유연성 대 제약 사항을 균형 있게 유지하면서 재사용 가능한 UI 구성 요소 구축\u003c/li\u003e\n\u003cli\u003e디자인 시스템 구성\u003c/li\u003e\n\u003cli\u003e디자인 시스템 컴포넌트 디자인\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBlade의 기술적 측면과 구현 방법을 더 자세히 알고 싶다면 아래의 참고 자료를 추천드립니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e블레이드의 스토리북 문서\u003c/li\u003e\n\u003cli\u003e블레이드의 기반 RFC\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e채택\u003c/h2\u003e\n\u003cp\u003e모두가 원칙적으로 디자인 시스템의 혜택과 필요성에 동의한다 하더라도, 디자인 시스템 채택이 왜 어려운지에 대한 근본적인 질문이 제기됩니다. 아마도 몇 가지 가능한 이유를 설명해보겠습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e제품 및 기능 팀은 종종 비즈니스 지표 목표를 추구하며 인프라에 대한 부담이나 제약 없이 동일한 목표를 달성하려 합니다.\u003c/li\u003e\n\u003cli\u003e개발자는 작업 흐름에 대해 자신의 방식을 가지고 있으며 변화에 저항합니다.\u003c/li\u003e\n\u003cli\u003e디자이너는 디자인 시스템이 창의성을 제한한다고 느낍니다.\u003c/li\u003e\n\u003cli\u003e리더십은 디자인 시스템을 프로젝트에 통합하는 것이 제품의 일정에 영향을 미칠 수 있다고 생각합니다.\u003c/li\u003e\n\u003cli\u003e사람들은 게으릅니다. 개발자와 디자이너 모두가 학습 곡선을 가지고 있으며 새로운 도구나 시스템을 이해하는 데 마찬가지로 마찰을 피하려 합니다.\u003c/li\u003e\n\u003cli\u003e플랫폼 팀은 디자인 시스템을 잘 홍보하는 데 추가적인 노력을 기울이지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위의 모든 이유들은 소비자의 관점에서 이해할 만하지만, 덧없고 기술 부채를 축적하게 됩니다. 장기적으로, 디자인 시스템의 채택은 컴포넌트 표준화로 인한 제품 개발 가속화를 통해 개발자 생산성을 해결하고, 디자인과 개발 간의 일관성을 높이며 브랜드 일관성을 추구하는 데 중요합니다. 초기 언급한 장애물을 넘어선다면 조직에는 훨씬 큰 혜택이 있습니다.\u003c/p\u003e\n\u003cp\u003e디자인 시스템 채용을 마스터하는 일반적인 규칙은 없습니다. 종류, 규모 및 조직의 성숙도에 따라 각자의 여정이 있습니다. Blade의 채용 여정을 자세히 설명하겠습니다. 일부는 표준으로 받아들여지는 것이지만, 다른 일부는 여러 해 동안 세밀한 조정이 필요했습니다.\u003c/p\u003e\n\u003ch2\u003e문서화\u003c/h2\u003e\n\u003cp\u003e나는 종종 문서화가 개발자의 빵의 버터라고 말합니다. 훌륭한 엔지니어링 솔루션의 기반으로 사용되는 중심축입니다. 디자인 시스템 팀은 보통 작습니다. 시스템 빌드 중에 여러 팀과 제품을 개별적으로 지원하는 것은 신체적으로 힘들고 작은 그룹에서는 현실적으로 불가능합니다. 그래서 좋은 디자인 시스템 문서는 사용자들이 기초, 컴포넌트 및 패턴에 대해 자주 묻는 일반적인 질문들을 처리하여 소비자 지원을 유지하고 많은 문제에 대응합니다. Blade에서는 문서를 다음과 같이 구성했습니다.\u003c/p\u003e\n\u003cp\u003e스토리북\u003c/p\u003e\n\u003cp\u003e블레이드의 개발자 문서는 스토리북을 기반으로 만들어졌습니다. 스토리북은 UI 컴포넌트 예제를 분리하여 문서화하는 훌륭한 도구로, 데이터와 비즈니스 로직을 추출해내는 방법을 제공합니다. Blade의 문서에는 설치 방법에 대한 개발자 친화적 가이드, 로컬 개발을 위한 안내, 컴포넌트 상태, 기본 토큰, 유틸리티 및 컴포넌트에 대한 내용이 포함되어 있습니다. 팀은 컴포넌트 문서에 특별히 신경을 씁니다. 컴포넌트 설명, Figma를 통한 컴포넌트 유형 및 사용법의 삽입, 컴포넌트를 조작해볼 수 있는 실시간 코드 편집기, API 결정 (아래 참조), 속성 이름, 설명 및 기본값이 포함된 API 테이블, 그리고 컴포넌트의 다양한 변형에 대한 실제 예제 등이 기술되어 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-15-CuttingdeepthroughBlade_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e블레이드의 디자인 문서는 Figma에 호스팅되어있으며, 컴포넌트의 구조, 밝은/어두운 모드에서의 시각화, 사용된 다양한 속성과 기본 토큰, 의도 및 변형, 컴포넌트의 유사 상태(호버, 포커스, 활성, 비활성) 등이 포함된 매우 상세한 내용을 제공합니다. 또한, Do's 와 Don'ts, 콘텐츠 지침, 모션과 접근성에 대한 지침도 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003e컴포넌트 API 결정\u003c/p\u003e\n\u003cp\u003e블레이드가 기반으로 하는 기본 원칙 중 하나는 \"디자인에서 본 대로 코드로 얻을 수 있다\"는 것입니다. 이 내러티브를 더 잘 설명하기 위해서는, 우리의 이상적인 미래 상태는 디자이너와 개발자 간의 마찰을 제로로 줄이는 것이라고 강조하고 싶습니다. Figma의 모든 컴포넌트 속성은 React props로의 쉬운 변환을 위해 1:1 매핑이 되어 있으며, 이 철학에는 예외가 없습니다.\u003c/p\u003e\n\u003cp\u003e그러므로, 우리는 컴포넌트 API, 기본값, 컴포넌트 네이밍 규칙 등을 어떻게 만드는지에 특별한 주의를 기울입니다. 팀은 이들 결정을 문서화하고 이유를 제시하며, 모든 다른 제품의 팀장들과 함께 이를 검토하는 것을 원칙으로 합니다. 이는 결정에 대한 집단 책임을 보장하고, 팀이 제품에 대한 가장자리 사례를 놓치지 않았는지를 확인하는 데 도움이 됩니다. 모든 사람으로부터 승인을 받으면 팀은 구현을 시작합니다.\u003c/p\u003e\n\u003cp\u003e여러 API 결정이 논의되었고 이들의 장단점이 나열된 카드 API 결정의 예를 들어 보겠습니다. 컴포넌트/_decisions 폴더에서 다른 API 결정들을 찾아볼 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e공지사항\u003c/h1\u003e\n\u003cp\u003e이전에 언급했듯이, DS 채택에 있어서 한 가지 장애물은 플랫폼 팀이 시스템을 충분히 마케팅하지 않는 것입니다. 제품 팀은 종종 기능, 릴리스, 버그, 인시던트 등에 집중되어 있어서 인프라 향상의 가능성에 즉각적으로 주의를 기울이지 않을 수 있습니다. 따라서 DS 팀은 주목받는 위치에 있도록 새로운 업그레이드, 구성 요소 추가, DS 버그 해결 등에 대해 지나치게 발표해야 합니다. 이곳에서 Blade Progress Bar 출시의 예를 들어 보세요.\nChaitanya Deorukhkar\n가 필요한 구성 요소의 기능을 강조하며, 동영상은 소비자들이 해당 구성 요소를 시도하고 싶어하는 호기심을 자극합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-15-CuttingdeepthroughBlade_1.png\" alt=\"Blade Progress Bar\"\u003e\u003c/p\u003e\n\u003cp\u003e온보딩의 편리함\u003c/p\u003e\n\u003cp\u003e회사가 성장하고 DS 소비자 베이스가 커짐에 따라, 새로 입사한 직원의 온보딩에 지식 전이 워크플로우를 통합하는 것이 매우 중요합니다. 이를 통해 정보 체인이 DS 팀에 부담을 주지 않고 소비자로부터 다른 소비자로 흐를 수 있습니다. Razorpay에서 우리는 각 디자이너가 프로젝트를 시작하기 전에 회사에 입사하기 전에 필수적으로 사용하는 내부 도구 위에 워크플로우를 만들었습니다.\u003c/p\u003e\n\u003ch2\u003e내부 사용 메트릭\u003c/h2\u003e\n\u003cp\u003eRazorpay는 OKR 방법론을 따르는 조직으로, 각 목표나 결정은 성공 기준을 정의하기 위해 숫자 메트릭으로 뒷받침되어야 합니다. Blade에서 결정한 모든 결정에 대해 동일한 형식을 확장하고, 결론은 데이터를 통해 도출되어야 했습니다.\u003c/p\u003e\n\u003cp\u003e이 아이디어를 향해 첫 번째 단계는 팀이 사용 정보 계측을 통해 소비자가 컴포넌트를 어떻게 사용하는지 이해하는 것이었습니다. 우리는 react-scanner를 활용하여 컴포넌트의 총 발생 횟수, 프로젝트별 사용, 흔히 사용되는 속성 대적게 사용되는 속성 등의 카테고리화된 사용 사례를 파악하는 데 도움이 되는 실용적인 유틸리티를 활용했습니다. 이를 통해 팀은 컴포넌트 사용 패턴을 이해하고 사용되지 않는 속성/토큰을 제거하고, 더 많이 사용되는 컴포넌트 그룹(input, feedback 등)에 투자하는 등의 결정을 내릴 수 있었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-15-CuttingdeepthroughBlade_2.png\" alt=\"이미지1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-15-CuttingdeepthroughBlade_3.png\" alt=\"이미지2\"\u003e\u003c/p\u003e\n\u003ch2\u003e페이지 % 커버리지\u003c/h2\u003e\n\u003cp\u003e우리 공동 창업자인 Shashank Kumar와의 회의 중에는 디자인 시스템에 대한 그의 비전에 대해 아이디어를 내고 있었습니다. 그의 질문은 간단하고 타당했어요 - \"나는 현재 조직이 Blade를 어떻게 사용하는지 모릅니다. 디자인 시스템을 사용하는 프로젝트가 4-5개라고 말한다면, 그게 좋은 숫자인지 아닌지 모릅니다. 그들이 실제로 Blade를 얼마나 사용하고 있습니까?\"\u003c/p\u003e\n\u003cp\u003e우리는 컴포넌트의 내부 계측을 해결했지만, 블레이드를 사용하는 소비자들이 정확히 어떻게 사용하는지는 알 수 없었습니다. 제품 A가 버튼 컴포넌트를 100번 사용했다고 말할 수는 있지만(대부분의 디자인 시스템에서 가능한 일), 모든 버튼이 Blade에서 왔는지 아니면 빠진 것이 있는지 확신할 수는 없었습니다. 우리는 디자인 시스템 채택 OKR을 위한 프레임워크를 수립하고 그에 지표를 부여하고 목표를 설정하고자 했습니다.\u003c/p\u003e\n\u003cp\u003e그러나 곧 채택률을 측정하는 명확한 표준이 없다는 사실을 깨달았습니다. 개발 생산성 목표를 세우면서, 컴포넌트 사용 횟수에 기반하여 개발자들이 작성하는 JS 및 CSS 코드 양이 얼마나 줄어들었는지 알아보려고 했지만, 이는 막다른 골목이라는 것을 깨달았습니다. 컴포넌트가 없을 경우 개발자들이 어떤 코드를 작성했을지를 사업 로직과 분리하여 추적하는 것은 현실적이지 않았습니다.\u003c/p\u003e\n\u003cp\u003e다수의 해결책에 대해 아이디어를 모아보는 도중 팀은 결국 \"유레카\" 순간을 맞이했습니다 - 만약 HTML 노드를 기본 분자로 삼아 Blade에서 나온 노드의 개수를 전체 페이지 노드 수와 비교하여 측정할 수 있는 메커니즘을 개발할 수 있다면 어떨까요? 그렇게 하면 Blade 컴포넌트의 노드를 사용하여 페이지의 몇 %가 구성되었는지를 측정하는 프레임워크를 가질 수 있을 것입니다!\u003c/p\u003e\n\u003cp\u003e아누라그 하즈라는 이 간단한 아이디어를 숨겨진 및 비어 있는 노드를 무시하고, 디자인 시스템 범위에 없는 노드(예: img, svg, 미디어 요소 등)를 무시함으로써 작은 스크립트로 변환했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/**\n * DOM 노드가 숨겨져 있는지 여부를 확인합니다.\n */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisElementHidden\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eelement\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (element.\u003cspan class=\"hljs-property\"\u003eparentElement\u003c/span\u003e \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-title function_\"\u003eisElementHidden\u003c/span\u003e(element.\u003cspan class=\"hljs-property\"\u003eparentElement\u003c/span\u003e)) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!(element \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHTMLElement\u003c/span\u003e)) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (element.\u003cspan class=\"hljs-property\"\u003ehidden\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e style = \u003cspan class=\"hljs-title function_\"\u003egetComputedStyle\u003c/span\u003e(element);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e style.\u003cspan class=\"hljs-property\"\u003edisplay\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\"none\"\u003c/span\u003e || style.\u003cspan class=\"hljs-property\"\u003evisibility\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\"hidden\"\u003c/span\u003e || style.\u003cspan class=\"hljs-property\"\u003eopacity\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\"0\"\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n * DOM 엘리먼트가 비어 있는지 여부를 확인합니다.\n */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisElementEmpty\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eelement\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!element) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!element.\u003cspan class=\"hljs-property\"\u003echildNodes\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n * DOM 노드가 미디어 엘리먼트인지 여부를 확인합니다.\n */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisMediaElement\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eelement\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e mediaTags = [\u003cspan class=\"hljs-string\"\u003e\"img\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"video\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"audio\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"source\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"picture\"\u003c/span\u003e];\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e mediaTags.\u003cspan class=\"hljs-title function_\"\u003eincludes\u003c/span\u003e(element.\u003cspan class=\"hljs-property\"\u003etagName\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoLowerCase\u003c/span\u003e());\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculateBladeCoverage\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e allDomElements = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003equerySelectorAll\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"body *\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e bladeNodeElements = [];\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e totalNodeElements = [];\n  allDomElements.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eelm\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-title function_\"\u003eisElementHidden\u003c/span\u003e(elm)) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-title function_\"\u003eisElementEmpty\u003c/span\u003e(elm)) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-title function_\"\u003eisMediaElement\u003c/span\u003e(elm)) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n\n    totalNodeElements.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(elm);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (elm.\u003cspan class=\"hljs-title function_\"\u003ehasAttribute\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"data-blade-component\"\u003c/span\u003e)) {\n      bladeNodeElements.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(elm);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (elm.\u003cspan class=\"hljs-title function_\"\u003eclosest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"[data-blade-component]\"\u003c/span\u003e)) {\n      bladeNodeElements.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(elm);\n    }\n  });\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e totalNodes = totalNodeElements.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e bladeNodes = bladeNodeElements.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e bladeCoverage = \u003cspan class=\"hljs-title class_\"\u003eNumber\u003c/span\u003e(((bladeNodes / totalNodes) * \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003etoFixed\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e));\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    bladeCoverage,\n    totalNodes,\n    bladeNodes,\n    bladeNodeElements,\n  };\n};\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ecalculateBladeCoverage\u003c/span\u003e());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e팁: 위 스니펫을 개발자 콘솔에서 실행하여 razorpay.com의 Blade % 커버리지를 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e한때 우리는 프레임워크를 갖추고 이론을 검증했습니다! Blade를 사용하여 제작된 많은 현재 페이지 중 일부는 미미한 커버리지를 갖고 있었습니다. 우리는 이 스크립트를 모든 앱에 통합하여 주기적으로 이 데이터를 기기 이벤트로 전달하고 지속적인 모니터링을 위한 대시보드를 구축했습니다. 이제 우리는 쫓아갈 지표를 갖게 되었습니다!\u003c/p\u003e\n\u003cp\u003e페이지 % 커버리지 메트릭은 곧 조직에서 표준이 되어 새로운 모듈 및 앱이 평가되었습니다. 개발자가 스크립트를 사용하기 쉽고 이를 통해 이 페이지의 어떤 섹션이 Blade에서 왔는지 여부를 스테이크 홀더(리더, 제품 매니저, 디자이너 등)가 쉽게 파악할 수 있도록 하기 위해\nSumit Gupta\n\u0026#x26;\nAnurag Hazra\nChrome 확장 프로그램과 통합하여 페이지의 % 커버리지를 제공하고 Blade가 아닌 노드를 강조했습니다.\u003c/p\u003e\n\u003cp\u003e공학 분야에서 % 페이지 커버리지 메트릭의 성공을 고려하여, 디자인 분야로 확장하기로 결정했습니다. 개발이 시작되기 전에 충분한 Blade 커버리지가 디자인 인계와 함께 이루어지도록 하는 것이 의미가 있다는 점에서 체크포인트를 설정하는 것이 합리적이었습니다.\u003c/p\u003e\n\u003cp\u003eKamlesh Chandnani는 Figma Blade 커버리지 플러그인을 만들었으며, 디자인 레이어를 평가하고 각 디자인 프레임 위에 작은 카드를 부착하여 디자인 인계 전에 커버리지를 계산합니다.\u003c/p\u003e\n\u003cp\u003eChaitanya Deorukhkar는 내부 사용 메트릭과 % 페이지 커버리지에 대한 상기 구현 사항을 설명하는 Measuring A Design System’s Success라는 강의에서 자세히 설명합니다.\u003c/p\u003e\n\u003cp\u003e또한, 유나이티드 항공 홈페이지에 대한 디자인 시스템 커버리지에 관한 Dan Mall의 기사도 참조하십시오. 이는 이 구현에 영감을 준 것입니다.\u003c/p\u003e\n\u003ch2\u003e중앙 기관 목표\u003c/h2\u003e\n\u003cp\u003e블레이드 커버리지를 측정하기 위한 프레임워크를 수립하는 것은 디자인 시스템 채택을 위한 기반을 마련하는 일이었습니다. 페이지를 블레이드 노드와 블레이드 노드가 아닌 것으로 이분화하고 앱에서 블레이드 % 페이지의 평균을 집계하여 앱별 기준을 단일 메트릭으로 정의하고 있습니다. 기준이 마련되면 디자인 시스템 채택, 미래 상태, 위험 및 디자인 및 엔지니어링을 위한 가능한 조직 전체 목표에 대한 전략을 개발하고 작성할 수 있었습니다.\u003c/p\u003e\n\u003cp\u003e채택 목표를 개발하고 전략을 세울 때 주의해야 할 두 가지가 있었습니다. 새로운 앱은 모두 블레이드를 이용하여 구축되어야 하며 기존 앱의 이전 모듈도 일관성을 유지하기 위해 블레이드로 이ꁼ되어야 했습니다. 이는 Razorpay를 위한 조직 목표로 이어졌습니다.\u003c/p\u003e\n\u003cp\u003e모든 앱을 대상으로 한 전체 목표는 모든 페이지 또는 모듈의 평균을 20%로 설정하는 것이었습니다. 이는 70%의 새로운 페이지를 커버하여 달성해야 하는 당연한 일이었습니다. 그러나 더 까다로운 부분은 이전 페이지를 이전하는 것으로, 특정 페이지 수에 초점을 맞추기보다는 고객의 시각에서 시각적 일관성을 유지하기 위해 많은 트래픽을 가진 페이지에 초점을 맞추기로 결정했습니다.\u003c/p\u003e\n\u003cp\u003e디자인 시스템 전략을 작성할 때 디자인 전략, 기여 및 이ꁼ 가이드 등과 같이 세부 정보를 자세히 작성하여 팀, 애플리케이션 소유주 또는 새로운 이해 관계자 간의 불일치를 해소하는 것이 중요합니다. 첨부된 예시를 확인하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-15-CuttingdeepthroughBlade_4.png\" alt=\"Cutting deep through Blade\"\u003e\u003c/p\u003e\n\u003ch2\u003e지원\u003c/h2\u003e\n\u003cp\u003e디자인 시스템 채택에 있어 성숙성, 완성도 또는 철저한 문서 작성 여부와 관계없이, 소비자들이 블로커(blockers) 상황에서 가능하게 하거나 지원하는 잘 정의된 지원 프로세스가 중요합니다. Blade의 경우, 우리는 소비자들을 다음과 같은 방법으로 지원했습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e엔지니어 및 디자이너들이 의심 사항이나 새로운 사용 사례를 논의하는 오픈 오피스 시간 (주당 두 번)\u003c/li\u003e\n\u003cli\u003e잘 정의된 레이블이 있는 Github Issues\u003c/li\u003e\n\u003cli\u003eJIRA의 즉시 지원 요청\u003c/li\u003e\n\u003cli\u003e빠른 쿼리를 위한 전용 Slack 채널\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-15-CuttingdeepthroughBlade_5.png\" alt=\"Cutting deep through Blade\"\u003e\u003c/p\u003e\n\u003cp\u003e저희 지원 구조는 디자인 시스템의 기반 및 구성 요소를 탐색하는 데 소비자들을 다양한 방법으로 지원하는 데 그치지 않고, 플랫폼 팀이 신규 패턴, 일반적 용법 또는 기존 구성 요소의 향상에 대해 더 많이 학습할 수 있도록 함으로써 Blade의 지속적인 개선에 이바지하고 있습니다.\u003c/p\u003e\n\u003ch2\u003e전도사들\u003c/h2\u003e\n\u003cp\u003e이전에 우리는 디자인 시스템 팀이 작고 조직의 모든 신규 제품 요구 사항에 대해 모든 해결책을 제시하거나 개념을 도출할 수 있는 단일 연락 대상이 될 수 없다고 결정했습니다. 따라서 조직 내에서 각 비즈니스 부서를 대표하는 기둥 또는 전도사가 존재하는 것이 중요하며, 이들이 디자인 시스템에 관한 문제나 쿼리를 해결하거나 새로운 구성 요소나 구성 요소의 변형에 대해 아이디어를 제기하는 데 사용되는 자리로 활약할 수 있도록 하는 것이 중요합니다. 우리는 이들을 \"Blade 대변인\"이라고 부릅니다.\u003c/p\u003e\n\u003cp\u003eBlade 대변인은 Razorpay의 각 비즈니스 부서에서 온 제품 디자이너들의 그룹으로, 해당 제품의 각 Blade 구성 요소에 대한 감사, 사용 사례 및 입력을 제공하고 최종 결과물을 검토합니다. 모든 Blade 구성 요소의 디자인 단계 동안 우리는 대변인들에게 각자의 제품에서 사용 사례를 제공하도록 요청하고 디자인이 완료된 후에는 그룹과 함께 구성 요소를 검토합니다. 이는 구성 요소가 조직의 요구 사항을 충족시키는지 확인하는 데 도움이 되는 것 뿐만 아니라 디자이너가 승인하면 최종 구성 요소가 최종적으로 채택될 것임을 확인하는 데 도움이 됩니다. 이 연습의 부작용 중 하나는 대변인 그룹이 지속적으로 새로운 구성 요소와 디자인 시스템의 토큰에 대해 교육받으면서 플랫폼과 제품 사이의 간극을 줄이게 되며 그들은 차후 동료들 사이에 지식을 전파할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003eFGD 및 설문 조사\u003c/h2\u003e\n\u003cp\u003e소비자에 직접적으로 노출되지 않는 제품의 경우 성공 지표를 정의하기 어렵습니다. 대부분의 경우 팀은 소비자들이 그들의 제품에 대한 인식을 이해하기 위해 설문조사 및 집중 토론 그룹(FGD)을 활용하여 NPS(순 수익률 지수)를 생성합니다. 우리는 생산성, 개발자-디자이너 간 마찰, UI 반복 감소, Figma와 코드 간의 일치, 문서 작성, 효율적인 의사 소통 등과 관련된 다양한 범주에 대한 질문을 포함하여 개발자와 디자이너 모두를 대상으로 설문 조사를 적극적으로 실시했습니다. 또한, 팀은 비즈니스 부문이나 툴 유형(React/ReactNative/Svelte)별로 구분된 다양한 집단과 FGD를 진행하는데, 이 때 질문은 자주 설문조사 결과에서 나오는 주제에 대해 더 심층적으로 들어갑니다. 블레이드의 유연성 대 제약, 디자인에서 개발로 컴포넌트/토큰 매핑, 신규 개발자의 진입 장벽, 다른 UI 라이브러리와의 비교, 기존 컴포넌트 대 사용자 지정 컴포넌트 등의 주제를 다룹니다.\u003c/p\u003e\n\u003cp\u003e표면적으로 이런 방대한 설문조사나 FGD를 실시하는 것은 지루할 수 있지만, 이로 인해 상당한 성과를 거두게 됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e설문 조사는 디자인 시스템을 사용하는 디자이너와 개발자들이 느끼는 전반적 인식에 대한 NPS를 제공합니다. 이는 플랫폼 팀이 매년 추구할 수 있는 점수를 제공하고 개선을 시도할 수 있게 합니다.\u003c/li\u003e\n\u003cli\u003e설문 조사 결과는 리더십에게 디자인 시스템에 대한 투자를 정당화하는 효과적인 시각을 제시합니다.\u003c/li\u003e\n\u003cli\u003e개선 및 도입 과제에 대해 소비자와 대화하는 것은 어떻게 지속할지에 대한 좋은 통찰을 제공할 수 있으며, 결과적으로 더 나은 채택 OKRs로 이어질 수 있습니다.\u003c/li\u003e\n\u003cli\u003e소비자가 자유롭게 의견을 피력할 수 있는 플랫폼을 제공함으로써, 플랫폼 팀이 관심을 가지고 디자인 시스템의 개발에 대한 협력적인 태도를 강화할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e브랜딩\u003c/h2\u003e\n\u003cp\u003e어떤 제품에 개성을 부여하는 것은 중요합니다. 그래서 여러분이 '파이트 클럽'에서 브래드 피트를 에드워드 노튼보다 더 기억하는 이유죠 (스포일러 주의!). 이와 같은 이유로 우리는 Blade와 관련된 견고한 브랜드를 구축하면 조직 및 세계와의 연관이 쉬워질 것이라고 결정했습니다. 우리는 로고를 만들고, 로고 내에서 돋보이는 글꼴, 명확한 색상 팔레트 등 여러 요소를 고려했습니다. 이 결과는 강렬하며, 브랜드에 대한 시각적인 이해를 제공하여 소통을 용이하게 했습니다 (생각보다 많은 Slack 이모티콘 반응들).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-15-CuttingdeepthroughBlade_6.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003e상품\u003c/h2\u003e\n\u003cp\u003e브랜드가 확립되자마자, 우리는 소비자와 초기 채택자들을 보상하고 기업 전반에서 블레이드의 전도를 돕는 목표를 가지고 주변 상품을 만들기로 하였습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-15-CuttingdeepthroughBlade_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e보상 및 인정\u003c/h2\u003e\n\u003cp\u003e성공적인 디자인 시스템 채택 과정은 종종 기업 전반의 노력이 필요하며 플랫폼 팀에만 할애되어서는 안 됩니다. 따라서 목표를 믿고 이를 실현하기 위해 노력하는 개인들을 인정하는 것이 중요합니다. 이는 전체 조직에 이들을 축하시키고 다른 이들에게 미래를 위한 유사한 노력을 기울이도록 영감을 주면서 간접적으로 시스템의 영향력을 강조합니다. 우리는 많은 이러한 개인들을 축하하며 팀의 성취를 강조하고 노력 중에 긍정적인 문화적 영향을 창출하였습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eBlade는 Razorpay의 약 13개 제품에 속해 있다. Blade는 설립 이후 많은 발전을 거쳐 현재는 통합되고 성숙한 제품이 되었습니다. 회사의 규모와 운영이 커지면서 다른 사업을 인수할 때, 정교한 디자인 언어를 사용하면 모든 제품을 하나의 우산 아래로 모을 수 있습니다. 또한 견고한 기반 덕분에 Blade는 기업이 요구할 때 용이하게 시각적 화장 도구를 통해 시각적 활기를 불어넣었으며 이는 우리의 Figma 라이브러리 오픈 소스화로 이어졌습니다.\u003c/p\u003e\n\u003cp\u003e몇 년 동안 Blade는 업계에서 많은 호평을 받았지만 Figma가 디자인 시스템 채택과 디자인 개발 협업의 증진에 대해 협력한 Boosting design system adoption에 대해 우리와 협업했을 때 이에 최고조를 달렸습니다. 또한 그들은 위에서 논의한 주제들을 How Razorpay sharpened developer workflows라는 기사에서 게재했습니다. 이제까지 오신 분들에게 추천드리는 글입니다.\u003c/p\u003e\n\u003cp\u003e디자인 시스템의 도입은 도전적이었지만 결과는 모범적이었습니다. 이러한 성과의 대부분은 팀에게 돌아가지만, 여기서의 한계는 없으며 팀이 미래에 어떤 것을 만들어내는지 기다릴 수 없습니다.\u003c/p\u003e\n\u003cp\u003e디자인 -\nSaurav Rastogi, Rama Krushna Behera, Abhishek Bhardwaj, Gopi Bhatnagar, Aditi Arora, Pingal Kakati, Saurabh Soni\u003c/p\u003e\n\u003cp\u003e엔지니어링 -\nKamlesh Chandnani, Chaitanya Deorukhkar, Anurag Hazra, Saurabh Daware, Nitin Kumar, Divyanshu Maithani, Dhruvdutt Jadhav, Abinash Shaw, Varun Achar\u003c/p\u003e\n\u003ch2\u003e블레이드 참조\u003c/h2\u003e\n\u003cp\u003eFigma 라이브러리\nGitHub 코드베이스\n문서화\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-15-CuttingdeepthroughBlade"},"buildId":"bcl7D5eEo4s3Ou6aXCZKZ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>