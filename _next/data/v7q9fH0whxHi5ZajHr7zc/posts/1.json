{"pageProps":{"posts":[{"title":"비디오 게임으로 러스트 마스터하기 2부  게임 메커닉 익히기","description":"","date":"2024-07-01 17:46","slug":"2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics","content":"\n\n1부를 아직 안 읽으셨나요? 확인해보세요!\n\n자, 이제 우리는 Rust 로봇을 세팅했어요. 그럼 이제는 뭘 해야 할까요?\n\n목표는 최고의 로봇 킬러를 만드는 것입니다. 순위 시스템에서 다른 플레이어들의 로봇과 경쟁할 겁니다 — 더 많은 경기에서 승리하면 순위가 올라가요. 이게 다예요! 덤으로 매월 대회가 열려 최종 우승자를 가립니다. 👑\n\n![이미지](/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_0.png)\n\n<div class=\"content-ad\"></div>\n\n멋져요! 이제 우리가 만들고 있는 로봇을 이해해야 합니다. 로봇은 빌딩 화면에서 선택할 4개의 구성 요소가 있습니다. 현재 우리 로봇은 4개의 라이플을 가지고 있습니다. 이러한 구성 요소는 아래 이미지에 표시된 대로 숫자로 식별됩니다. 여기서 0은 앞, 1은 위, 2는 왼쪽, 3은 아래를 나타냅니다. 이는 머리의 방향에 기반합니다. 나중에 머리를 회전시킬 것입니다.\n\n![로봇 구성요소](/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_1.png)\n\n구성 요소 외에도 모듈이 있습니다. 이러한 모듈은 특별한 기능을 수행하여 로봇이 주변을 관찰하고 독특한 능력을 실행할 수 있도록 합니다. 실제 로봇을 프로그래밍해본 적이 있다면 센서가 세계를 인식하는 데 중요한 역할을 한다는 것을 이해할 것입니다. 이 게임은 모듈을 통해 비슷한 개념을 적용합니다. 레이더, 레이저 및 힘-필드 모듈로 시작할 것입니다요.\n\n![로봇 모듈](/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_2.png)\n\n<div class=\"content-ad\"></div>\n\n그럼, 첫 번째 강력한 머신을 만드는 것으로 들어가 봅시다.\n\n이 머신의 계획은, 우리의 위치를 기반으로 적이 어디에 있는지 감지하기 위해 레이더 모듈을 사용할 것입니다. 그런 다음 우리는 적에게 모든 구성 요소(소총)를 조준하여 사용할 것입니다. 그리고 계속 발포하도록 반복할 것입니다!\n\n나는 코드를 모두 넣어둘 것인데, 한 번 살펴봐 주겠니? 러스트에 완전히 처음이신 분들은 조금 무서울 수 있습니다. 하지만 우리는 모든 것을 살펴보고 기사의 끝에는 더 잘 이해하실 수 있기를 희망합니다!\n\n그래서 여기 커다란 무서운 코드 덤프 입니다:\n\n<div class=\"content-ad\"></div>\n\n```rust\n#![allow(unused_must_use)]\nuse rbot;\n\n// 코드의 진입점입니다. lib.rs 파일에 main 함수가 필요합니다. 사용자 정의 코드와 상호작용하는 게임의 인터페이스로 작동합니다. 새 파일, 모듈을 생성하고 온라인 패키지를 사용하십시오. 코드는 WebAssembly로 컴파일되어야 합니다.\n//\n// 문서는 다음에서 확인할 수 있습니다: https://docs.rs/rbot/latest/rbot/\npub fn main() {\n    loop {\n        // 레이더를 사용 가능할 때까지 기다립니다. 쿨다운이 있으므로 항상 호출할 수 없습니다. await_module을 사용하여 준비되었음을 확인합니다.\n        rbot::modules::await_module(rbot::modules::Module::Radar);\n\n        // 적 위치를 알아내기 위해 레이더 모듈을 사용합니다.\n        let radar_msg = rbot::modules::radar().unwrap();\n\n        // 적의 위치에 대한 각도를 x와 y를 각도로 변환하여 구합니다.\n        let angle = rbot::conversions::xy_to_angle(radar_msg.x, radar_msg.y);\n\n        for i in 0..4 {\n            // 특정 구성 요소를 적 방향으로 조준합니다.\n            rbot::await_aim(i, angle, 0.5);\n\n            // 구성 요소가 사용할 준비가 될 때까지 기다립니다.\n            rbot::await_component(i);\n\n            // 특정 구성 요소를 사용합니다.\n            rbot::use_component(i, false);\n        }\n    }\n}\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1152/1*hDUUgh1Dy2iWkOXtpkviBQ.gif\" />\n\n아아아아!? 무서워!! 하지만 걱정 마세요, 모두 함께 해결해 나갈 거에요. 한 걸음씩.\n \n메인: 먼저, 우리의 main 함수를 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\n```rust\npub fn main() {\n  \n}\n```\n\n이게 뭐지? 우리 프로그램의 진입점이야. 똑똑한 사람이 이렇게 해야 한다고 결정하고, 우리는 단순히 받아들일 뿐이야. 대부분의 프로그래밍 언어에서 비슷한 구조를 찾을 수 있어. 오늘은 여기서 우리 모든 코드를 작성할 거야.\n\nLoop: 다음 코드 블록은 loop야.\n\n```rust\nloop {\n\n}\n```\n\n<div class=\"content-ad\"></div>\n\n루프는 코드를 여러 번 반복해서 실행하는 데 정말 좋은 도구에요. 계속해서 반복해서 반복해서 반복해서 반복해서 반복해서 반복해서 반복해서… 이렇게 이해하시죠. '...' 안에 있는 내용이 계속해서 반복되죠. 멋지죠! 로봇이 끊임없이 작업을 실행하도록 원할 때 매우 유용한 기능이에요.\n\n로봇 명령어: 이제 로봇 명령어에 대해 이야기해볼게요! 여기서 우리는 로봇이 원하는 일을 하도록 지정할 수 있어요. 이 코드 블록에서 레이다 모듈이 활성화될 준비가 될 때까지 기다리도록 로봇에게 지시하는 거에요. 이걸 안하면 레이다를 호출했을 때 실패하고 대신 에러를 반환할 수도 있어요 (에러에 대해서는 나중에 더 설명할게요).\n\n```js\nrbot::modules::await_module(rbot::modules::Module::Radar);\n```\n\n로봇 명령어: 이제 레이다를 안전하게 사용하고 로봇으로부터 센서의 읽기 값이 돌아올 수 있어요. 이 메시지에는 적 로봇의 위치에 대한 정보가 포함되어 있어요. 이 정보를 통해 그 적을 조준하고 파괴할 수 있어요! 😈\n\n<div class=\"content-ad\"></div>\n\n```js\nlet radar_msg = rbot::modules::radar().unwrap();\n```\n\n로봇 명령: 이 메시지로부터 적에 대한 x와 y 좌표를 상대적으로 얻습니다. 이 정보를 적이 있는 각도로 변환할 수 있습니다. 각도와 좌표에 대해 아무것도 모른다면 일단 받아들이세요. 우리는 앞으로 수학적인 내용에 더 깊이 들어갈 것입니다! 이것은 로봇공학을 할 때 이해해야 하는 매우 중요한 개념으로, 여기서 배우고자 하는 것입니다!\n\n```js\nlet angle = rbot::conversions::xy_to_angle(radar_msg.x, radar_msg.y);\n```\n\nFor-loop: Loop와 비슷하게, for-loop는 코드를 여러 번 반복해서 호출하는 데 사용됩니다. Loop와 for-loop의 차이점은 우리가 블록을 몇 번 실행할지를 지정할 수 있다는 것입니다. 이 경우에는 블록을 4번 실행할 것입니다. 또한 몇 번째 반복 중에 있는지를 나타내는 변수 i를 가지고 있을 것입니다. 이렇게 하면 모든 컴포넌트(조준하고 발사하는 등)에 대해 동일한 절차를 수행할 수 있습니다!\n\n<div class=\"content-ad\"></div>\n\n로봇 명령: 이 명령은 로봇이 지정된 각도를 향하도록 하는 것을 명령합니다. 로봇이 각도를 향할 때까지 코드는 실행을 멈추며, 허용 오차는 0.5도입니다. 한 번 로봇이 각도를 향했을 때, 코드는 계속 실행됩니다. 우리는 조준한 후에만 발포하길 원하기 때문에 정말 좋은 방법이죠! for 루프에서 i에 주목해주세요! 이전에 기사에서 설명한 대로 '0,1,2,3' 구성요소를 사용 중입니다.\n\n```js\nrbot::await_aim(i, angle, 0.5);\n```\n\n로봇 명령: 이제 거의 적을 공격할 준비가 된 상태입니다. 그러나 무기가 준비된 상태인지 확인해야 합니다. 무기에 총알이 없는 상태에서 쏘려고 한다면 어색할 테니까요? 그래서 이 명령은 로봇에게 코드 실행을 계속하기 전에 구성 요소가 준비될 때까지 기다리라고 지시하는 것입니다!\n\n```js\nrbot::await_component(i);\n```\n\n<div class=\"content-ad\"></div>\n\n로봇 명령: 발사! 이제 우리는 소총으로 쏠 수 있어요! 우리 총알이 적에 맞아 가는 걸 지켜보고 승리의 달콤함을 누려보세요! 참고로, \"false\"는 로봇에게 소총을 계속 발사하지 말라고 말해요. 우리는 한 번만 쏘기를 원해요!\n\n```js\nrbot::use_component(i, false);\n```\n\n준비를 마친 우리 로봇은 이제 투기장에 들어가 다른 로봇과 싸울 준비가 돼 있어요!\n\n친절하게, 로봇을 컴파일하는 것을 기억해 주세요!!! 코드를 업데이트하더라도 아무것도 바뀌지 않는다고 생각하신다면, 아마 컴파일을 잊은 것일 겁니다.\n\n<div class=\"content-ad\"></div>\n\n서버에 코드를 업로드하려면 뒤로 가기 버튼을 누르고 실행 버튼을 눌러주세요! 당신의 로봇은 랭킹에 따라 실력에 맞는 로봇과 대결하게 될 것입니다. 이기면 이기는 만큼 로봇의 랭킹이 올라갑니다.\n\n![로봇 대결](https://miro.medium.com/v2/resize:fit:1152/1*YYOoeiUS00hHvJd9-twJUg.gif)\n\n당신의 로봇이 승리할 수 있기를 바랍니다!\n\n이 기사는 많이 진전되었죠. 제가 알고 있어요! 우리는 일어날 수 있는 최소한의 장벽을 넘어야 했을 뿐입니다. 걱정하지 마세요, 앞으로 우리는 천천히 속도를 줄여 뒤로 한 걸음 물러서며 천천히 전진할 겁니다!\n\n<div class=\"content-ad\"></div>\n\n다음 기사를 기대해주세요! 거기에서는 Rust, 프로그래밍 및 로봇 공학 세계를 더 깊이 파헤쳐볼 예정이에요!\n\n코딩 즐겁게 하세요!\n\n참고: 이 게임은 초기 액세스 중이며 개발 중에 있습니다. 이해하기 어려운 부분이 있다면, https://botbeats.net에서 찾을 수 있는 디스코드 채널로 이동해보세요. 개발자들은 여러분의 모든 질문에 즐겁게 답변해주고 버그를 가능한 한 모두 해결하려 할 거에요!","ogImage":{"url":"/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_0.png"},"coverImage":"/assets/img/2024-07-01-MasterRustbyPlayingVideoGamesPart2GameMechanics_0.png","tag":["Tech"],"readingTime":6},{"title":"라즈베리 파이 시작하기 첫 번째 프로젝트 만드는 방법","description":"","date":"2024-07-01 17:45","slug":"2024-07-01-GettingStartedwithRaspberryPiBuildingYourFirstProject","content":"\n\n![Getting Started with Raspberry Pi](/assets/img/2024-07-01-GettingStartedwithRaspberryPiBuildingYourFirstProject_0.png)\n\n라즈베리 파이는 작고 저렴한 컴퓨터로, 프로그래밍 학습부터 복잡한 전자 제품까지 다양한 프로젝트에 사용할 수 있습니다. 초보자든 경험 많은 개발자든, 라즈베리 파이는 컴퓨팅과 전자공학의 세계로 입문하기 쉽고 재미있는 방법을 제공합니다. 이 기사에서는 라즈베리 파이 설정부터 간단한 프로젝트 완성까지 안내해드리겠습니다: 기본 LED 깜박임 회로 만들기.\n\n## 준비물\n\n시작하려면 다음 구성품이 필요합니다:\n\n<div class=\"content-ad\"></div>\n\n- Raspberry Pi (모델 3 이상 권장)\n- Raspberry Pi OS가 설치된 MicroSD 카드 (적어도 8GB)\n- 전원 공급 장치 (5V, 2.5A)\n- HDMI 케이블 (모니터에 연결)\n- USB 키보드와 마우스\n- 브레드보드\n- LED (어떤 색상이든 상관 없음)\n- 저항기 (220옴)\n- 점퍼 와이어\n\n## 단계 1: Raspberry Pi 설정\n\n- Raspberry Pi OS 설치: MicroSD 카드에 OS가 이미 설치되어 있지 않은 경우 Raspberry Pi 웹사이트에서 다운로드할 수 있습니다. Rufus와 같은 도구를 사용하여 OS 이미지를 MicroSD 카드에 플래시합니다.\n- MicroSD 카드 삽입: MicroSD 카드를 Raspberry Pi의 슬롯에 넣습니다.\n- 주변 기기 연결: HDMI 케이블을 Raspberry Pi와 모니터에 연결하십시오. USB 키보드와 마우스를 Raspberry Pi의 USB 포트에 연결합니다.\n- 전원 공급: 전원 공급 장치를 꽂아 Raspberry Pi를 켭니다. Raspberry Pi OS 데스크톱이 표시될 것입니다.\n\n## 단계 2: LED 깜박임 프로그램 작성\n\n<div class=\"content-ad\"></div>\n\n- 터미널 열기: 작업 표시 줄에서 터미널 아이콘을 클릭하여 명령줄 인터페이스를 엽니다.\n- GPIO 라이브러리 설치: 다음 명령을 입력하여 GPIO 라이브러리가 설치되어 있는지 확인합니다:\n\n```js\nsudo apt-get update\nsudo apt-get install python3-rpi.gpio\n```\n\n3. 파이썬 스크립트 만들기: 텍스트 편집기(예: Thonny Python IDE)를 열고 다음 코드를 작성하여 LED를 깜박이게 만듭니다:\n\n```js\nimport RPi.GPIO as GPIO\nimport time\n\nLED_PIN = 18\n\nGPIO.setmode(GPIO.BCM)\nGPIO.setup(LED_PIN, GPIO.OUT)\n\ntry:\n    while True:\n        GPIO.output(LED_PIN, GPIO.HIGH)\n        time.sleep(1)\n        GPIO.output(LED_PIN, GPIO.LOW)\n        time.sleep(1)\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    GPIO.cleanup()\n```\n\n<div class=\"content-ad\"></div>\n\n4. 스크립트 저장: 스크립트를 blink.py로 저장해 주세요.\n\n## 단계 3: 회로 만들기\n\n- LED를 브레드보드에 놓기: LED를 브레드보드에 삽입하세요. 긴 다리(양극)가 긍정(+), 짧은 다리(음극)가 부정(-)임을 유의해 주세요.\n- 저항 연결: 저항의 한쪽 끝을 LED의 짧은 다리(음극)에 연결하고 다른 쪽을 브레드보드의 그라운드 레일에 연결하세요.\n- 점퍼 와이어 연결:\n\n  - 라즈베리 파이의 GPIO 핀 18번에서 LED의 양극에 점퍼 와이어를 연결하세요.\n  - 브레드보드의 그라운드 레일에서 라즈베리 파이의 GND 핀에 접지 핀용 점퍼 와이어를 연결하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-07-01-GettingStartedwithRaspberryPiBuildingYourFirstProject_1.png)\n\n## 단계 4: 프로그램 실행\n\n- Python 스크립트 실행: 터미널에서 스크립트를 저장한 디렉토리로 이동하여 다음을 실행합니다:\n\n```bash\npython3 blink.py\n```\n\n<div class=\"content-ad\"></div>\n\n2. LED 깜박임 확인: 만약 모든 것이 제대로 연결되어 있다면 LED가 1초마다 켜졌다가 꺼졌다가 할 것입니다.\n\n이 간단한 LED 깜박임 프로젝트는 Raspberry Pi에서 GPIO (일반용도 입력/출력) 프로그래밍의 기본을 소개합니다. 여기서부터는 날씨 관측소를 만들거나 홈 자동화 시스템을 구축하거나 자신만의 레트로 게임 콘솔을 개발하는 등 더 복잡한 프로젝트를 탐험할 수 있습니다. 가능성은 무궁무진하며, 방대한 커뮤니티와 자료들이 제공되므로 Raspberry Pi로 무엇을 할지 아이디어가 절대 바닥나지 않을 것입니다. 아래 댓글에 경험과 통찰을 공유해 주세요! 즐거운 만들기!!","ogImage":{"url":"/assets/img/2024-07-01-GettingStartedwithRaspberryPiBuildingYourFirstProject_0.png"},"coverImage":"/assets/img/2024-07-01-GettingStartedwithRaspberryPiBuildingYourFirstProject_0.png","tag":["Tech"],"readingTime":3},{"title":"젊은 예술가의 성장 과정 성공과 도전의 여정","description":"","date":"2024-07-01 17:43","slug":"2024-07-01-EvolutionofaYoungArtist","content":"\n\n## 자기주도 학습\n\n어릴 적부터 나는 항상 예술가였어요. 그림을 그리는 것을 좋아했고, 상상 속이나 주변 세계의 이미지를 스케치하곤 했어요. 종이 조각에 그리고 일기장에 그리며, 가능한 경우라면 숙제에도 미술을 포함시킬려고 했죠.\n\n어른들로 부터 제 미술에 대한 칭찬을 자주 받았던 기억이 선명해요. 제가 재능 있고, 뛰어나다고 말해주셨죠. 미술 기반의 숙제는 대부분 A를 받았고 (위 두 이미지처럼), 빠른 인정을 받을 방법으로 그림 그리기를 배웠어요.\n\n아마도 이 인정이 적어도 일부는 어린 시절 내내 예술가가 될 것이라는 자신감을 갖게 해준 것이며, 이것은 절대로 요동이 없었어요.\n\n<div class=\"content-ad\"></div>\n\n내가 성장함에 따라, 나는 내 목표에 대해 단호했고 노트북에서 스케치하고 그림을 그려 나가며 이를 추구했다. 전공 수업을 선택할 때, 나는 항상 미술 수업을 택했고, 거기서 색상 활용, 1점 및 2점 원근 등 젊은 예술가들이 기술을 향상시키도록 고안된 기술들에 대해 배웠다.\n\n시간이 흘러, 나의 기술은 향상되었다. 내 작품은 더욱 나아지고, 내가 만들어 내는 작품에 자부심을 가졌다. 또한 동료들과 어른들로부터 칭찬을 계속 받았던 것도 좋은 도움이 되었다. 이를 통해 나의 작품에 대한 확신을 갖게 되었다.\n\n나의 미술에 대한 사랑은 여가 시간에도 이어졌다. 방과 후 가장 좋아하는 시간은 잡지를 넘겨보며 보냈다—건축, 패션 등 어떤 종류든지—사진, 삽화, 페이지 전체의 시각적 미를 탐하며. (나중에 콜라주 아트에 대해 배우면서, 이러한 페이지를 소스 자료로 사용하기 시작했다.)\n\n첫 미술 박물관을 방문했을 때는 정확히 언제였는지는 기억이 안 나지만, 그 경험은 분명 감탄스러웠다. 흰 벽에 걸린 위대한 예술가들의 그림들을 목격하는 것은 언제나 나에게 영감을 줬고, 집에 돌아가 종이를 꺼내어 그렸다. 오늘날까지, 미술 박물관을 방문하는 것은 내가 가장 좋아하는 활동 중 하나이며, 나는 한 작품에 완전히 빠져들기도 한다. 나를 발견할지도 모르겠다. 그때는 붓질, 빛과 그림자, 그리고 색상 사용에 매료되어 그냥 그대로 서 있을지도 몰라.\n\n<div class=\"content-ad\"></div>\n\n예술을 경험함으로써 예술에 대한 사랑이 더해지고, 계속해서 스케치와 그림을 그리고 싶게 만들어주었어요— 창의성의 아름다운 나선으로 이어지는 것 같아요.\n\n# 그리고, 깨달음\n\n고등학교 때, 열정을 충전하기 위해 예술 수업을 선택하고 여가시간에 그림을 그리고 색을 연구해왔어요. 이러한 시간을 통해 사진을 참고하여 정확하게 그림을 그리거나 색과 스타일을 실험하는 능력이 향상되었어요. 그러나 어떤 변화가 시작되었어요.\n\n두 번째 해의 예술 수업에서 어떤 깨달음을 얻었어요. 전문 예술가의 작품을 배우면서 나만의 작품을 창작하는데, 내 내면에서 생각했던 열정과 헌신이 없는 것을 깨달았어요.\n\n<div class=\"content-ad\"></div>\n\n그림 그리기와 스케치에는 물론이고, 보통 하나의 작품을 한 번에 마무리하는 것을 선호했어요(가능하다면). 수십 시간을 들여 몇 달이나 몇 년 동안 섬세한 디테일로 작품을 완성하는 것에는 흥미가 없었죠.\n\n전문 화가가 되는 건 제게 어울리지 않았어요.\n\n이 깨달음을 깨달을 당시, 창작글쓰기에 대한 사랑도 발견하게 되었어요.\n\n항상 예술가였다는 게 사실이긴 해도, 오히려 더 읽는 사람이라고 말할 수 있을 거예요. 저는 열정적으로 책을 읽었죠—어머니께서 어릴 적 제가 혼자서 쉬고 있어도 걱정할 필요가 없다고 자주 얘기하곤 했는데요. 왜냐면 책을 읽는 게 반가웠기 때문에 엄마가 돌아오면 제가 아직 그 자리에 앉아 있을 거라고 확신하셨거든요.\n\n<div class=\"content-ad\"></div>\n\n내가 예술을 좋아하는 것 보다 말에 대한 사랑이 더 크다. 어린 시절에는 지금처럼 이야기, 시, 에세이, 기사를 쓰는 일이 나에게 이를 추구할 수 있는 길일 수 있다는 생각이 전혀 들지 않았다. 그러나 내 예술에 대한 갑작스러운 깨달음은 나로 하여금 추구할 다른 길을 찾게 하였고, 이것이 바로 나의 글쓰기에 대한 열정을 열어준 문이 되었고, 수천 시간을 쏟아부을 기관을 가진 공예로써 쓰기를 추구할 수 있는 길로 열어주었다.\n\n# 나의 창의적인 공간을 지키기\n\n예술은 여전히 내 삶의 중요한 일부이다. 여전히 박물관을 방문하고 여전히 예술을 한다. 저널이나 영수증 뒷면, 랜덤한 종이 조각에 스케치하고 낙서를 한다. 어른들을 위한 색칠북을 채우며 색상을 혼합하고 놀아본다. 그리고 최근에는 수채화를 탐험해왔다. 또한 친구와 함께 하는 팔찌 제작부터 조카를 위한 할로윈 의상 장신구 디자인까지 다양한 공예를 즐긴다.\n\n나의 예술하는 것을 사랑하는 마음은 결코 내게서 떠나가지 않을 것이며, 순수한 기쁨과 즐거움을 유지하기 위해 치열하게 보호하고 있다.\n\n<div class=\"content-ad\"></div>\n\n현재의 자본주의 상태에서, 우리가 하는 모든 창의적인 일을 돈 버는 것으로 전환시키려는 경향이 종종 있습니다. 더 많은 돈을 벌어야 하고, 자유를 얻어야 하며, 알고리즘 기계를 유지해야 합니다. 생산량에 대한 지속적인 압박이 있으며, 이것은 저도 내 글쓰기 경력에서 분명히 느끼는 것입니다.\n\n잘못 이해하지 마세요. 글쓰기를 사랑하지만, 이 사랑하는 일을 중심으로 한 경력 구축은 스트레스와 함께 오는 것입니다. 글을 써야 하고, 작품을 출판에 제출하고, 희망적으로 발표되고(그리고 돈을 받고), 독자들을 모집해야 합니다. 지속적으로 실력을 연마하고 성장해야 하며, 한껏 실력껏 글을 써야 합니다. 이 모든 것을 저는 저의 작가, 시인, 게임 작가로서 하느라 기쁘게하는 중입니다.\n\n그러나 그 공을 내 미술에 한 날 옮겨 돈을 버는 것에 바쳐본다면, 그에 대한 내 사랑의 한 부분이 시들어갈 것입니다. 온라인에서 내가 만든 것을 공유하고 가끔 글과 함께 포함하는 것(예: 이 시의 콜라주와 같이)은 기쁘게 할 의사가 있지만, 인쇄물을 판매하거나 직접 내 미술을 돈으로 전환하는 온라인 상점을 설치할 의지는 없습니다.\n\n미술은 내 삶과 경력에서 오는 스트레스를 덜어내기 위해 하는 일입니다. 스케치를 그리고, 그림을 그리고, 만드는 일들은 저를 진정시키고 영혼을 달래줍니다. 이는 탐험과 놀이, 기쁨에 관한 것이며, 그 기쁨을 자본주의의 만족할 줄 모르는 욕망으로부터 언제나 지키겠습니다.\n\n<div class=\"content-ad\"></div>\n\nNote, 이 작품은 \"과거에 무엇을 했는지\"라는 프롬프트에 대한 답변으로 쓰여졌습니다. 이 DIY 다이어리에 실린 이 에세이를 출판해준 Amanda Laughtland에게 감사드립니다.","ogImage":{"url":"/assets/img/2024-07-01-EvolutionofaYoungArtist_0.png"},"coverImage":"/assets/img/2024-07-01-EvolutionofaYoungArtist_0.png","tag":["Tech"],"readingTime":4},{"title":"IoT 응용을 위한 Arduino와 Django 통합 방법 기술 격차 해소하기","description":"","date":"2024-07-01 17:42","slug":"2024-07-01-BridgingtheGapIntegratingArduinowithDjangoforIoTApplications","content":"\n\n<img src=\"/assets/img/2024-07-01-BridgingtheGapIntegratingArduinowithDjangoforIoTApplications_0.png\" />\n\n# 소개\n\n사물 인터넷(IoT)은 물리적 세계와 상호 작용하는 방식을 혁신하고, 일상적인 물건들이 인터넷을 통해 연결되고 통신할 수 있도록 합니다. 인기 있는 마이크로컨트롤러 플랫폼인 아두이노(Arduino)을 강력한 파이썬 웹 프레임워크인 장고(Django)와 결합하면 IoT 프로젝트에 흥미로운 가능성이 열립니다. 이 블로그 글은 아두이노를 장고와 통합하는 과정을 안내해줄 것이며, 웹 인터페이스를 통해 아두이노 프로젝트를 제어하고 모니터링할 수 있게 해줍니다.\n\n# 왜 아두이노와 장고를 결합해야 하는가?\n\n<div class=\"content-ad\"></div>\n\n- 원격 제어 및 모니터링: 웹 브라우저를 사용하여 세계 어디에서나 Arduino 프로젝트를 제어하세요.\n- 데이터 기록 및 시각화: Django를 이용한 웹 앱에서 Arduino가 수집한 센서 데이터를 저장하고 시각화하세요.\n- 향상된 상호작용: 프로젝트를 더 사용자 친화적으로 만들기 위해 상호작용 웹 인터페이스를 생성하세요.\n\n# 시작하기\n\n# 사전 요구 사항\n\n- Arduino 및 Python 프로그래밍에 대한 기본 지식.\n- Arduino 보드 (예: Arduino Uno) 및 필요한 부품 (예: LED, 센서).\n- 컴퓨터에 Python 설치.\n- Django 설치 (pip install django).\n- pyserial 라이브러리 설치 (pip install pyserial).\n\n<div class=\"content-ad\"></div>\n\n# 단계 1: Arduino 설정하기\n\n먼저, 시리얼 포트에서 명령을 수신하여 LED를 제어하는 간단한 Arduino 스케치를 만들어 봅시다.\n\n## 아두이노 코드\n\n```js\nvoid setup() {\n    Serial.begin(9600);\n    pinMode(LED_BUILTIN, OUTPUT);\n}\n\nvoid loop() {\n    if (Serial.available() > 0) {\n        String command = Serial.readStringUntil('\\n');\n\n        if (command == \"lightOn\") {\n            digitalWrite(LED_BUILTIN, HIGH);\n        } else if (command == \"lightOff\") {\n            digitalWrite(LED_BUILTIN, LOW);\n        }\n\n        Serial.println(\"받은 명령: \" + command);\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n지금 이 코드를 Arduino IDE를 사용하여 Arduino 보드에 업로드해 주세요.\n\n# 단계 2: Django 프로젝트 설정\n\n다음으로, Django 프로젝트 및 응용 프로그램을 생성하여 Arduino와 통신할 수 있게 설정합니다.\n\n## Django 프로젝트 생성\n\n<div class=\"content-ad\"></div>\n\n```js\n장고-어드민 startproject arduino_control\ncd arduino_control\n장고-어드민 startapp control\n```\n\n## 장고 구성\n\narduino_control/settings.py에서 INSTALLED_APPS에 control 앱을 추가합니다.\n\n```js\nINSTALLED_APPS = [\n    ...\n    'control',\n]\n```\n\n<div class=\"content-ad\"></div>\n\n## 뷰 및 URL 만들기\n\n컨트롤러/views.py에 Arduino에 명령을 보내는 뷰를 만들어보세요.\n\n```js\nimport serial\nimport time\nfrom django.shortcuts import render\nfrom django.http import HttpResponse\nfrom django.urls import reverse\n\nSERIAL_PORT = 'COM3'  # 사용하는 시리얼 포트로 변경해주세요\nBAUD_RATE = 9600\n\ndef send_command(command):\n    try:\n        ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=1)\n        time.sleep(2)  # 시리얼 연결 초기화를 위해 잠시 기다립니다\n\n        ser.write(f\"{command}\\n\".encode('utf-8'))\n        print(f\"명령 전송: {command}\")\n\n        response = ser.readline().decode('utf-8').strip()\n        print(f\"Arduino로부터 응답: {response}\")\n\n        ser.close()\n    except PermissionError as e:\n        print(f\"PermissionError: {e}. 포트가 다른 프로그램에 의해 사용 중이 아닌지 확인해주세요.\")\n    except serial.SerialException as e:\n        print(f\"SerialException: {e}. 포트 {SERIAL_PORT} 열기에 실패했습니다.\")\n    except Exception as e:\n        print(f\"에러: {e}\")\n\ndef index(request):\n    return render(request, 'index.html')\n\ndef lighton(request):\n    send_command('lightOn')\n    button_html = f'<button class=\"btn btn-primary\" hx-get=\"{reverse(\"lightoff\")}\" hx-trigger=\"click\" hx-target=\"this\" hx-swap=\"outerHTML\">LED 끄기</button>'\n    return HttpResponse(button_html)\n\ndef lightoff(request):\n    send_command('lightOff')\n    button_html = f'<button class=\"btn btn-primary\" hx-get=\"{reverse(\"lighton\")}\" hx-trigger=\"click\" hx-target=\"this\" hx-swap=\"outerHTML\">LED 켜기</button>'\n    return HttpResponse(button_html)\n```\n\ntime.sleep(2)은 모든 설정에 대해 동일하지 않으므로, 시스템에 맞는 적절한 지연 시간을 찾아야 합니다. 설정이 올바르지 않으면 웹 앱에 영향을 줄 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\ncontrol/urls.py에서 URL을 설정하세요.\n\n```js\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.index, name='index'),\n    path('lighton/', views.lighton, name='lighton'),\n    path('lightoff/', views.lightoff, name='lightoff'),\n]\n```\n\nmain project arduino_control/urls.py에 이러한 URL을 포함하세요.\n\n```js\nfrom django.contrib import admin\nfrom django.urls import include, path\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', include('control.urls')),\n]\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 3: HTML 템플릿 생성하기\n\ncontrol/templates/index.html에 간단한 HTML 템플릿을 만드세요.\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Arduino Control</title>\n    \n    <!-- 부트스트랩 CSS -->\n    <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css\">\n    \n    <!-- HTMX -->\n    <script src=\"https://unpkg.com/htmx.org@^1.5.0/dist/htmx.js\"></script>\n    \n    <!-- jQuery -->\n    <script src=\"https://code.jquery.com/jquery-3.5.1.min.js\"></script>\n    \n    <style>\n        .center-container {\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            height: 100vh;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container center-container\">\n        <button class=\"btn btn-success\" hx-get=\"{ url 'lighton' }\" hx-trigger=\"click\" hx-tabasrget=\"this\" hx-swap=\"outerHTML\">Turn LED on</button>\n    </div>\n    <script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js\"></script>\n</body>\n</html>\n```\n\n# 단계 4: Django 서버 실행하기\n\n<div class=\"content-ad\"></div>\n\nDjango 서버를 시작하세요.\n\n```js\npython manage.py runserver\n```\n\n웹 브라우저에서 http://127.0.0.1:8000/을 방문하여 인터페이스를 확인하고 Arduino를 제어하세요.\n\n# 다른 프로젝트 아이디어:\n\n<div class=\"content-ad\"></div>\n\n- 랜덤 숫자 생성 API\n현재 혼돈 시스템을 감지하는 센서에서 읽는 값을 제공하는 API 엔드포인트를 만들어보세요.\n- 홈 자동화 시스템\n- 보안 시스템\nArduino에 연결된 모션 센서를 사용하여 기본 보안 시스템을 구축하세요. 움직임을 감지하면 알림이 Django 웹 서버로 전송되어 웹 인터페이스에 표시됩니다.\n- IoT 건강 모니터링 시스템\n실시간 데이터(생체 신호에 관한)를 의사에게 인터넷을 통해 공유하는 원격 건강 모니터링 시스템입니다.\n\n# 결론\n\nArduino와 Django를 결합하면 강력하고 상호작용이 가능한 IoT 응용 프로그램을 만들 수 있는 무궁무진한 가능성이 열립니다. 이 안내를 따라 웹 인터페이스를 설정하여 Arduino 프로젝트를 원격으로 제어하고 모니터링할 수 있습니다. 홈 자동화 시스템, 원격 센서 네트워크 또는 다른 IoT 프로젝트를 구축하든, 이 통합은 유연하고 확장 가능한 솔루션을 제공합니다. 더 많은 센서 및 구동기로 실험하고, 더 복잡한 상호작용 및 데이터 시각화를 다루기 위해 Django 응용프로그램을 확장하세요.\n\n즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-07-01-BridgingtheGapIntegratingArduinowithDjangoforIoTApplications_0.png"},"coverImage":"/assets/img/2024-07-01-BridgingtheGapIntegratingArduinowithDjangoforIoTApplications_0.png","tag":["Tech"],"readingTime":6},{"title":"No Mans Sky에서 작동하는 지식의 돌 만들기 방법","description":"","date":"2024-07-01 17:41","slug":"2024-07-01-BuildingaworkingKnowledgeStonefromNoMansSky","content":"\n\n게임 No Man’s Sky에서는 지식의 돌과 상호 작용하여 언어의 단어를 배웁니다. 이 돌은 하나의 단어를 캐릭터의 두뇌로 직접 전달하는 지식을 전달합니다. 하지만 실제 세계에서 언어를 배우는 것은 그렇게 간단하지 않습니다. 그럼에도 불구하고, 당신을 가르치는 지식의 돌을 만들어 봅시다.\n\n이것은 전자 장치 작업에 대한 완전한 자습서가 아닙니다. 이 프로젝트를 사용하거나 작업하는 동안 발생하는 모든 손상에 대해 책임지지 않습니다.\n\n작동하는 지식의 돌을 만들기 위해 다음 부품을 사용합니다:\n\n- 아두이노 나노\n- WS2812B LED 스트립\n- 모든 것을 전원 공급하기 위한 USB 케이블\n- SW-420 충격 센서\n- NFC 스티커\n- 아두이노를 내 PC에 프로그래밍하기 위해 사용하는 다른 USB 케이블\n\n<div class=\"content-ad\"></div>\n\n지식의 돌 자체를 손에 넣으려면 3D 프린터가 필요합니다. 지식의 돌 파일은 Printables와 MakerWorld에서 찾을 수 있습니다. 모든 전자 기기를 담을 상자 파일도 Printables와 MakerWorld에 있습니다. 제가 돌의 크기를 150%로, 전자 기기를 담을 상자는 원래 크기의 125%로 확대했습니다.\n\n부품을 모두 프린트하신 후에 전자 기기 조립을 시작할 수 있습니다.\n\n다음은 전자 기기를 연결하는 방법을 보여주는 도표입니다.\n\n<div class=\"content-ad\"></div>\n\n!! 중요 !!\n\n아두이노에 LED 스트립을 바로 연결하지 마십시오. 꼭 스위치를 사용하십시오. 아두이노의 전원을 켤 때마다 스위치를 끄십시오 (LED 스트립도 꺼짐). 이렇게 함으로써 USB 포트를 통해 아두이노 (그리고 LED 스트립)를 전원을 공급할 때 아두이노로부터 너무 많은 전력을 받아올리지 못하게 하여 파괴되는 것을 방지할 수 있습니다.\n\n비디오에서는 지식 돌이 두 가지 다른 소스 코드에서 작동하는 것을 보여드렸습니다. 하나는 휴대폰이 닿으면 돌이 밝아지는 것이었고, 다른 하나는 LED 스트립의 색 스펙트럼을 사용하여 돌을 모든 색상으로 밝게 했습니다.\n\n다음은 터치할 때 돌이 밝아지는 첫 번째 코드입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n#include <FastLED.h>\n\nconst int vibration_sensor_pin = 2;\nconst int led_data_pin = 13;\nconst int leds_number = 15; // 스트립이 가진 LED 수\n\nconst int brightness = 180; // 최대 밝기, 0 = 어두움, 255 = 전체 밝기\nboolean animated = false; // LED 스트립이 현재 애니메이션을 수행 중인가요?\n\nCRGB leds[leds_number];\n\nvoid setup() {\n  pinMode(vibration_sensor_pin, INPUT);\n\n  // 진동 센서가 신호를 감지할 경우 애니메이션 메서드를 실행합니다.\n  attachInterrupt(digitalPinToInterrupt(vibration_sensor_pin), animation, RISING);\n\n  FastLED.addLeds<WS2812B, led_data_pin, GRB>(leds, leds_number);\n  \n  for(int dot = 0; dot < leds_number; dot++) { \n    leds[dot] = CRGB::Black;\n  }\n  FastLED.show();\n\n  // LED 스트립이 작동하는지 확인하기 위해 RGB로 밝혀보세요.\n  // 그 후 꺼져요.\n  fill_solid(leds, leds_number, CRGB::Red);\n  FastLED.show();\n  delay(300);\n  fill_solid(leds, leds_number, CRGB::Green);\n  FastLED.show();\n  delay(300);\n  fill_solid(leds, leds_number, CRGB::Blue);\n  FastLED.show();\n  delay(300);\n  fill_solid(leds, leds_number, CRGB::Black);\n  FastLED.show();\n}\n\nvoid loop() {\n}\n\nvoid animation() {\n  // 시간 측정\n  unsigned long current_time = millis();\n  static unsigned long last_interrupt_time = current_time - 6000;\n\n  // 신호 튕김 방지\n  // 마지막 신호가 5초 이내에 발생했으면 무시합니다.\n  if(current_time - last_interrupt_time > 5000 && !animated) {\n    // LED 스트립에서 애니메이션 실행\n    animated = true;\n\n    // 1.5초 동안 점점 더 밝게\n    for(int curr_brightness = 0; curr_brightness <= brightness; curr_brightness++) {\n      fill_solid(leds, leds_number, CRGB(0, 180, 255));\n      FastLED.setBrightness(curr_brightness);\n      FastLED.show();\n      delay(1500 / brightness);\n    }\n\n    // 10초간 유지\n    delay(10000);\n\n    // 1.5초 동안 점점 어둡게\n    for(int curr_brightness = brightness; curr_brightness >= 0; curr_brightness--) {\n      fill_solid(leds, leds_number, CRGB(0, 180, 255));\n      FastLED.setBrightness(curr_brightness);\n      FastLED.show();\n      delay(1500 / brightness);\n    }\n\n    animated = false;\n  }\n\n  // 다음 바운스를 감지하기 위해 시간 업데이트\n  last_interrupt_time = current_time;\n}\n```\n\n지식의 돌이 모든 색상을 순환하는 코드는 여기에서 확인할 수 있습니다.\n\n```js\n#include <FastLED.h>\n\nconst int led_data_pin = 13;\nconst int leds_number = 15; // 스트립이 가진 LED 수\n\nconst int brightness = 180; // 최대 밝기, 0 = 어두움, 255 = 전체 밝기\n\nCRGB leds[leds_number];\n\nvoid setup() {\n  FastLED.addLeds<WS2812B, led_data_pin>(leds, leds_number);\n  \n  // LED 스트립 초기화\n  for(int dot = 0; dot < leds_number; dot++) { \n    leds[dot] = CRGB::Black;\n  }\n  FastLED.show();\n}\n\nvoid loop() {\n  static uint8_t hue = 0; // 색을 나타내는 hue\n\n  // 현재 색상 표시하고 hue 값 증가\n  FastLED.showColor(CHSV(hue++, 255, brightness));\n\n  // 다음 색상 표시 전에 20밀리초 대기\n  delay(20);\n}\n```\n\nPC를 아두이노 나노에 USB 포트를 통해 연결할 때 LED 스트립을 연결 해제하는 것이 중요합니다. 이전에 언급한 대로 LED는 아두이노 일부를 파괴할 정도의 전원을 끌어낼 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이제 충격 센서를 흔들어 빛 효과를 활성화한 후, 5초 이상 휴식을 주도록 설정했어요. 충격 센서가 너무 민감하거나 반대로 민감하지 않다고 생각되면 시계방향 또는 반시계방향으로 나사를 돌려 민감도를 조절할 수 있어요.\n\n스마트폰으로 돌을 사용해 웹사이트를 열 수 있도록 하려면 NFC 스티커에 웹사이트 URL을 써야 해요. 스마트폰과 NFC Tools 앱(구글 플레이 / 앱 스토어)을 사용해 URL https://nms-words.kgabriel.dev를 데이터로 추가한 후, 스마트폰에 스티커를 대고 앱에서 \"쓰기\" 탭으로 전환해 이를 스티커에 쓰면 돼요.\n\n이제 모두 함께 모아놓기 전 마지막 단계로 NFC 스티커를 지식의 돌의 내부 상단에 붙이는 거예요.\n\n소띠하고 프로그래밍을 마치면, 조립한 상자 안에 전자 부품을 조심스럽게 넣으면 돼요. LED 스트립은 바깥쪽에 두고 상자 측면의 평평한 표면에 붙일 수 있어요. LED 스트립을 더 고정하기 위해 저는 집게로 고정했어요.\n\n<div class=\"content-ad\"></div>\n\n🎉이제 작동하는 지식의 돌이 생겼어요!🎉\n\n튜토리얼을 즐기셨길 바랍니다! 만약 아직 보지 않았다면, 이 지식의 돌을 보여준 영상도 확인해보는 것을 잊지 마세요. 정말로 중요한 일이에요.","ogImage":{"url":"/assets/img/2024-07-01-BuildingaworkingKnowledgeStonefromNoMansSky_0.png"},"coverImage":"/assets/img/2024-07-01-BuildingaworkingKnowledgeStonefromNoMansSky_0.png","tag":["Tech"],"readingTime":5},{"title":"다가오는 AI 물결 모든 산업을 혁신하고 기업주와 노동자를 뒤흔들 2024 최신 AI 동향","description":"","date":"2024-06-30 23:42","slug":"2024-06-30-TheUpcomingAIWaveHowItsGoingtoRevolutionizeEveryIndustryandShakeUpBusinessOwnersandLaborers","content":"\n\n여러분, 모자를 꼭 놓치지 마세요! AI 혁명이 올 것이고, 모든 것을 바꿀 것입니다. 의료부터 금융, 제조업부터 소매업까지, AI는 더 이상 과학 소설이 아닌 새로운 현실입니다. 파도를 탈 준비가 되셨나요?\n\n# 비즈니스 소유자를 위한 AI 변화: 게임 체인저\n\n비즈니스 소유자들에게 AI 파도는 황금을 찾은 것과 같습니다. 몇 초만에 데이터 산으로 내려다보고 시장 트렌드를 불길한 정확도로 예측하며, 시간을 많이 소비하는 지루한 업무들을 자동화하는 힘을 가지는 것을 상상해보세요. AI는 이제 더 이상 테크 기업만의 것이 아니라 모두를 위한 것입니다.\n\n효율성 해제와 혁신 유발\n\n<div class=\"content-ad\"></div>\n\nAI는 효율성과 혁신의 완전히 새로운 수준으로 안내해줄 패스입니다. AI를 채용하는 것은 운영을 간소화하고 비용을 절감하며 고객들을 감동시키는 것을 의미합니다. AI 기반의 통찰력을 통해 보다 똑똑한 결정을 내릴 수 있고, 제품을 맞춤화하며 경쟁에서 앞서갈 수 있습니다.\n\n고객 지원에서 AI에 대해 생각해보세요. AI-기반 음성 어시스턴트는 24/7 쿼리를 처리하여 일관된, 정확한 답변을 제공할 수 있습니다. 이는 단지 고객들을 행복하게 하는 것 뿐만 아니라, 인간 에이전트들이 더 복잡한 문제를 다룰 수 있도록 해줍니다. 결과는 무엇인가요? 생산성과 고객 애정이 크게 향상됩니다.\n\n경쟁 우위 확보\n\n오늘날 빠르게 변화하는 세상에서 경쟁력을 유지하는 것은 순발력과 혁신력을 갖추는 것을 의미합니다. AI는 이 두 가지를 할 수 있는 도구를 제공합니다. 전략을 안내해주는 예측 분석부터 공급망을 최적화하는 머신 러닝 알고리즘에 이르기까지 가능성은 무한합니다. AI에 집중하는 사업주들은 자신의 산업을 선도하며, 성장을 주도하고 경쟁자들을 뒤로 남길 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 인공지능 파도의 어둠 면: 인간 노동에 미치는 영향\n\n그러나 이것은 또 다른 면이 있습니다. 인공지능이 비즈니스에 많은 혜택을 가져다 주는 반면, 인력에는 긴 그림자가 드리우고 있습니다. 가장 큰 질문은: 노동자들은 어떻게 되는 것일까요?\n\n일자리 위기\n\n여기서 상황이 무서워집니다. 인공지능이 더 똑똑해지면서 많은 일자리가 위험에 처하게 됩니다. 제조업과 물류와 같이 수동 노동에 많이 의존하는 산업들은 이미 열을 맞고 있습니다. 로봇과 자동화 시스템이 반복적인 작업을 대신하고 있기 때문에 인간에게 일자리가 더 이상 제공되지 않게 되는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n기는 경제의 부상\n\n많은 노동자들에게 인공지능의 물결은 불안한 미래를 의미합니다. 정규직이 단기 계약직과 프리랜서 일자리로 교체될 수도 있습니다. 확실히, 기는 경제는 유연성을 제공하지만, 일자리 불안과 혜택이 없다는 것을 의미합니다. 노동자들은 게임에 머무르기 위해 새로운 기술을 배워야 할 것입니다.\n\n기술 격차\n\n우리가 인공지능 왕국으로 이동함에 따라, 새로운 기술의 필요성은 중대합니다. 적응하지 않는 노동자들은 뒤처지기 쉽습니다. 학교와 기업은 인공지능 시대를 위해 사람들을 준비하는 교육 프로그램을 제공하기 위해 협력해야 합니다. 데이터 분석부터 머신 러닝까지, 새로운 기술이 게임의 이름입니다.\n\n<div class=\"content-ad\"></div>\n\n![Image](/assets/img/2024-06-30-TheUpcomingAIWaveHowItsGoingtoRevolutionizeEveryIndustryandShakeUpBusinessOwnersandLaborers_0.png)\n\n# 변화를 받아들이기\n\n다가오는 AI 파도는 도전이자 기회이다. 사업주들은 지금 AI의 선술교를 타야하며, 증가된 효율성과 경쟁 우위의 혜택을 누려야 한다. 동시에 미래에 대비할 수 있도록 노동자들을 돕는 역할을 해야 한다.\n\n행동을 취하라\n\n<div class=\"content-ad\"></div>\n\n인공 지능 혁명은 멈출 수 없어요. 이를 포용하고, 준비하고, 여러분의 업계에 미치는 영향을 조절해 보세요. 기업 주인으로서, 이제는 인공 지능 기술과 인력 교육에 투자할 때입니다. 근로자들에게는 평생 학습과 적응력이 중요합니다. 함께하면 인공 지능의 파도를 탈 수 있고, 이를 통해 더 강해져 나올 수 있어요.\n\n이제 뛰어들 준비가 되셨나요?","ogImage":{"url":"/assets/img/2024-06-30-TheUpcomingAIWaveHowItsGoingtoRevolutionizeEveryIndustryandShakeUpBusinessOwnersandLaborers_0.png"},"coverImage":"/assets/img/2024-06-30-TheUpcomingAIWaveHowItsGoingtoRevolutionizeEveryIndustryandShakeUpBusinessOwnersandLaborers_0.png","tag":["Tech"],"readingTime":3},{"title":"OpenLLM으로 언어 학습 모델LLM을 위한 Raspberry Pi 5의 강력한 활용 방법","description":"","date":"2024-06-30 23:41","slug":"2024-06-30-UnleashingthePowerofRaspberryPi5forLanguageLearningModelsLLMswithOpenLLM","content":"\n\n라즈베리 파이 5가 최근에 출시되어 테크 열정가와 전문가들에게 새로운 기회의 문을 열었습니다. 이 강력한 마이크로 컴퓨터의 가장 흥미로운 혁신적인 사용 중 하나는 언어 학습 모델 (LLM) 분야에서 입니다. 이 글에서는 라즈베리 파이 5를 활용하여 OpenLLM을 실행하고 실험하여, 인공 지능 및 머신 러닝 프로젝트를 위한 강력한 소형 장비로 변환하는 방법을 살펴보겠습니다.\n\n# 라즈베리 파이 5를 특별하게 만드는 요소는 무엇인가요?\n\n라즈베리 파이 5는 이전 제품들보다 상당히 업그레이드되어, 다양한 고급 응용 프로그램에 적합한 인상적인 사양을 자랑합니다:\n\n- Quad-Core ARM Cortex-A76 프로세서, 2.4 GHz: 복잡한 연산을 처리하기에 이상적인 상당한 성능 향상을 제공합니다.\n- 최대 8GB의 RAM: 기계 학습 모델을 비롯한 메모리 집약적인 응용 프로그램을 실행하기 위한 풍부한 메모리를 제공합니다.\n- 향상된 연결성: USB 3.0 포트, 전원을 위한 USB-C, 그리고 기가비트 이더넷을 갖추어 빠른 데이터 전송과 안정적인 네트워크 연결성을 보장합니다.\n- PCIe 슬롯: 더 많은 확장성을 제공하여, 더 빠른 데이터 접근을 위해 고속 SSD를 추가하는 등 다양한 확장이 가능합니다.\n\n<div class=\"content-ad\"></div>\n\n# 언어 학습 모델 (LLM)이란 무엇인가요?\n\n언어 학습 모델 (LLM)은 인공 지능의 하위 집합으로, 인간 언어를 이해하고 생성하며 조작하는 데 초점을 맞춥니다. 이러한 모델들은 딥 러닝 알고리즘을 기반으로 하며, 번역, 요약, 감정 분석 등 다양한 작업을 수행할 수 있습니다. 잘 알려진 LLM에는 GPT-3, BERT, T5 등이 있습니다. OpenLLM은 이러한 모델들의 오픈 소스 구현으로, 개발자들이 LLM을 탐색하고 활용할 수 있는 접근 가능한 도구를 제공합니다.\n\n# LLM에 라즈베리 파이 5를 사용하는 이유는 무엇인가요?\n\nLLM을 실행하기 위해 라즈베리 파이 5를 사용하는 것은 야심찬 일처럼 보일 수 있지만, 이러한 설정을 고려할만한 몇 가지 확고한 이유가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 가격: 일반적인 서버나 고성능 데스크탑에 비해 라즈베리 파이 5는 LLM 실험에 비용 효율적인 솔루션입니다.\n- 휴대성: 소형 사이즈로 이동이 쉽고 다양한 환경에서 설정하기 쉽습니다. 이동이나 원격 애플리케이션에 완벽합니다.\n- 에너지 효율성: 전통적인 컴퓨터보다 훨씬 적은 전력을 소비하여 연속적인 운영에 친환경적인 선택입니다.\n- 커뮤니티와 지원: 라즈베리 파이는 다양한 개발자와 열렬한 팬들로 이루어진 강력한 커뮤니티를 가지고 있어 다양한 자료와 지원을 제공합니다.\n\n# OpenLLM을 위한 라즈베리 파이 5 설정\n\n## 단계 1: 라즈베리 파이 5 준비하기\n\n먼저 라즈베리 파이 5를 설정하세요. 최소 32GB의 microSD 카드, 전원 공급 장치, 키보드, 마우스, 모니터와 같은 필수 주변 기기가 필요합니다. 공식 웹사이트에서 라즈베리 파이 OS를 다운로드하고 Balena Etcher를 사용하여 이미지를 microSD 카드에 플래시하세요.\n\n<div class=\"content-ad\"></div>\n\n- Raspberry Pi OS 다운로드: Raspberry Pi OS\n- OS 플래시: Balena Etcher를 사용하여 OS 이미지를 microSD 카드에 작성합니다.\n\n## 단계 2: 필요한 소프트웨어 설치\n\n라즈베리 파이 5가 구동 중이면 머신 러닝을 위한 필수 소프트웨어 패키지를 설치하세요. 터미널을 열고 시스템을 업데이트하세요:\n\n```js\nsudo apt update && sudo apt upgrade\n```\n\n<div class=\"content-ad\"></div>\n\n다음으로 Python과 pip을 설치해 보세요:\n\n```js\nsudo apt install python3 python3-pip\n```\n\n## 단계 3: OpenLLM 및 종속성 설치\n\nOpenLLM은 LLM을 실행하고 실험할 수 있는 오픈 소스 라이브러리입니다. OpenLLM 및 관련 종속성을 설치하려면 다음 명령어를 사용하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\npip3 install openllm\n```\n\n## Step 4: 성능을 최적화하세요\n\n라즈베리 파이 5가 고성능 작업을 수행할 때 최상으로 작동하도록 보장하려면 다음 최적화를 고려해보세요:\n\n- 스왑 메모리 활성화: 이를 통해 메모리 사용량을 효과적으로 관리할 수 있습니다.\n- 오버클로킹: 가능하다면 오버클로킹은 추가 성능 향상을 제공할 수 있습니다.\n- 외부 저장소: PCIe 슬롯을 통해 외부 SSD를 사용하면 데이터 액세스 속도를 크게 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 단계 5: 라즈베리 파이 5에서 OpenLLM을 사용하여 LLM 실행하기\n\n설치가 완료되었으므로 이제 OpenLLM을 사용하여 사전 훈련된 LLM을 실행할 수 있습니다. 텍스트 생성을 위해 간단한 스크립트가 여기 있습니다:\n\n```js\nfrom openllm import load_model, generate_text\n# 사전 훈련된 모델 로드\nmodel = load_model('gpt4')\n# 텍스트 생성\ntext = generate_text(model, \"한때\", max_length=50)\nprint(text)\n```\n\n## 단계 6: 실험하고 반복하기\n\n<div class=\"content-ad\"></div>\n\n라즈베리 파이 5에서 LLMs를 실행하는 것은 AI와 머신 러닝을 실험할 수 있는 좋은 방법입니다. 여러분은 매개변수를 조정하고 모델을 세밀하게 조정하거나 강력한 도구를 활용하여 나만의 애플리케이션을 개발할 수 있습니다.\n\n# OpenLLM을 이용한 라즈베리 파이 5의 장점\n\n## 비용 효율적인 학습 및 개발\n\n라즈베리 파이 5의 가격이 저렴하여 고가의 하드웨어가 필요하지 않고도 LLMs를 배우고 실험할 수 있는 훌륭한 플랫폼으로 만들어줍니다.\n\n<div class=\"content-ad\"></div>\n\n## 엣지 AI 활성화하기\n\nRaspberry Pi 5를 사용하여 LLMs를 지원하는 것은 중앙 서버가 아닌 로컬 기기에서 처리가 발생하는 엣지 AI의 성장 트렌드를 지원합니다. 이는 지연 시간을 줄이고 프라이버시를 강화합니다.\n\n## 혁신 유도하기\n\nRaspberry Pi 5의 다재다능함과 접근성은 혁신과 창의성을 촉진합니다. 개발자와 취미 체험가들은 교육, 의료 및 스마트 홈 기술과 같은 다양한 분야에서 LLMs를 활용한 새로운 응용 프로그램과 솔루션을 탐구할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-30-UnleashingthePowerofRaspberryPi5forLanguageLearningModelsLLMswithOpenLLM_0.png"},"coverImage":"/assets/img/2024-06-30-UnleashingthePowerofRaspberryPi5forLanguageLearningModelsLLMswithOpenLLM_0.png","tag":["Tech"],"readingTime":4},{"title":"키네시스 어드밴티지 2 키보드 소음 줄이는 방법","description":"","date":"2024-06-30 23:40","slug":"2024-06-30-SilencingKinesisAdvantage2Keyboard","content":"\n\n![키네시스 어드밴티지 2 키보드](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_0.png)\n\n키네시스 어드밴티지 2 키보드는 소프트웨어 개발자를 위해 만들어진 것이 아니에요, 특히 C++, 자바, 자바스크립트 그리고 일부 파이썬을 자주 사용하는 사람들에게는 더 그렇죠.\n\n괄호와 중괄호가 이상한 위치에 있어서 손가락을 약한 각도로 사용해야 하고, 레이아웃 때문에 일부 키가 원래 위치에 있지 않아서 약지로 눌러야 해요 - 제가 모르는 것일수도 있지만, 제 약지는 제일 강한 손가락은 아니거든요. 그래서 필요한 대부분의 문자를 약지로 누를 수 있어서 개발자들의 삶이 힘들어져요. 물론, 저는 열 손가락법을 얘기하고 있어요. 그렇지 않으면, 당신이 원하는 손가락으로 모든 키에 접근할 수 있어요. 키를 원하는대로 매핑할 수 있고 - 예를 들어, 저는 대괄호를 페이지 업과 페이지 다운 키로 재매핑해서 제 삶을 조금 더 쉽게 만들었어요.\n\n개발자들을 위한 것은 아니지만, 저는 사용해본 적 있는 키보드 중에서 가장 편안한 키보드에요. 특히 이 글을 쓰는 것처럼 작성만 하고 있다면, 손가락 열 기술을 알고 있다면 편안하고 빠른 키보드로 시장에 없어요.\n\n<div class=\"content-ad\"></div>\n\n상당한 단점을 가지고 있는 쓰기에 좋아요: 너무 시끄러워요! 이전에 저는 이렇게 시끄러운 키보드를 본 적이 없습니다. (저도 Keycron 메카닉 키보드가 있어요). 브라운 \"조용한\" 스위치를 사용하고 있지만, \"조용한\"은 키네시스 세계에서는 전체적인 소음이 아닌 스위치의 조용함을 의미합니다. (저는 키를 누르는 힘이 센 편이 아니에요.) 키네시스를 사용하기 시작했을 때, 동료들이 먼저 이야기해 주었어요. 그래서 집에서 사용하게 되었어요. 긴 글을 쓸 때면 소음 차단 헤드폰 없이는 그 소음을 견딜 수가 없어요. 정말로 제게는 악몽이에요.\n\n![Kinesis Advantage 2 Keyboard](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_1.png)\n\n키들에 O 실리콘 링 감쇠기를 구입했는데, 효과는 거의 없고 큰 획득이 없었어요. 이렇게 구입하지 않아도 돼요. 최근에 다음 기사를 발견했어요: https://yboulkaid.com/2022/03/15/kinesis.html. 이 비용이 싸지 않고 이 재료들로 다른 키보드를 살 수도 있어요. 그래서 잠시 중단했어요.\n\n매일 키보드의 시끄러움에 대한 짜증이 쌓여가는데, 아마도 제 삶의 변화 때문이겠죠. 지금은 아들이 있는데 하루 종일 조금 시끄러워요. 그가 자고 있는 동안 창작을 하며 조용한 시간을 가지고 싶은데, 다른 아이(Kinesis Advantage 2)이 울부짖기 시작하면 어쩔 수 없어요. 그래서 한 번 시도해보기로 결심했어요.\n\n<div class=\"content-ad\"></div>\n\n내 구매는 약 75 유로 정도 걸렸어요: 2 종류의 QMX 소거기(일반 키와 썸 클러스터에는 서로 다른 종류가 필요하기 때문)와 Dynamat Extreme을 샀습니다. 아래는 품목에 관한 더 자세한 내용입니다:\n\n- QMX-Clips PCB 마운트(검정 윗면, 썸 클러스터용): [링크](https://uniqey.net/en/accessories/17/qmx-clips-pcb-mount-110-pcs)\n- QMX-Clips Plate 마운트(흰색 윗면; 일반 키용): [링크](https://uniqey.net/en/accessories/18/qmx-clips-plate-mount-110-pcs.?c=11)\n- Dynamat Xtreme — 미국에서 제작된 스피커 키트 버전을 구매할 수 있었는데, EU에서는 모든 버전을 찾을 수 없었습니다. Xtreme 버전이면 어떤 버전이든 구매할 수 있어요.\n\nQMX 클립을 설치하는 것은 챌린지였는데, Advantage 2s와 같은 키보드 레이아웃용으로 만들지 않아서 어려웠어요. 어떤 키는 다른 것보다 높고 각도가 다르기 때문입니다. 파란 도구로 클립을 설치할 수 없었고, 그들이 제공한 평평한 드라이버로 설치했어요. 스크류드라이버로 연결 지점을 누르면 클릭 소리가 들립니다. 때때로 클릭 소리가 안 들리면 방향을 바꿔야 해요 — 만약 왼쪽 부분을 먼저 클릭해도 오른쪽 부분이 클릭하지 않는다면, 오른쪽을 먼저 클릭한 후 왼쪽을 클릭합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_3.png)\n![Image 2](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_4.png)\n![Image 3](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_5.png)\n![Image 4](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_6.png)\n\n\n<div class=\"content-ad\"></div>\n\n![Silencing Kinesis Advantage2 Keyboard](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_7.png)\n\n또 하나의 도전 과제는 Dynamat Xtreme를 보드에 직접 붙이는 것이었습니다. 바닥은 쉬웠지만 실제 키 쪽은 그리드가 많아 맞춤 컷팅을 해야 했기 때문에 어려웠어요. 또 하나의 포인트는 Dynamat Xtreme을 두께 그대로 두면 키보드를 다시 닫을 수 없다는 것이었습니다. 일반적으로 뒤로 누르는 롤러 도구가 있지만, 나는 다시 사용할 일이 없는 물건에 추가 비용을 지불하고 싶지 않았어요. 그래서 나는 나만의 나만의 나만의 자전구로 눌렀어요(그것은 내 아들이 장난감의 일부에요 :)). 이런 기회가 없다면 립스틱 케이스, 작은 머그잔 또는 비슷한 물건을 사용할 수 있지만, 그 위에 눌러주고 Dynamat Xtreme이 두께를 잃도록 하는 것이 중요해요. 이 과정은 키보드를 닫는 것뿐만 아니라 소리 차단에도 중요해요.\n\n![Silencing Kinesis Advantage2 Keyboard](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_8.png)\n\n드디어 완료했어요. 다음 동영상은 처음 시도한 것이에요. 특히 Dynamat Xtreme 쪽에서 몇 일 뒤에도 더 조용해지고 있어요.\n\n<div class=\"content-ad\"></div>\n\n프로세스의 안 좋은 측면은 많은 잔여물이 생긴다는 점이에요. 기본적으로, 구매한 소재로 2개의 Kinesis Advantage 2를 신청할 수 있지만, 공유할 다른 친구가 없어서요.\n\n![이미지](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_9.png)\n\nQMX-클립이 장기적으로 어떻게 반응할지 확신은 못하지만, 교체용 여분 부품들은 충분히 갖고 있어요.\n\n또 다른 단점은 특히 엄지 클러스터에서, 일부 키들이 각도와 추가 부품 때문에 너무 세게 누르면 막혀버릴 수 있다는 점이에요. CTRL, Page Up, Page Down, Alt Option, Home, 그리고 End 키 같은 거 말이죠. 나는 너무 세게 누르지 않았는데도, 적용하기 전에보다 자연스럽지 못하다는 느낌이 들어요.\n\n<div class=\"content-ad\"></div>\n\n결과는... 나는 이 어플리케이션에 대해 후회하지 않아. 나는 키 소리에 만족하며 사용성도 좋다고 생각해 (지금은 놀랍도록 조용해졌어; 물론, 셔클렛 타입처럼 아니야). 나에게 유일한 후회는 이전에 이것을 적용하지 않았다는 것이야. 물론, 이 어플리케이션은 모두에게 필요한 것은 아닐 수 있어. 키보드 소리를 좋아하고 혼자 살거나 혼자 일 하는 경우, 추가 비용을 지출할 필요가 없어. 어플리케이션을 한 후에 키보드를 판매하는 것이 불가능할 수도 있어, 왜냐하면 새로운 소유자가 그런 어플리케이션을 원하지 않을 수 있기 때문이지만, 나의 경우에는 아니야. 나는 내 키보드를 판매하는 것을 고려하지 않아.\n\n나는 여러분의 지원으로 더 많이 쓰는 인간 작가야! 돈을 내지 않아도 돼. 내 이야기를 좋아한다면 👏 열어 줘, 말하고 싶은 것이 있다면 ✍️ 코멘트를 달아 줘. 나를 Medium, LinkedIn, Instagram, X에서 팔로우할 수 있어.","ogImage":{"url":"/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_0.png"},"coverImage":"/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_0.png","tag":["Tech"],"readingTime":5},{"title":"임베디드 AI  머신 러닝을 사용하여 배터리 충전 상태 확인 방법","description":"","date":"2024-06-30 23:36","slug":"2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning","content":"\n\n## 배터리 충전 상태(SOC)는 배터리의 잔여 전하를 총 용량의 백분율로 표시합니다. 이 정보는 내장 장치의 에너지 관리에 매우 중요합니다. SOC를 정확하게 추정하는 것은 리튬이온 배터리의 복잡한 행동에 영향을 받아 어려운 작업입니다. 이는 온도, 배터리 건강 상태, 그리고 SOC 자체와 같은 요소들에 의해 영향을 받기 때문입니다. SOC를 추정하기 위한 전통적인 방법인 전기화학 모델은 정확한 매개변수와 배터리의 조성 및 물리적 특성에 대한 심층적인 이해를 요구합니다. 반면, 머신 러닝 모델은 데이터 기반 접근 방식을 제공하여 배터리의 행동에 대해 덜 자세한 지식만으로도 SOC 추정을 단순화시키므로 내장 시스템에 구현하기에 적합합니다.\n\n![이미지](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_0.png)\n\n## 머신 러닝 과정\n\n내장형 AI 시리즈의 제1부에서, ML을 사용하여 값들을 예측하는 과정을 설명했습니다 (그림 1).\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_1.png)\n\nPart 2에서 설명한 것처럼, 배터리 방전 곡선은 대부분의 사용 가능 범위에 걸쳐 거의 선형입니다. 그러므로 우리는 Part 1에서 설명한 선형 회귀 모델을 사용할 수 있을 것입니다. 그러나 출력물은 룩업 테이블 및 보간 방법과 매우 유사할 것입니다. 더 정확하고 유연한 예측을 제공해야 할 다른 접근 방식이 있습니다.\n\n이러한 옵션을 탐색하기 위해 ML 프로세스 플로우차트의 단계를 따를 것입니다.\n\n## 단계 1 — 문제 정의\n\n\n<div class=\"content-ad\"></div>\n\n배터리의 SOC를 정확하게 예측하는 ML 모델을 개발하는 것이 목표입니다. 이 모델은 전압을 기반으로 배터리의 SOC를 예측하는 데 사용되며 전류, 온도, 그리고 시간과 같은 관련 특징도 함께 고려됩니다 (Figure 2). 모델은 다양한 작동 조건과 배터리 상태에 걸쳐 잘 일반화되어야 하며, 이는 실시간 응용 프로그램에서 신뢰할 수 있는 SOC 추정을 보장합니다.\n\nInputs and Features\n\n- Voltage (V): 배터리의 순간 전압을 나타내는 주요 입력 특징입니다.\n- Current (I): 배터리에 공급되거나 공급되는 전류로, 전압 값에 영향을 줄 수 있습니다.\n- Temperature (T): 주변 온도 또는 배터리의 온도로, 온도 변화가 배터리 성능에 영향을 줍니다.\n- Time (t): 전압이 측정된 시간으로, 배터리의 방전 또는 충전 주기를 이해하는 데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n- 전하 상태 (SOC): 배터리의 예상 SOC로서 총 용량의 백분율로 표시됩니다.\n\n![image](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_2.png)\n\n## 단계 2 — 훈련 데이터 수집 및 정리\n\n이 단계에서 가장 많은 작업을 수행하게 될 것입니다. 모델을 훈련시킬 데이터가 더 좋을수록 예측이 더 좋아질 것입니다. 우리는 맥마스터 대학교에서 발행한 LG 18650HG2 리튬이온 배터리에 대한 Digital Commons 데이터를 사용할 것입니다. 아래의 Python 스크립트를 사용하여 이 데이터셋을 다운로드할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport os\nimport requests\nimport zipfile\nimport numpy as np\n\n# 다운로드 할 파일의 URL\nurl = \"https://data.mendeley.com/public-files/datasets/cp3473x7xv/files/ad7ac5c9-2b9e-458a-a91f-6f3da449bdfb/file_downloaded\"\n\n# 추출된 ZIP 파일이 들어 있는 출력 폴더\noutput_folder = os.path.expanduser(\"~/Documents/GitHub/Embedded-AI/data/LGHG2@n10C_to_25degC\")\nos.makedirs(output_folder, exist_ok=True)\n\n# 데이터 세트 다운로드 및 추출\ntrain_folder = os.path.join(output_folder, \"Train\")\ntest_folder = os.path.join(output_folder, \"Test\")\nif not os.path.exists(train_folder) or not os.path.exists(test_folder):\n    print(\"LGHG2@n10C_to_25degC.zip (56 MB) 다운로드 중... \")\n    download_folder = os.path.dirname(output_folder)\n    filename = os.path.join(download_folder, \"LGHG2@n10C_to_25degC.zip\")\n    response = requests.get(url)\n    with open(filename, 'wb') as file:\n        file.write(response.content)\n    with zipfile.ZipFile(filename, 'r') as zip_ref:\n        zip_ref.extractall(output_folder)\n```\n\n이 스크립트에서 output_folder를 수정하여 데이터를 저장할 위치를 지정하십시오. 이 데이터를 사용하기 전에 데이터가 어떻게 구성되어 있는지 이해해야 합니다. Figure 3는 추출된 데이터 세트의 내용을 보여줍니다.\n\n<img src=\"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_3.png\" />\n\n각 파일에는 다섯 가지 예측 변수(전압, 전류, 온도, 평균 전압 및 평균 전류)로 이루어진 시계열 X와 하나의 대상 SOC로 이루어진 시계열 Y가 포함되어 있습니다. 서로 다른 환경 온도에서 수집된 데이터를 나타내는 하나의 훈련 파일과 네 개의 테스트 파일이 있습니다. 유일한 문제는 데이터가 MATLAB 형식(.mat)으로 저장되어 있다는 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n.mat 파일은 MATLAB에서 변수를 저장하는 데 사용되는 이진 데이터 파일입니다. 배열, 행렬 및 기타 데이터 유형을 저장할 수 있습니다. 이진 파일이기 때문에 텍스트 편집기에서는 읽을 수 없지만, Python의 scipy.io 모듈을 사용하여 이러한 파일을 읽고 쓸 수 있습니다.\n\n```python\nimport os\nimport scipy.io\nimport numpy as np\n\n# .mat 파일의 처음 10줄을 읽어 출력\ndef read_and_print_mat_files(folder):\n    for filename in os.listdir(folder):\n        if filename.endswith(\".mat\"):\n            filepath = os.path.join(folder, filename)\n            mat_data = scipy.io.loadmat(filepath)\n            print(f\"{filename} 내용:\")\n            for key in mat_data:\n                if not key.startswith(\"__\"):\n                    data = mat_data[key]\n                    if isinstance(data, np.ndarray) and data.ndim > 1:  \n                        print(f\"{key}:\")\n                        print(data[:10])  \n                    else:\n                        print(f\"{key}: {data}\")\n            print(\"\\n\")\n\n# 폴더 경로\ntrain_folder = os.path.expanduser(\"~/Documents/GitHub/Embedded-AI/data/LGHG2@n10C_to_25degC/Train\")\ntest_folder = os.path.expanduser(\"~/Documents/GitHub/Embedded-AI/data/LGHG2@n10C_to_25degC/Test\")\n\n# Train 및 Test 파일의 내용 읽고 출력\nprint(\"훈련 데이터 파일:\")\nread_and_print_mat_files(train_folder)\nprint(\"\\n테스트 데이터 파일:\")\nread_and_print_mat_files(test_folder)\n```\n\n훈련 데이터의 처음 다섯 행의 내용은 아래와 같이 표시됩니다.\n\n```python\nTRAIN_LGHG2@n10degC_to_25degC_Norm_5Inputs.mat 내용:\nX:\n[[0.38514793 0.38515183 0.38515573 ... 0.47884278 0.4789612  0.4789612 ]\n [0.75102009 0.75102009 0.75102009 ... 0.75102009 0.75102009 0.75102009]\n [0.30310108 0.30459129 0.3060815  ... 0.00847709 0.00847709 0.00847709]\n [0.38514793 0.38514988 0.38515183 ... 0.45983939 0.45997861 0.46011672]\n [0.75102009 0.75102009 0.75102009 ... 0.75102009 0.75102009 0.75102009]]\nY:\n[[0.20641667 0.20641667 0.20641667 ... 0.28324333 0.28324333 0.28324333]]\n```\n\n<div class=\"content-ad\"></div>\n\nX는 각 행이 다음 다섯 개의 예측변수 중 하나에 해당하는 2D 배열입니다:\n\n- 전압\n- 전류\n- 온도\n- 평균 전압\n- 평균 전류\n\n각 열은 Series에서 다른 시간점을 나타내며, 측정은 1초마다 이루어졌습니다. 예를 들어, 첫 번째 행은 전압: [0.38514793, 0.38515183, 0.38515573, …, 0.47884278, 0.4789612, 0.4789612]이고, 두 번째 행은 전류: [0.75102009, 0.75102009, 0.75102009, …, 0.75102009, 0.75102009, 0.75102009]이며, 나머지 예측변수에 대한 내용도 같은 방식입니다.\n\nY도 하나의 행으로 이루어진 2D 배열이지만, SOC가 단일 대상 변수임을 나타냅니다. 각 열은 해당 시간점에서의 SOC를 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n이제 파일 내용을 이해했으므로 훈련 및 테스트를 위해 데이터 저장소를 로드할 수 있습니다.\n\n```js\ndef read_mat_files(folder):\n    data = []\n    for filename in os.listdir(folder):\n        if filename.endswith(\".mat\"):\n            filepath = os.path.join(folder, filename)\n            mat_data = scipy.io.loadmat(filepath)\n            data.append(mat_data)\n    return data\n\n# 훈련 데이터와 테스트 데이터를 위한 파일 데이터 저장소 생성\nfds_train = read_mat_files(train_folder)\nfds_test = read_mat_files(test_folder)\n\n# 데이터 저장소에 있는 모든 데이터 읽기\ntrain_data_full = fds_train[0]\ntest_data_full_n10deg = fds_test[0]\ntest_data_full_0deg = fds_test[1]\ntest_data_full_10deg = fds_test[2]\ntest_data_full_25deg = fds_test[3]\n\n# 데이터 배열의 모양 출력하여 구조를 이해하기\nprint(\"train_data_full['X']의 모양: \", train_data_full['X'].shape)\nprint(\"train_data_full['Y']의 모양: \", train_data_full['Y'].shape)\nprint(\"test_data_full_n10deg['X']의 모양: \", test_data_full_n10deg['X'].shape)\nprint(\"test_data_full_n10deg['Y']의 모양: \", test_data_full_n10deg['Y'].shape)\n```\n\nshape 속성은 배열의 차원을 나타내는 튜플을 반환합니다. 2D 배열의 경우 shape는 (행, 열)로 이루어진 튜플을 반환합니다.\n\n```js\ntrain_data_full['X']의 모양:  (5, 669956)\ntrain_data_full['Y']의 모양:  (1, 669956)\ntest_data_full_n10deg['X']의 모양:  (5, 47517)\ntest_data_full_n10deg['Y']의 모양:  (1, 47517)\n```\n\n<div class=\"content-ad\"></div>\n\n훈련 데이터 파일 내에서, 주변 온도 측정 값은 다음과 같이 분할되어 있습니다:\n\n```js\nidx0   = 1 - 184257        # 온도 = 0°C\nidx10  = 184258 - 337973   # 온도 = 10°C\nidx25  = 337974 - 510530   # 온도 = 25°C\nidxN10 = 510531 - 669956   # 온도 = -10°C\n```\n\n우리가 출력한 훈련 데이터의 첫 5개 행을 살펴보면, X의 3번째 행이 온도를 나타냅니다. 이 값이 0이 될 것으로 예상할 수 있지만, 이 값들은 측정되고 정규화된 값입니다. 모든 예측 변수는 모델 수렴 및 성능을 향상시키기 위해 정규화되었습니다.\n\n훈련 온도 데이터 세트를 분리하려면, 아래 코드를 로딩 스크립트에 추가하십시오.\n\n<div class=\"content-ad\"></div>\n\n```js\r\n# train_data_full에서 X와 Y 추출하기\nX = train_data_full['X']\nY = train_data_full['Y']\n\n# 인덱스 범위 정의\nidx0 = slice(0, 184257)\nidx10 = slice(184257, 337973)\nidx25 = slice(337973, 510530)\nidxN10 = slice(510530, 669956)\n\n# 데이터 세그먼트 추출\nX_idx0 = X[:, idx0]\nY_idx0 = Y[:, idx0]\n\nX_idx10 = X[:, idx10]\nY_idx10 = Y[:, idx10]\n\nX_idx25 = X[:, idx25]\nY_idx25 = Y[:, idx25]\n\nX_idxN10 = X[:, idxN10]\nY_idxN10 = Y[:, idxN10]\n\n# 추출 확인을 위해 형태 출력\nprint(f'X_idx0 형태: {X_idx0.shape}, Y_idx0 형태: {Y_idx0.shape}')\nprint(f'X_idx10 형태: {X_idx10.shape}, Y_idx10 형태: {Y_idx10.shape}')\nprint(f'X_idx25 형태: {X_idx25.shape}, Y_idx25 형태: {Y_idx25.shape}')\nprint(f'X_idxN10 형태: {X_idxN10.shape}, Y_idxN10 형태: {Y_idxN10.shape}')\r\n```\n\n트레이닝 데이터에는 총 669,956개의 열이 있어서 처리하기에는 조금 많습니다. 간단하게 만들기 위해 데이터를 다시 샘플링하여 매 100번째 점을 가져와 평균 전압 및 평균 전류 예측 변수의 새로운 이동 평균값을 계산할 것입니다. 재계산된 이동 평균은 각 포인트에 대해 최근 5개 샘플을 사용합니다. 이는 i-5부터 i까지의 값들의 평균을 계산하기 위해 루프를 사용하여 수행됩니다. 이동 평균을 계산하는 데 최근 5개 샘플을 사용하는 것은 시계열 분석에서 일반적인 기술입니다. 이 접근 방식은 데이터를 부드럽게 만들면서 최근 변화에 반응성을 유지하는 균형을 제공합니다.\n\n데이터 전처리를 돕기 위해 파이썬 함수를 작성했습니다.\n\n```js\r\ndef resample_and_compute_moving_averages(X, Y, step=100):\r\n    # 데이터 재샘플링 (매 `step`번째 포인트 가져오기)\r\n    X_resampled = X[:, ::step]\r\n    Y_resampled = Y[:, ::step]\r\n    \r\n    # 새로운 이동 평균 계산\r\n    n = X_resampled.shape[1]\r\n    avg_voltage_idx = 3  # 4번째 열이 평균 전압이라고 가정\r\n    avg_current_idx = 4  # 5번째 열이 평균 전류이라고 가정\r\n    \r\n    new_avg_voltage = np.empty(n)\r\n    new_avg_current = np.empty(n)\r\n    \r\n    for i in range(n):\r\n        new_avg_voltage[i] = np.mean(X_resampled[0, max(0, i-5):i+1])\r\n        new_avg_current[i] = np.mean(X_resampled[1, max(0, i-5):i+1])\r\n    \r\n    X_resampled[avg_voltage_idx, :n] = new_avg_voltage\r\n    X_resampled[avg_current_idx, :n] = new_avg_current\r\n    \r\n    return X_resampled, Y_resampled\r\n```\n\n<div class=\"content-ad\"></div>\n\n학습 및 테스트 데이터 재샘플링은 이제 간단합니다.\n\n```js\n# 학습 데이터를 재샘플링하고 새로운 이동 평균 계산\nX_train_resampled, Y_train_resampled = resample_and_compute_moving_averages(X_train, Y_train)\n\n# 테스트 데이터 추출 및 재샘플링\nX_test_n10deg = test_data_full_n10deg['X']\nY_test_n10deg = test_data_full_n10deg['Y']\nX_test_n10deg_resampled, Y_test_n10deg_resampled = resample_and_compute_moving_averages(X_test_n10deg, Y_test_n10deg)\n\nX_test_0deg = test_data_full_0deg['X']\nY_test_0deg = test_data_full_0deg['Y']\nX_test_0deg_resampled, Y_test_0deg_resampled = resample_and_compute_moving_averages(X_test_0deg, Y_test_0deg)\n\nX_test_10deg = test_data_full_10deg['X']\nY_test_10deg = test_data_full_10deg['Y']\nX_test_10deg_resampled, Y_test_10deg_resampled = resample_and_compute_moving_averages(X_test_10deg, Y_test_10deg)\n\nX_test_25deg = test_data_full_25deg['X']\nY_test_25deg = test_data_full_25deg['Y']\nX_test_25deg_resampled, Y_test_25deg_resampled = resample_and_compute_moving_averages(X_test_25deg, Y_test_25deg)\n\n# 재샘플링 확인을 위해 형태 출력\nprint(f'재샘플링 후 학습 데이터 형태: X={X_train_resampled.shape}, Y={Y_train_resampled.shape}')\nprint(f'n10degC 테스트 데이터 형태: X={X_test_n10deg_resampled.shape}, Y={Y_test_n10deg_resampled.shape}')\nprint(f'0degC 테스트 데이터 형태: X={X_test_0deg_resampled.shape}, Y={Y_test_0deg_resampled.shape}')\nprint(f'10degC 테스트 데이터 형태: X={X_test_10deg_resampled.shape}, Y={Y_test_10deg_resampled.shape}')\nprint(f'25degC 테스트 데이터 형태: X={X_test_25deg_resampled.shape}, Y={Y_test_25deg_resampled.shape}')\n```\n\n데이터 처리 스케치의 전체 버전은 Reefwing Gist에서 제공됩니다. 데이터셋 크기를 재샘플링한 후에는 아래와 같은 크기가 됩니다.\n\n```js\n재샘플링 후 학습 데이터 형태: X=(5, 6700), Y=(1, 6700)\nn10degC 테스트 데이터 형태: X=(5, 476), Y=(1, 476)\n0degC 테스트 데이터 형태: X=(5, 443), Y=(1, 443)\n10degC 테스트 데이터 형태: X=(5, 426), Y=(1, 426)\n25degC 테스트 데이터 형태: X=(5, 393), Y=(1, 393)\n```\n\n<div class=\"content-ad\"></div>\n\n저희는 모든 전처리된 학습 및 테스트 데이터를 Preprocessed라는 새 하위 디렉토리에 저장할 거에요. 이 파일들은 CSV 형식으로 저장되며, 쉽게 읽고 쓸 수 있어서 사용자가 쉽게 확인할 수 있어요. 더 큰 데이터셋의 경우 HDF5 (계층적 데이터 형식)를 사용하면 효율적으로 대량의 데이터를 저장할 수 있고 복잡한 데이터 구조를 지원해요. 이는 과학 계산에서도 널리 사용되고 있어요. 관련 추가 코드는 아래에 나와 있어요.\n\n```js\npreprocessed_folder = os.path.join(output_folder, 'Preprocessed')\nos.makedirs(preprocessed_folder, exist_ok=True)\n\n...\n\n# 학습 데이터를 리샘플링하고 새로운 이동 평균을 계산합니다.\nX_train_resampled, Y_train_resampled = resample_and_compute_moving_averages(X_train, Y_train)\n\n# DataFrame을 생성하고 CSV로 저장합니다.\ntrain_df = pd.DataFrame(np.vstack((X_train_resampled, Y_train_resampled)).T,\n                        columns=['Voltage', 'Current', 'Temperature', 'Average Voltage', 'Average Current', 'SOC'])\ntrain_df.to_csv(os.path.join(preprocessed_folder, 'resampled_training_data.csv'), index=False)\n\n# 테스트 데이터를 추출하고 리샘플링합니다.\ntest_data_files = ['n10degC', '0degC', '10degC', '25degC']\nresampled_test_data_shapes = {}\n\nfor i, test_data_full in enumerate(fds_test):\n    X_test = test_data_full['X']\n    Y_test = test_data_full['Y']\n    X_test_resampled, Y_test_resampled = resample_and_compute_moving_averages(X_test, Y_test)\n    test_df = pd.DataFrame(np.vstack((X_test_resampled, Y_test_resampled)).T,\n                           columns=['Voltage', 'Current', 'Temperature', 'Average Voltage', 'Average Current', 'SOC'])\n    test_df.to_csv(os.path.join(preprocessed_folder, f'resampled_test_data_{test_data_files[i]}.csv'), index=False)\n    resampled_test_data_shapes[test_data_files[i]] = (X_test_resampled.shape, Y_test_resampled.shape)\n```\n\n## 단계 3 — 모델 선택\n\n배터리 충전 상태 (SOC) 및 건강 상태 (SOH)를 추정하기 위해 여러 머신러닝 알고리즘이 광범위하게 연구되어 왔습니다. 네 가지 가장 탁월한 유형은 얕은 신경망 (NN), 딥러닝 (DL), 서포트 벡터 머신 (SVM), 그리고 가우시안 프로세스 회귀 (GPR)입니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_4.png)\n\n얕은 신경망(SNN)\n얕은 신경망(Figure 4)은 한 개 또는 두 개의 은닉층으로 구성됩니다. 딥 러닝과 비교하면 비교적 단순하지만 전력 특성의 비선형성을 모델링하기에 충분히 강력합니다. 단층 신경망은 더 간단한 구조로, 계산 능력과 메모리가 덜 필요하여 자원 제한적인 임베디드 장치에서 실시간 SOC 및 SOH 추정에 적합합니다. 이러한 모델은 전압, 전류, 온도와 같은 다양한 입력 특성으로부터 SOC 및 SOH를 예측하는 데 학습될 수 있습니다.\n\n![이미지](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_5.png)\n\n딥 러닝(DL)\n딥 러닝 모델인 딥 신경망(DNNs — Figure 5) 및 합성곱 신경망(CNNs)과 같이 여러 층을 가지고 있어 데이터의 복잡한 패턴과 상호작용을 포착할 수 있습니다. DL 모델은 입력 특성과 SOC 또는 SOH 사이의 복잡한 관계를 학습하여 매우 정확한 추정을 제공할 수 있습니다. 그러나 그들의 복잡성은 더 많은 계산 자원과 메모리를 필요로 하며, 이는 일부 임베디드 시스템에 제약 요인이 될 수 있습니다. 그러나 임베디드 하드웨어의 발전으로 실시간 응용 프로그램에서 딥 러닝 모델을 배포하긴 점점 더 가능해지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![SVM](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_6.png)\n\n서포트 벡터 머신(SVM)\n서포트 벡터 머신(도표 6)은 분류와 회귀 작업 모두에 사용할 수 있는 지도 학습 모델입니다. SOC 및 SOH 추정을 위해 SVM은 고차원 데이터를 효과적으로 처리할 수 있으며, 특히 훈련 데이터가 제한적인 상황에서 과적합에 강합니다. SVM은 데이터를 서로 다른 클래스로 분리하거나 연속 값을 예측하는 데 최적의 초평면을 찾아 작동합니다. 상대적으로 낮은 계산 요구로 인해 리소스가 제한된 임베디드 응용 프로그램에 적합합니다.\n\n![GPR](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_7.png)\n\n가우시안 프로세스 회귀(GPR)\n가우시안 프로세스 회귀(도표 7)는 예측 뿐만 아니라 불확실성 추정을 제공하는 비모수적인 확률적 접근 방식입니다. SOC 및 SOH 추정에 특히 유용한 GPR은 운영 조건 및 노화로 인한 배터리 행동의 기저 불확실성을 모델링할 수 있습니다. GPR 모델은 유연하며 새로운 데이터로 업데이트할 수 있어, 배터리 수명 주기 내의 변화에 적응할 수 있습니다. 이러한 이유로 GPR 모델을 채택하여 구현하기로 결정했습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 GPR은 계산이 많이 필요하며, 실시간 임베디드 애플리케이션에 적합하게 만들기 위해 효율적인 구현이 필요합니다. 또는 장치 외부에서 처리를 수행하고 최적화된 후에 훈련된 모델을 배포할 수도 있습니다. 이것이 우리가 취할 접근 방식입니다.\n\n## 파트 4\n\n시리즈의 제 4부에서 배터리 SOC 예측기의 ML 프로세스를 계속할 것입니다. 이는 모델을 훈련하고 evaluate하는 데 중점을 둘 것입니다.\n\n## 참고문헌\n\n<div class=\"content-ad\"></div>\n\n[1] Kollmeyer, Philip; Vidal, Carlos; Naguib, Mina; Skells, Michael (2020), “LG 18650HG2 Li-ion Battery Data and Example Deep Neural Network xEV SOC Estimator Script”, Mendeley Data, V3, doi: 10.17632/cp3473x7xv.3\n\n만약 이 글을 즐겁게 보셨고 제 글쓰기를 지원하고 싶으시다면, 팔로우를 누르거나 (최대 50번), 강조하기, 혹은 댓글을 남겨주세요! 혹은 다른 방법으로 커피를 사주시거나 구독해주셔도 됩니다. 새 글이 올라올 때마다 이메일을 받아보실 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_0.png"},"coverImage":"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_0.png","tag":["Tech"],"readingTime":15},{"title":"3D 프린팅의 현황 복잡성과 도전 과제 탐구하기","description":"","date":"2024-06-30 23:34","slug":"2024-06-30-TheStateof3DPrintingNavigatingtheComplexityandChallenges","content":"\n\n지난 10년 동안 3D 프린팅 기술은 많이 발전해 왔습니다. 하지만 저처럼 산업에 오래 종사한 분들은 여전히 극복해야 할 중요한 과제들이 있다는 것을 아실 것입니다. 특히 제가 창업한 3D 프린팅 스타트업은 특정 응용 프로그램 요구 사항을 위한 센서 및 소프트웨어를 만드는 데 초점을 맞추고 있어, 현재 3D 프린팅 분야의 역동성과 복잡성을 직접 경험해왔습니다.\n\n<img src=\"/assets/img/2024-06-30-TheStateof3DPrintingNavigatingtheComplexityandChallenges_0.png\" />\n\n# 3D 프린팅과 어셈블리 코드: 복잡한 병행\n\n현재 3D 프린팅 기술을 되새겨보면서, 초창기 어셈블리 코드로 프로그래밍하는 것과 유사한 점을 느낍니다. 어셈블리 코드는 컴퓨터 아키텍처에 대한 상세한 지식이 요구되는 저수준 프로그래밍 언어입니다. 어셈블리 코드를 사용하여 프로그램을 작성하는 것은 세심한 작업이며, 모든 명령이 명시적으로 기술되어야 하기 때문에 실수할 여지가 거의 없습니다.\n\n<div class=\"content-ad\"></div>\n\n현재 3D 프린터를 설정하고 유지하는 것도 복잡하고 요구가 높은 작업일 수 있습니다. 각 기계마다 독특한 특징과 조정이 필요한 설정이 있어서 최적의 결과를 얻으려면 세밀한 조정이 필요합니다. 표준화된 프로토콜의 부재로 인해 사용자들은 종종 기계의 펌웨어와 구성 설정에 심취해야 합니다, 마치 어셈블리 코드를 다루는 프로그래머처럼요.\n\n비교를 위해 어셈블리와 G코드에서 각각 두 가지 짧은 예시가 아래에 나와 있습니다.\n\n```js\nsection .data\n    msg db 'Hello, World!',0x0a ; 프린트할 메시지\n\nsection .bss\n\nsection .text\n    global _start\n\n_start:\n    ; 메시지 프린트\n    mov eax, 4          ; sys_write의 시스템 콜 번호\n    mov ebx, 1          ; 파일 서술자 1은 표준 출력\n    mov ecx, msg        ; 메시지의 포인터\n    mov edx, 13         ; 메시지의 길이\n    int 0x80            ; 커널 호출\n\n    ; 프로그램 종료\n    mov eax, 1          ; sys_exit의 시스템 콜 번호\n    xor ebx, ebx        ; 반환 값 0\n    int 0x80            ; 커널 호출\n```\n\n```js\n; G코드 시작\nG28 ; 모든 축 원점 복귀\nG21 ; 단위를 밀리미터로 설정\nG90 ; 절대 위치 지정 사용\nM82 ; 외출시 등 분모를 절대 모드로 설정\n\n; 프린팅 시작\nG1 Z0.2 F300 ; 시작 높이로 이동\nG92 E0 ; 외출시 초기화\nG1 F140 E30 ; 140 mm/min 속도로 30mm 필라멘트 밀어내기\nG1 F3000 ; 이후 동작 속도 설정\n\n; 선 그리기\nG1 X50 Y50 Z0.2 F1500 ; 시작점으로 이동\nG1 X150 Y50 E15 ; 15mm 필라멘트를 밀어내면서 선 긋기\nG1 X150 Y150 E30 ; 다음 지점으로 이동하면서 외출시하기\n\n; G코드 종료\nG1 F140 E-3 ; 필라멘트 되감기\nG28 ; 모든 축 원점 복귀\nM84 ; 모터 비활성화\n```\n\n<div class=\"content-ad\"></div>\n\n# 프린터 설정: 초기 2D 프린터의 메아리\n\n스탠다드 드라이버가 2D 인쇄를 간편하게 만들기 전 날들을 기억하십니까? 그때는 프린터 설정이 수동으로 드라이버를 설치하고 다양한 호환성 문제를 해결해야 했기 때문에 불편한 작업이었습니다. 현재 3D 프린터 설정 상태는 그 시대를 연상시킵니다.\n\n기술 발전에도 불구하고, 3D 프린터 설정 프로세스는 여전히 상당한 장벽으로 남아 있습니다. 각 프린터 모델은 고유의 설명서가 있으며, 신뢰할 수 있는 인쇄물을 얻기 위해서는 가파른 학습 곡선이 필요합니다. 이 상황은 다수의 일반적인 해결책이 존재하나, 주로 취미가인을 위해 제공되어 전문가와 산업 사용자의 특정 요구를 해결하지 못하고 있다는 점에서 악화되고 있습니다.\n\n# 🤔 왜요?\n\n<div class=\"content-ad\"></div>\n\n# 코드의 높은 비용과 자동화에 미치는 영향\n\n3D 프린팅 분야의 발전을 방해하는 또 다른 중요한 문제는 미국에서 안정적인 소프트웨어를 개발하는 높은 비용입니다. 이로 인해 우리는 자동화와 고품질, 신뢰성 높은 3D 프린터 개발에서 뒤처지고 있습니다. 3D 프린팅과 같이 복잡한 산업에서 강력하고 자동화된 솔루션이 필수적입니다.\n\n현재 많은 솔루션이 일반화되어 \"한 사이즈가 모든 것에 맞는\" 것으로 설계되어 있습니다. 이러한 접근은 취미로 하는 사람들에게는 도움이 되겠지만, 특정 응용 요구 사항이 있는 사람들에게는 부족합니다. 저희 스타트업은 \"생활 품질 툴킷\"을 만드는 데 집중하고 있습니다. 캘리브레이션, 재료 튜닝, 부분 내부 검사, 그리고 실시간 동적 Gcode™ 조정과 같은 일반적이고 귀찮은 작업을 간소화하는 것을 목표로 합니다. 맞춤 솔루션을 제공함으로써 산업 간극을 메우고 산업을 발전시키는데 기여하길 희망합니다.\n\n# 앞으로 전망: 특화된 솔루션이 필요한 이유\n\n<div class=\"content-ad\"></div>\n\n앞으로 나아가면서, 3D 프린팅 산업은 보다 특화된 응용 프로그램별 솔루션을 개발하는 것이 중요합니다. 2D 프린팅에서 표준 드라이버가 혁명을 일으킨 것처럼, 3D 프린팅 영역에서도 기술을 더 접근 가능하고 신뢰할 수 있게 만들기 위해 유사한 발전이 필요합니다.\n\n우리가 스타트업에서 한 여정은 이러한 도전에 직면하고자 하는 열망으로 인해 이뤄졌습니다. 특정 요구 사항을 충족시키는 센서와 소프트웨어에 집중함으로써, 우리는 보다 체계적이고 효율적인 3D 프린팅 경험을 만들기 위해 노력하고 있습니다. 이제는 일반화된 솔루션 시대를 넘어서 전문화되고 신뢰할 수 있으며 자동화된 3D 프린팅 기술의 미래를 받아들이는 때입니다.\n\n# 시장 역학에 대한 답답함과 전략적 영향\n\n마지막으로 언급하고 싶은 것은 중국이 3D 프린팅 기술에서 미국 기업들을 완전히 압도하고 있다는 점에 대한 저의 답답함입니다. Bambu Labs와 같은 기업들이 소개하는 혁신들은 솔직히 미국 기업들이 여러 년 전에 개발하고 상용화했어야 했던 것들입니다. 만약 우리가 중국과 전쟁을 벌인다면, 빠르고 저렴하게 더 많은 제품을 만들어야 승리할 수 있습니다. 현재 그들은 그 측면에서 우리보다 더 뛰어나죠.\n\n<div class=\"content-ad\"></div>\n\n미국에서 자동화 및 신뢰할 수 있는 기술에 투자가 부족하고 고비용 때문에 우리가 얼마나 뒤쳐져 있는지 보는 것은 마음이 아프다. 3D 프린팅 산업에서 우리의 선두지위를 되찾으려면 혁신, 비용 효율적인 개발, 전문가와 산업 사용자들의 특별한 요구를 해결하는 데 초점을 맞춰야 한다.\n\n## 신기함보다 신뢰할 것의 문제\n\n창업 투자와 컨퍼런스의 세계에서는 종종 가장 주목을 끄는 것이 곧은 새로운 기기와 혁신이다. 그러나 최신과 가장 좋은 것에 초점을 맞추는 것은 종종 신뢰성에 대가가 따른다. 3D 프린팅 산업은 자주 \"문제를 찾는 해결책\"으로 묘사된다. 기업들이 자본 장비에 의존할 수 없을 때, 진정한 진전을 위해 화려한 프로토타입에서 실제 응용에서 지속적으로 성능을 발휘할 수 있는 견고하고 신뢰할 수 있는 기계로의 중점을 옮겨야 한다.\n\n해당 주제에 대한 생각과 경험을 자유롭게 공유해 주세요. 3D 프린팅에서 직면한 가장 큰 문제는 무엇인지, 어떻게 그 문제들을 해결할 수 있을지 생각해 보세요.","ogImage":{"url":"/assets/img/2024-06-30-TheStateof3DPrintingNavigatingtheComplexityandChallenges_0.png"},"coverImage":"/assets/img/2024-06-30-TheStateof3DPrintingNavigatingtheComplexityandChallenges_0.png","tag":["Tech"],"readingTime":4}],"page":"1","totalPageCount":1,"totalPageGroupCount":1,"lastPageGroup":1,"currentPageGroup":0},"__N_SSG":true}