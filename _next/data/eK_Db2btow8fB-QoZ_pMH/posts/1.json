{"pageProps":{"posts":[{"title":"다가오는 AI 물결 모든 산업을 혁신하고 기업주와 노동자를 뒤흔들 2024 최신 AI 동향","description":"","date":"2024-06-30 23:42","slug":"2024-06-30-TheUpcomingAIWaveHowItsGoingtoRevolutionizeEveryIndustryandShakeUpBusinessOwnersandLaborers","content":"\n\n여러분, 모자를 꼭 놓치지 마세요! AI 혁명이 올 것이고, 모든 것을 바꿀 것입니다. 의료부터 금융, 제조업부터 소매업까지, AI는 더 이상 과학 소설이 아닌 새로운 현실입니다. 파도를 탈 준비가 되셨나요?\n\n# 비즈니스 소유자를 위한 AI 변화: 게임 체인저\n\n비즈니스 소유자들에게 AI 파도는 황금을 찾은 것과 같습니다. 몇 초만에 데이터 산으로 내려다보고 시장 트렌드를 불길한 정확도로 예측하며, 시간을 많이 소비하는 지루한 업무들을 자동화하는 힘을 가지는 것을 상상해보세요. AI는 이제 더 이상 테크 기업만의 것이 아니라 모두를 위한 것입니다.\n\n효율성 해제와 혁신 유발\n\n<div class=\"content-ad\"></div>\n\nAI는 효율성과 혁신의 완전히 새로운 수준으로 안내해줄 패스입니다. AI를 채용하는 것은 운영을 간소화하고 비용을 절감하며 고객들을 감동시키는 것을 의미합니다. AI 기반의 통찰력을 통해 보다 똑똑한 결정을 내릴 수 있고, 제품을 맞춤화하며 경쟁에서 앞서갈 수 있습니다.\n\n고객 지원에서 AI에 대해 생각해보세요. AI-기반 음성 어시스턴트는 24/7 쿼리를 처리하여 일관된, 정확한 답변을 제공할 수 있습니다. 이는 단지 고객들을 행복하게 하는 것 뿐만 아니라, 인간 에이전트들이 더 복잡한 문제를 다룰 수 있도록 해줍니다. 결과는 무엇인가요? 생산성과 고객 애정이 크게 향상됩니다.\n\n경쟁 우위 확보\n\n오늘날 빠르게 변화하는 세상에서 경쟁력을 유지하는 것은 순발력과 혁신력을 갖추는 것을 의미합니다. AI는 이 두 가지를 할 수 있는 도구를 제공합니다. 전략을 안내해주는 예측 분석부터 공급망을 최적화하는 머신 러닝 알고리즘에 이르기까지 가능성은 무한합니다. AI에 집중하는 사업주들은 자신의 산업을 선도하며, 성장을 주도하고 경쟁자들을 뒤로 남길 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 인공지능 파도의 어둠 면: 인간 노동에 미치는 영향\n\n그러나 이것은 또 다른 면이 있습니다. 인공지능이 비즈니스에 많은 혜택을 가져다 주는 반면, 인력에는 긴 그림자가 드리우고 있습니다. 가장 큰 질문은: 노동자들은 어떻게 되는 것일까요?\n\n일자리 위기\n\n여기서 상황이 무서워집니다. 인공지능이 더 똑똑해지면서 많은 일자리가 위험에 처하게 됩니다. 제조업과 물류와 같이 수동 노동에 많이 의존하는 산업들은 이미 열을 맞고 있습니다. 로봇과 자동화 시스템이 반복적인 작업을 대신하고 있기 때문에 인간에게 일자리가 더 이상 제공되지 않게 되는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n기는 경제의 부상\n\n많은 노동자들에게 인공지능의 물결은 불안한 미래를 의미합니다. 정규직이 단기 계약직과 프리랜서 일자리로 교체될 수도 있습니다. 확실히, 기는 경제는 유연성을 제공하지만, 일자리 불안과 혜택이 없다는 것을 의미합니다. 노동자들은 게임에 머무르기 위해 새로운 기술을 배워야 할 것입니다.\n\n기술 격차\n\n우리가 인공지능 왕국으로 이동함에 따라, 새로운 기술의 필요성은 중대합니다. 적응하지 않는 노동자들은 뒤처지기 쉽습니다. 학교와 기업은 인공지능 시대를 위해 사람들을 준비하는 교육 프로그램을 제공하기 위해 협력해야 합니다. 데이터 분석부터 머신 러닝까지, 새로운 기술이 게임의 이름입니다.\n\n<div class=\"content-ad\"></div>\n\n![Image](/assets/img/2024-06-30-TheUpcomingAIWaveHowItsGoingtoRevolutionizeEveryIndustryandShakeUpBusinessOwnersandLaborers_0.png)\n\n# 변화를 받아들이기\n\n다가오는 AI 파도는 도전이자 기회이다. 사업주들은 지금 AI의 선술교를 타야하며, 증가된 효율성과 경쟁 우위의 혜택을 누려야 한다. 동시에 미래에 대비할 수 있도록 노동자들을 돕는 역할을 해야 한다.\n\n행동을 취하라\n\n<div class=\"content-ad\"></div>\n\n인공 지능 혁명은 멈출 수 없어요. 이를 포용하고, 준비하고, 여러분의 업계에 미치는 영향을 조절해 보세요. 기업 주인으로서, 이제는 인공 지능 기술과 인력 교육에 투자할 때입니다. 근로자들에게는 평생 학습과 적응력이 중요합니다. 함께하면 인공 지능의 파도를 탈 수 있고, 이를 통해 더 강해져 나올 수 있어요.\n\n이제 뛰어들 준비가 되셨나요?","ogImage":{"url":"/assets/img/2024-06-30-TheUpcomingAIWaveHowItsGoingtoRevolutionizeEveryIndustryandShakeUpBusinessOwnersandLaborers_0.png"},"coverImage":"/assets/img/2024-06-30-TheUpcomingAIWaveHowItsGoingtoRevolutionizeEveryIndustryandShakeUpBusinessOwnersandLaborers_0.png","tag":["Tech"],"readingTime":3},{"title":"OpenLLM으로 언어 학습 모델LLM을 위한 Raspberry Pi 5의 강력한 활용 방법","description":"","date":"2024-06-30 23:41","slug":"2024-06-30-UnleashingthePowerofRaspberryPi5forLanguageLearningModelsLLMswithOpenLLM","content":"\n\n라즈베리 파이 5가 최근에 출시되어 테크 열정가와 전문가들에게 새로운 기회의 문을 열었습니다. 이 강력한 마이크로 컴퓨터의 가장 흥미로운 혁신적인 사용 중 하나는 언어 학습 모델 (LLM) 분야에서 입니다. 이 글에서는 라즈베리 파이 5를 활용하여 OpenLLM을 실행하고 실험하여, 인공 지능 및 머신 러닝 프로젝트를 위한 강력한 소형 장비로 변환하는 방법을 살펴보겠습니다.\n\n# 라즈베리 파이 5를 특별하게 만드는 요소는 무엇인가요?\n\n라즈베리 파이 5는 이전 제품들보다 상당히 업그레이드되어, 다양한 고급 응용 프로그램에 적합한 인상적인 사양을 자랑합니다:\n\n- Quad-Core ARM Cortex-A76 프로세서, 2.4 GHz: 복잡한 연산을 처리하기에 이상적인 상당한 성능 향상을 제공합니다.\n- 최대 8GB의 RAM: 기계 학습 모델을 비롯한 메모리 집약적인 응용 프로그램을 실행하기 위한 풍부한 메모리를 제공합니다.\n- 향상된 연결성: USB 3.0 포트, 전원을 위한 USB-C, 그리고 기가비트 이더넷을 갖추어 빠른 데이터 전송과 안정적인 네트워크 연결성을 보장합니다.\n- PCIe 슬롯: 더 많은 확장성을 제공하여, 더 빠른 데이터 접근을 위해 고속 SSD를 추가하는 등 다양한 확장이 가능합니다.\n\n<div class=\"content-ad\"></div>\n\n# 언어 학습 모델 (LLM)이란 무엇인가요?\n\n언어 학습 모델 (LLM)은 인공 지능의 하위 집합으로, 인간 언어를 이해하고 생성하며 조작하는 데 초점을 맞춥니다. 이러한 모델들은 딥 러닝 알고리즘을 기반으로 하며, 번역, 요약, 감정 분석 등 다양한 작업을 수행할 수 있습니다. 잘 알려진 LLM에는 GPT-3, BERT, T5 등이 있습니다. OpenLLM은 이러한 모델들의 오픈 소스 구현으로, 개발자들이 LLM을 탐색하고 활용할 수 있는 접근 가능한 도구를 제공합니다.\n\n# LLM에 라즈베리 파이 5를 사용하는 이유는 무엇인가요?\n\nLLM을 실행하기 위해 라즈베리 파이 5를 사용하는 것은 야심찬 일처럼 보일 수 있지만, 이러한 설정을 고려할만한 몇 가지 확고한 이유가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 가격: 일반적인 서버나 고성능 데스크탑에 비해 라즈베리 파이 5는 LLM 실험에 비용 효율적인 솔루션입니다.\n- 휴대성: 소형 사이즈로 이동이 쉽고 다양한 환경에서 설정하기 쉽습니다. 이동이나 원격 애플리케이션에 완벽합니다.\n- 에너지 효율성: 전통적인 컴퓨터보다 훨씬 적은 전력을 소비하여 연속적인 운영에 친환경적인 선택입니다.\n- 커뮤니티와 지원: 라즈베리 파이는 다양한 개발자와 열렬한 팬들로 이루어진 강력한 커뮤니티를 가지고 있어 다양한 자료와 지원을 제공합니다.\n\n# OpenLLM을 위한 라즈베리 파이 5 설정\n\n## 단계 1: 라즈베리 파이 5 준비하기\n\n먼저 라즈베리 파이 5를 설정하세요. 최소 32GB의 microSD 카드, 전원 공급 장치, 키보드, 마우스, 모니터와 같은 필수 주변 기기가 필요합니다. 공식 웹사이트에서 라즈베리 파이 OS를 다운로드하고 Balena Etcher를 사용하여 이미지를 microSD 카드에 플래시하세요.\n\n<div class=\"content-ad\"></div>\n\n- Raspberry Pi OS 다운로드: Raspberry Pi OS\n- OS 플래시: Balena Etcher를 사용하여 OS 이미지를 microSD 카드에 작성합니다.\n\n## 단계 2: 필요한 소프트웨어 설치\n\n라즈베리 파이 5가 구동 중이면 머신 러닝을 위한 필수 소프트웨어 패키지를 설치하세요. 터미널을 열고 시스템을 업데이트하세요:\n\n```js\nsudo apt update && sudo apt upgrade\n```\n\n<div class=\"content-ad\"></div>\n\n다음으로 Python과 pip을 설치해 보세요:\n\n```js\nsudo apt install python3 python3-pip\n```\n\n## 단계 3: OpenLLM 및 종속성 설치\n\nOpenLLM은 LLM을 실행하고 실험할 수 있는 오픈 소스 라이브러리입니다. OpenLLM 및 관련 종속성을 설치하려면 다음 명령어를 사용하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\npip3 install openllm\n```\n\n## Step 4: 성능을 최적화하세요\n\n라즈베리 파이 5가 고성능 작업을 수행할 때 최상으로 작동하도록 보장하려면 다음 최적화를 고려해보세요:\n\n- 스왑 메모리 활성화: 이를 통해 메모리 사용량을 효과적으로 관리할 수 있습니다.\n- 오버클로킹: 가능하다면 오버클로킹은 추가 성능 향상을 제공할 수 있습니다.\n- 외부 저장소: PCIe 슬롯을 통해 외부 SSD를 사용하면 데이터 액세스 속도를 크게 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 단계 5: 라즈베리 파이 5에서 OpenLLM을 사용하여 LLM 실행하기\n\n설치가 완료되었으므로 이제 OpenLLM을 사용하여 사전 훈련된 LLM을 실행할 수 있습니다. 텍스트 생성을 위해 간단한 스크립트가 여기 있습니다:\n\n```js\nfrom openllm import load_model, generate_text\n# 사전 훈련된 모델 로드\nmodel = load_model('gpt4')\n# 텍스트 생성\ntext = generate_text(model, \"한때\", max_length=50)\nprint(text)\n```\n\n## 단계 6: 실험하고 반복하기\n\n<div class=\"content-ad\"></div>\n\n라즈베리 파이 5에서 LLMs를 실행하는 것은 AI와 머신 러닝을 실험할 수 있는 좋은 방법입니다. 여러분은 매개변수를 조정하고 모델을 세밀하게 조정하거나 강력한 도구를 활용하여 나만의 애플리케이션을 개발할 수 있습니다.\n\n# OpenLLM을 이용한 라즈베리 파이 5의 장점\n\n## 비용 효율적인 학습 및 개발\n\n라즈베리 파이 5의 가격이 저렴하여 고가의 하드웨어가 필요하지 않고도 LLMs를 배우고 실험할 수 있는 훌륭한 플랫폼으로 만들어줍니다.\n\n<div class=\"content-ad\"></div>\n\n## 엣지 AI 활성화하기\n\nRaspberry Pi 5를 사용하여 LLMs를 지원하는 것은 중앙 서버가 아닌 로컬 기기에서 처리가 발생하는 엣지 AI의 성장 트렌드를 지원합니다. 이는 지연 시간을 줄이고 프라이버시를 강화합니다.\n\n## 혁신 유도하기\n\nRaspberry Pi 5의 다재다능함과 접근성은 혁신과 창의성을 촉진합니다. 개발자와 취미 체험가들은 교육, 의료 및 스마트 홈 기술과 같은 다양한 분야에서 LLMs를 활용한 새로운 응용 프로그램과 솔루션을 탐구할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-30-UnleashingthePowerofRaspberryPi5forLanguageLearningModelsLLMswithOpenLLM_0.png"},"coverImage":"/assets/img/2024-06-30-UnleashingthePowerofRaspberryPi5forLanguageLearningModelsLLMswithOpenLLM_0.png","tag":["Tech"],"readingTime":4},{"title":"키네시스 어드밴티지 2 키보드 소음 줄이는 방법","description":"","date":"2024-06-30 23:40","slug":"2024-06-30-SilencingKinesisAdvantage2Keyboard","content":"\n\n![키네시스 어드밴티지 2 키보드](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_0.png)\n\n키네시스 어드밴티지 2 키보드는 소프트웨어 개발자를 위해 만들어진 것이 아니에요, 특히 C++, 자바, 자바스크립트 그리고 일부 파이썬을 자주 사용하는 사람들에게는 더 그렇죠.\n\n괄호와 중괄호가 이상한 위치에 있어서 손가락을 약한 각도로 사용해야 하고, 레이아웃 때문에 일부 키가 원래 위치에 있지 않아서 약지로 눌러야 해요 - 제가 모르는 것일수도 있지만, 제 약지는 제일 강한 손가락은 아니거든요. 그래서 필요한 대부분의 문자를 약지로 누를 수 있어서 개발자들의 삶이 힘들어져요. 물론, 저는 열 손가락법을 얘기하고 있어요. 그렇지 않으면, 당신이 원하는 손가락으로 모든 키에 접근할 수 있어요. 키를 원하는대로 매핑할 수 있고 - 예를 들어, 저는 대괄호를 페이지 업과 페이지 다운 키로 재매핑해서 제 삶을 조금 더 쉽게 만들었어요.\n\n개발자들을 위한 것은 아니지만, 저는 사용해본 적 있는 키보드 중에서 가장 편안한 키보드에요. 특히 이 글을 쓰는 것처럼 작성만 하고 있다면, 손가락 열 기술을 알고 있다면 편안하고 빠른 키보드로 시장에 없어요.\n\n<div class=\"content-ad\"></div>\n\n상당한 단점을 가지고 있는 쓰기에 좋아요: 너무 시끄러워요! 이전에 저는 이렇게 시끄러운 키보드를 본 적이 없습니다. (저도 Keycron 메카닉 키보드가 있어요). 브라운 \"조용한\" 스위치를 사용하고 있지만, \"조용한\"은 키네시스 세계에서는 전체적인 소음이 아닌 스위치의 조용함을 의미합니다. (저는 키를 누르는 힘이 센 편이 아니에요.) 키네시스를 사용하기 시작했을 때, 동료들이 먼저 이야기해 주었어요. 그래서 집에서 사용하게 되었어요. 긴 글을 쓸 때면 소음 차단 헤드폰 없이는 그 소음을 견딜 수가 없어요. 정말로 제게는 악몽이에요.\n\n![Kinesis Advantage 2 Keyboard](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_1.png)\n\n키들에 O 실리콘 링 감쇠기를 구입했는데, 효과는 거의 없고 큰 획득이 없었어요. 이렇게 구입하지 않아도 돼요. 최근에 다음 기사를 발견했어요: https://yboulkaid.com/2022/03/15/kinesis.html. 이 비용이 싸지 않고 이 재료들로 다른 키보드를 살 수도 있어요. 그래서 잠시 중단했어요.\n\n매일 키보드의 시끄러움에 대한 짜증이 쌓여가는데, 아마도 제 삶의 변화 때문이겠죠. 지금은 아들이 있는데 하루 종일 조금 시끄러워요. 그가 자고 있는 동안 창작을 하며 조용한 시간을 가지고 싶은데, 다른 아이(Kinesis Advantage 2)이 울부짖기 시작하면 어쩔 수 없어요. 그래서 한 번 시도해보기로 결심했어요.\n\n<div class=\"content-ad\"></div>\n\n내 구매는 약 75 유로 정도 걸렸어요: 2 종류의 QMX 소거기(일반 키와 썸 클러스터에는 서로 다른 종류가 필요하기 때문)와 Dynamat Extreme을 샀습니다. 아래는 품목에 관한 더 자세한 내용입니다:\n\n- QMX-Clips PCB 마운트(검정 윗면, 썸 클러스터용): [링크](https://uniqey.net/en/accessories/17/qmx-clips-pcb-mount-110-pcs)\n- QMX-Clips Plate 마운트(흰색 윗면; 일반 키용): [링크](https://uniqey.net/en/accessories/18/qmx-clips-plate-mount-110-pcs.?c=11)\n- Dynamat Xtreme — 미국에서 제작된 스피커 키트 버전을 구매할 수 있었는데, EU에서는 모든 버전을 찾을 수 없었습니다. Xtreme 버전이면 어떤 버전이든 구매할 수 있어요.\n\nQMX 클립을 설치하는 것은 챌린지였는데, Advantage 2s와 같은 키보드 레이아웃용으로 만들지 않아서 어려웠어요. 어떤 키는 다른 것보다 높고 각도가 다르기 때문입니다. 파란 도구로 클립을 설치할 수 없었고, 그들이 제공한 평평한 드라이버로 설치했어요. 스크류드라이버로 연결 지점을 누르면 클릭 소리가 들립니다. 때때로 클릭 소리가 안 들리면 방향을 바꿔야 해요 — 만약 왼쪽 부분을 먼저 클릭해도 오른쪽 부분이 클릭하지 않는다면, 오른쪽을 먼저 클릭한 후 왼쪽을 클릭합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_3.png)\n![Image 2](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_4.png)\n![Image 3](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_5.png)\n![Image 4](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_6.png)\n\n\n<div class=\"content-ad\"></div>\n\n![Silencing Kinesis Advantage2 Keyboard](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_7.png)\n\n또 하나의 도전 과제는 Dynamat Xtreme를 보드에 직접 붙이는 것이었습니다. 바닥은 쉬웠지만 실제 키 쪽은 그리드가 많아 맞춤 컷팅을 해야 했기 때문에 어려웠어요. 또 하나의 포인트는 Dynamat Xtreme을 두께 그대로 두면 키보드를 다시 닫을 수 없다는 것이었습니다. 일반적으로 뒤로 누르는 롤러 도구가 있지만, 나는 다시 사용할 일이 없는 물건에 추가 비용을 지불하고 싶지 않았어요. 그래서 나는 나만의 나만의 나만의 자전구로 눌렀어요(그것은 내 아들이 장난감의 일부에요 :)). 이런 기회가 없다면 립스틱 케이스, 작은 머그잔 또는 비슷한 물건을 사용할 수 있지만, 그 위에 눌러주고 Dynamat Xtreme이 두께를 잃도록 하는 것이 중요해요. 이 과정은 키보드를 닫는 것뿐만 아니라 소리 차단에도 중요해요.\n\n![Silencing Kinesis Advantage2 Keyboard](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_8.png)\n\n드디어 완료했어요. 다음 동영상은 처음 시도한 것이에요. 특히 Dynamat Xtreme 쪽에서 몇 일 뒤에도 더 조용해지고 있어요.\n\n<div class=\"content-ad\"></div>\n\n프로세스의 안 좋은 측면은 많은 잔여물이 생긴다는 점이에요. 기본적으로, 구매한 소재로 2개의 Kinesis Advantage 2를 신청할 수 있지만, 공유할 다른 친구가 없어서요.\n\n![이미지](/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_9.png)\n\nQMX-클립이 장기적으로 어떻게 반응할지 확신은 못하지만, 교체용 여분 부품들은 충분히 갖고 있어요.\n\n또 다른 단점은 특히 엄지 클러스터에서, 일부 키들이 각도와 추가 부품 때문에 너무 세게 누르면 막혀버릴 수 있다는 점이에요. CTRL, Page Up, Page Down, Alt Option, Home, 그리고 End 키 같은 거 말이죠. 나는 너무 세게 누르지 않았는데도, 적용하기 전에보다 자연스럽지 못하다는 느낌이 들어요.\n\n<div class=\"content-ad\"></div>\n\n결과는... 나는 이 어플리케이션에 대해 후회하지 않아. 나는 키 소리에 만족하며 사용성도 좋다고 생각해 (지금은 놀랍도록 조용해졌어; 물론, 셔클렛 타입처럼 아니야). 나에게 유일한 후회는 이전에 이것을 적용하지 않았다는 것이야. 물론, 이 어플리케이션은 모두에게 필요한 것은 아닐 수 있어. 키보드 소리를 좋아하고 혼자 살거나 혼자 일 하는 경우, 추가 비용을 지출할 필요가 없어. 어플리케이션을 한 후에 키보드를 판매하는 것이 불가능할 수도 있어, 왜냐하면 새로운 소유자가 그런 어플리케이션을 원하지 않을 수 있기 때문이지만, 나의 경우에는 아니야. 나는 내 키보드를 판매하는 것을 고려하지 않아.\n\n나는 여러분의 지원으로 더 많이 쓰는 인간 작가야! 돈을 내지 않아도 돼. 내 이야기를 좋아한다면 👏 열어 줘, 말하고 싶은 것이 있다면 ✍️ 코멘트를 달아 줘. 나를 Medium, LinkedIn, Instagram, X에서 팔로우할 수 있어.","ogImage":{"url":"/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_0.png"},"coverImage":"/assets/img/2024-06-30-SilencingKinesisAdvantage2Keyboard_0.png","tag":["Tech"],"readingTime":5},{"title":"임베디드 AI  머신 러닝을 사용하여 배터리 충전 상태 확인 방법","description":"","date":"2024-06-30 23:36","slug":"2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning","content":"\n\n## 배터리 충전 상태(SOC)는 배터리의 잔여 전하를 총 용량의 백분율로 표시합니다. 이 정보는 내장 장치의 에너지 관리에 매우 중요합니다. SOC를 정확하게 추정하는 것은 리튬이온 배터리의 복잡한 행동에 영향을 받아 어려운 작업입니다. 이는 온도, 배터리 건강 상태, 그리고 SOC 자체와 같은 요소들에 의해 영향을 받기 때문입니다. SOC를 추정하기 위한 전통적인 방법인 전기화학 모델은 정확한 매개변수와 배터리의 조성 및 물리적 특성에 대한 심층적인 이해를 요구합니다. 반면, 머신 러닝 모델은 데이터 기반 접근 방식을 제공하여 배터리의 행동에 대해 덜 자세한 지식만으로도 SOC 추정을 단순화시키므로 내장 시스템에 구현하기에 적합합니다.\n\n![이미지](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_0.png)\n\n## 머신 러닝 과정\n\n내장형 AI 시리즈의 제1부에서, ML을 사용하여 값들을 예측하는 과정을 설명했습니다 (그림 1).\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_1.png)\n\nPart 2에서 설명한 것처럼, 배터리 방전 곡선은 대부분의 사용 가능 범위에 걸쳐 거의 선형입니다. 그러므로 우리는 Part 1에서 설명한 선형 회귀 모델을 사용할 수 있을 것입니다. 그러나 출력물은 룩업 테이블 및 보간 방법과 매우 유사할 것입니다. 더 정확하고 유연한 예측을 제공해야 할 다른 접근 방식이 있습니다.\n\n이러한 옵션을 탐색하기 위해 ML 프로세스 플로우차트의 단계를 따를 것입니다.\n\n## 단계 1 — 문제 정의\n\n\n<div class=\"content-ad\"></div>\n\n배터리의 SOC를 정확하게 예측하는 ML 모델을 개발하는 것이 목표입니다. 이 모델은 전압을 기반으로 배터리의 SOC를 예측하는 데 사용되며 전류, 온도, 그리고 시간과 같은 관련 특징도 함께 고려됩니다 (Figure 2). 모델은 다양한 작동 조건과 배터리 상태에 걸쳐 잘 일반화되어야 하며, 이는 실시간 응용 프로그램에서 신뢰할 수 있는 SOC 추정을 보장합니다.\n\nInputs and Features\n\n- Voltage (V): 배터리의 순간 전압을 나타내는 주요 입력 특징입니다.\n- Current (I): 배터리에 공급되거나 공급되는 전류로, 전압 값에 영향을 줄 수 있습니다.\n- Temperature (T): 주변 온도 또는 배터리의 온도로, 온도 변화가 배터리 성능에 영향을 줍니다.\n- Time (t): 전압이 측정된 시간으로, 배터리의 방전 또는 충전 주기를 이해하는 데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n- 전하 상태 (SOC): 배터리의 예상 SOC로서 총 용량의 백분율로 표시됩니다.\n\n![image](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_2.png)\n\n## 단계 2 — 훈련 데이터 수집 및 정리\n\n이 단계에서 가장 많은 작업을 수행하게 될 것입니다. 모델을 훈련시킬 데이터가 더 좋을수록 예측이 더 좋아질 것입니다. 우리는 맥마스터 대학교에서 발행한 LG 18650HG2 리튬이온 배터리에 대한 Digital Commons 데이터를 사용할 것입니다. 아래의 Python 스크립트를 사용하여 이 데이터셋을 다운로드할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport os\nimport requests\nimport zipfile\nimport numpy as np\n\n# 다운로드 할 파일의 URL\nurl = \"https://data.mendeley.com/public-files/datasets/cp3473x7xv/files/ad7ac5c9-2b9e-458a-a91f-6f3da449bdfb/file_downloaded\"\n\n# 추출된 ZIP 파일이 들어 있는 출력 폴더\noutput_folder = os.path.expanduser(\"~/Documents/GitHub/Embedded-AI/data/LGHG2@n10C_to_25degC\")\nos.makedirs(output_folder, exist_ok=True)\n\n# 데이터 세트 다운로드 및 추출\ntrain_folder = os.path.join(output_folder, \"Train\")\ntest_folder = os.path.join(output_folder, \"Test\")\nif not os.path.exists(train_folder) or not os.path.exists(test_folder):\n    print(\"LGHG2@n10C_to_25degC.zip (56 MB) 다운로드 중... \")\n    download_folder = os.path.dirname(output_folder)\n    filename = os.path.join(download_folder, \"LGHG2@n10C_to_25degC.zip\")\n    response = requests.get(url)\n    with open(filename, 'wb') as file:\n        file.write(response.content)\n    with zipfile.ZipFile(filename, 'r') as zip_ref:\n        zip_ref.extractall(output_folder)\n```\n\n이 스크립트에서 output_folder를 수정하여 데이터를 저장할 위치를 지정하십시오. 이 데이터를 사용하기 전에 데이터가 어떻게 구성되어 있는지 이해해야 합니다. Figure 3는 추출된 데이터 세트의 내용을 보여줍니다.\n\n<img src=\"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_3.png\" />\n\n각 파일에는 다섯 가지 예측 변수(전압, 전류, 온도, 평균 전압 및 평균 전류)로 이루어진 시계열 X와 하나의 대상 SOC로 이루어진 시계열 Y가 포함되어 있습니다. 서로 다른 환경 온도에서 수집된 데이터를 나타내는 하나의 훈련 파일과 네 개의 테스트 파일이 있습니다. 유일한 문제는 데이터가 MATLAB 형식(.mat)으로 저장되어 있다는 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n.mat 파일은 MATLAB에서 변수를 저장하는 데 사용되는 이진 데이터 파일입니다. 배열, 행렬 및 기타 데이터 유형을 저장할 수 있습니다. 이진 파일이기 때문에 텍스트 편집기에서는 읽을 수 없지만, Python의 scipy.io 모듈을 사용하여 이러한 파일을 읽고 쓸 수 있습니다.\n\n```python\nimport os\nimport scipy.io\nimport numpy as np\n\n# .mat 파일의 처음 10줄을 읽어 출력\ndef read_and_print_mat_files(folder):\n    for filename in os.listdir(folder):\n        if filename.endswith(\".mat\"):\n            filepath = os.path.join(folder, filename)\n            mat_data = scipy.io.loadmat(filepath)\n            print(f\"{filename} 내용:\")\n            for key in mat_data:\n                if not key.startswith(\"__\"):\n                    data = mat_data[key]\n                    if isinstance(data, np.ndarray) and data.ndim > 1:  \n                        print(f\"{key}:\")\n                        print(data[:10])  \n                    else:\n                        print(f\"{key}: {data}\")\n            print(\"\\n\")\n\n# 폴더 경로\ntrain_folder = os.path.expanduser(\"~/Documents/GitHub/Embedded-AI/data/LGHG2@n10C_to_25degC/Train\")\ntest_folder = os.path.expanduser(\"~/Documents/GitHub/Embedded-AI/data/LGHG2@n10C_to_25degC/Test\")\n\n# Train 및 Test 파일의 내용 읽고 출력\nprint(\"훈련 데이터 파일:\")\nread_and_print_mat_files(train_folder)\nprint(\"\\n테스트 데이터 파일:\")\nread_and_print_mat_files(test_folder)\n```\n\n훈련 데이터의 처음 다섯 행의 내용은 아래와 같이 표시됩니다.\n\n```python\nTRAIN_LGHG2@n10degC_to_25degC_Norm_5Inputs.mat 내용:\nX:\n[[0.38514793 0.38515183 0.38515573 ... 0.47884278 0.4789612  0.4789612 ]\n [0.75102009 0.75102009 0.75102009 ... 0.75102009 0.75102009 0.75102009]\n [0.30310108 0.30459129 0.3060815  ... 0.00847709 0.00847709 0.00847709]\n [0.38514793 0.38514988 0.38515183 ... 0.45983939 0.45997861 0.46011672]\n [0.75102009 0.75102009 0.75102009 ... 0.75102009 0.75102009 0.75102009]]\nY:\n[[0.20641667 0.20641667 0.20641667 ... 0.28324333 0.28324333 0.28324333]]\n```\n\n<div class=\"content-ad\"></div>\n\nX는 각 행이 다음 다섯 개의 예측변수 중 하나에 해당하는 2D 배열입니다:\n\n- 전압\n- 전류\n- 온도\n- 평균 전압\n- 평균 전류\n\n각 열은 Series에서 다른 시간점을 나타내며, 측정은 1초마다 이루어졌습니다. 예를 들어, 첫 번째 행은 전압: [0.38514793, 0.38515183, 0.38515573, …, 0.47884278, 0.4789612, 0.4789612]이고, 두 번째 행은 전류: [0.75102009, 0.75102009, 0.75102009, …, 0.75102009, 0.75102009, 0.75102009]이며, 나머지 예측변수에 대한 내용도 같은 방식입니다.\n\nY도 하나의 행으로 이루어진 2D 배열이지만, SOC가 단일 대상 변수임을 나타냅니다. 각 열은 해당 시간점에서의 SOC를 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n이제 파일 내용을 이해했으므로 훈련 및 테스트를 위해 데이터 저장소를 로드할 수 있습니다.\n\n```js\ndef read_mat_files(folder):\n    data = []\n    for filename in os.listdir(folder):\n        if filename.endswith(\".mat\"):\n            filepath = os.path.join(folder, filename)\n            mat_data = scipy.io.loadmat(filepath)\n            data.append(mat_data)\n    return data\n\n# 훈련 데이터와 테스트 데이터를 위한 파일 데이터 저장소 생성\nfds_train = read_mat_files(train_folder)\nfds_test = read_mat_files(test_folder)\n\n# 데이터 저장소에 있는 모든 데이터 읽기\ntrain_data_full = fds_train[0]\ntest_data_full_n10deg = fds_test[0]\ntest_data_full_0deg = fds_test[1]\ntest_data_full_10deg = fds_test[2]\ntest_data_full_25deg = fds_test[3]\n\n# 데이터 배열의 모양 출력하여 구조를 이해하기\nprint(\"train_data_full['X']의 모양: \", train_data_full['X'].shape)\nprint(\"train_data_full['Y']의 모양: \", train_data_full['Y'].shape)\nprint(\"test_data_full_n10deg['X']의 모양: \", test_data_full_n10deg['X'].shape)\nprint(\"test_data_full_n10deg['Y']의 모양: \", test_data_full_n10deg['Y'].shape)\n```\n\nshape 속성은 배열의 차원을 나타내는 튜플을 반환합니다. 2D 배열의 경우 shape는 (행, 열)로 이루어진 튜플을 반환합니다.\n\n```js\ntrain_data_full['X']의 모양:  (5, 669956)\ntrain_data_full['Y']의 모양:  (1, 669956)\ntest_data_full_n10deg['X']의 모양:  (5, 47517)\ntest_data_full_n10deg['Y']의 모양:  (1, 47517)\n```\n\n<div class=\"content-ad\"></div>\n\n훈련 데이터 파일 내에서, 주변 온도 측정 값은 다음과 같이 분할되어 있습니다:\n\n```js\nidx0   = 1 - 184257        # 온도 = 0°C\nidx10  = 184258 - 337973   # 온도 = 10°C\nidx25  = 337974 - 510530   # 온도 = 25°C\nidxN10 = 510531 - 669956   # 온도 = -10°C\n```\n\n우리가 출력한 훈련 데이터의 첫 5개 행을 살펴보면, X의 3번째 행이 온도를 나타냅니다. 이 값이 0이 될 것으로 예상할 수 있지만, 이 값들은 측정되고 정규화된 값입니다. 모든 예측 변수는 모델 수렴 및 성능을 향상시키기 위해 정규화되었습니다.\n\n훈련 온도 데이터 세트를 분리하려면, 아래 코드를 로딩 스크립트에 추가하십시오.\n\n<div class=\"content-ad\"></div>\n\n```js\r\n# train_data_full에서 X와 Y 추출하기\nX = train_data_full['X']\nY = train_data_full['Y']\n\n# 인덱스 범위 정의\nidx0 = slice(0, 184257)\nidx10 = slice(184257, 337973)\nidx25 = slice(337973, 510530)\nidxN10 = slice(510530, 669956)\n\n# 데이터 세그먼트 추출\nX_idx0 = X[:, idx0]\nY_idx0 = Y[:, idx0]\n\nX_idx10 = X[:, idx10]\nY_idx10 = Y[:, idx10]\n\nX_idx25 = X[:, idx25]\nY_idx25 = Y[:, idx25]\n\nX_idxN10 = X[:, idxN10]\nY_idxN10 = Y[:, idxN10]\n\n# 추출 확인을 위해 형태 출력\nprint(f'X_idx0 형태: {X_idx0.shape}, Y_idx0 형태: {Y_idx0.shape}')\nprint(f'X_idx10 형태: {X_idx10.shape}, Y_idx10 형태: {Y_idx10.shape}')\nprint(f'X_idx25 형태: {X_idx25.shape}, Y_idx25 형태: {Y_idx25.shape}')\nprint(f'X_idxN10 형태: {X_idxN10.shape}, Y_idxN10 형태: {Y_idxN10.shape}')\r\n```\n\n트레이닝 데이터에는 총 669,956개의 열이 있어서 처리하기에는 조금 많습니다. 간단하게 만들기 위해 데이터를 다시 샘플링하여 매 100번째 점을 가져와 평균 전압 및 평균 전류 예측 변수의 새로운 이동 평균값을 계산할 것입니다. 재계산된 이동 평균은 각 포인트에 대해 최근 5개 샘플을 사용합니다. 이는 i-5부터 i까지의 값들의 평균을 계산하기 위해 루프를 사용하여 수행됩니다. 이동 평균을 계산하는 데 최근 5개 샘플을 사용하는 것은 시계열 분석에서 일반적인 기술입니다. 이 접근 방식은 데이터를 부드럽게 만들면서 최근 변화에 반응성을 유지하는 균형을 제공합니다.\n\n데이터 전처리를 돕기 위해 파이썬 함수를 작성했습니다.\n\n```js\r\ndef resample_and_compute_moving_averages(X, Y, step=100):\r\n    # 데이터 재샘플링 (매 `step`번째 포인트 가져오기)\r\n    X_resampled = X[:, ::step]\r\n    Y_resampled = Y[:, ::step]\r\n    \r\n    # 새로운 이동 평균 계산\r\n    n = X_resampled.shape[1]\r\n    avg_voltage_idx = 3  # 4번째 열이 평균 전압이라고 가정\r\n    avg_current_idx = 4  # 5번째 열이 평균 전류이라고 가정\r\n    \r\n    new_avg_voltage = np.empty(n)\r\n    new_avg_current = np.empty(n)\r\n    \r\n    for i in range(n):\r\n        new_avg_voltage[i] = np.mean(X_resampled[0, max(0, i-5):i+1])\r\n        new_avg_current[i] = np.mean(X_resampled[1, max(0, i-5):i+1])\r\n    \r\n    X_resampled[avg_voltage_idx, :n] = new_avg_voltage\r\n    X_resampled[avg_current_idx, :n] = new_avg_current\r\n    \r\n    return X_resampled, Y_resampled\r\n```\n\n<div class=\"content-ad\"></div>\n\n학습 및 테스트 데이터 재샘플링은 이제 간단합니다.\n\n```js\n# 학습 데이터를 재샘플링하고 새로운 이동 평균 계산\nX_train_resampled, Y_train_resampled = resample_and_compute_moving_averages(X_train, Y_train)\n\n# 테스트 데이터 추출 및 재샘플링\nX_test_n10deg = test_data_full_n10deg['X']\nY_test_n10deg = test_data_full_n10deg['Y']\nX_test_n10deg_resampled, Y_test_n10deg_resampled = resample_and_compute_moving_averages(X_test_n10deg, Y_test_n10deg)\n\nX_test_0deg = test_data_full_0deg['X']\nY_test_0deg = test_data_full_0deg['Y']\nX_test_0deg_resampled, Y_test_0deg_resampled = resample_and_compute_moving_averages(X_test_0deg, Y_test_0deg)\n\nX_test_10deg = test_data_full_10deg['X']\nY_test_10deg = test_data_full_10deg['Y']\nX_test_10deg_resampled, Y_test_10deg_resampled = resample_and_compute_moving_averages(X_test_10deg, Y_test_10deg)\n\nX_test_25deg = test_data_full_25deg['X']\nY_test_25deg = test_data_full_25deg['Y']\nX_test_25deg_resampled, Y_test_25deg_resampled = resample_and_compute_moving_averages(X_test_25deg, Y_test_25deg)\n\n# 재샘플링 확인을 위해 형태 출력\nprint(f'재샘플링 후 학습 데이터 형태: X={X_train_resampled.shape}, Y={Y_train_resampled.shape}')\nprint(f'n10degC 테스트 데이터 형태: X={X_test_n10deg_resampled.shape}, Y={Y_test_n10deg_resampled.shape}')\nprint(f'0degC 테스트 데이터 형태: X={X_test_0deg_resampled.shape}, Y={Y_test_0deg_resampled.shape}')\nprint(f'10degC 테스트 데이터 형태: X={X_test_10deg_resampled.shape}, Y={Y_test_10deg_resampled.shape}')\nprint(f'25degC 테스트 데이터 형태: X={X_test_25deg_resampled.shape}, Y={Y_test_25deg_resampled.shape}')\n```\n\n데이터 처리 스케치의 전체 버전은 Reefwing Gist에서 제공됩니다. 데이터셋 크기를 재샘플링한 후에는 아래와 같은 크기가 됩니다.\n\n```js\n재샘플링 후 학습 데이터 형태: X=(5, 6700), Y=(1, 6700)\nn10degC 테스트 데이터 형태: X=(5, 476), Y=(1, 476)\n0degC 테스트 데이터 형태: X=(5, 443), Y=(1, 443)\n10degC 테스트 데이터 형태: X=(5, 426), Y=(1, 426)\n25degC 테스트 데이터 형태: X=(5, 393), Y=(1, 393)\n```\n\n<div class=\"content-ad\"></div>\n\n저희는 모든 전처리된 학습 및 테스트 데이터를 Preprocessed라는 새 하위 디렉토리에 저장할 거에요. 이 파일들은 CSV 형식으로 저장되며, 쉽게 읽고 쓸 수 있어서 사용자가 쉽게 확인할 수 있어요. 더 큰 데이터셋의 경우 HDF5 (계층적 데이터 형식)를 사용하면 효율적으로 대량의 데이터를 저장할 수 있고 복잡한 데이터 구조를 지원해요. 이는 과학 계산에서도 널리 사용되고 있어요. 관련 추가 코드는 아래에 나와 있어요.\n\n```js\npreprocessed_folder = os.path.join(output_folder, 'Preprocessed')\nos.makedirs(preprocessed_folder, exist_ok=True)\n\n...\n\n# 학습 데이터를 리샘플링하고 새로운 이동 평균을 계산합니다.\nX_train_resampled, Y_train_resampled = resample_and_compute_moving_averages(X_train, Y_train)\n\n# DataFrame을 생성하고 CSV로 저장합니다.\ntrain_df = pd.DataFrame(np.vstack((X_train_resampled, Y_train_resampled)).T,\n                        columns=['Voltage', 'Current', 'Temperature', 'Average Voltage', 'Average Current', 'SOC'])\ntrain_df.to_csv(os.path.join(preprocessed_folder, 'resampled_training_data.csv'), index=False)\n\n# 테스트 데이터를 추출하고 리샘플링합니다.\ntest_data_files = ['n10degC', '0degC', '10degC', '25degC']\nresampled_test_data_shapes = {}\n\nfor i, test_data_full in enumerate(fds_test):\n    X_test = test_data_full['X']\n    Y_test = test_data_full['Y']\n    X_test_resampled, Y_test_resampled = resample_and_compute_moving_averages(X_test, Y_test)\n    test_df = pd.DataFrame(np.vstack((X_test_resampled, Y_test_resampled)).T,\n                           columns=['Voltage', 'Current', 'Temperature', 'Average Voltage', 'Average Current', 'SOC'])\n    test_df.to_csv(os.path.join(preprocessed_folder, f'resampled_test_data_{test_data_files[i]}.csv'), index=False)\n    resampled_test_data_shapes[test_data_files[i]] = (X_test_resampled.shape, Y_test_resampled.shape)\n```\n\n## 단계 3 — 모델 선택\n\n배터리 충전 상태 (SOC) 및 건강 상태 (SOH)를 추정하기 위해 여러 머신러닝 알고리즘이 광범위하게 연구되어 왔습니다. 네 가지 가장 탁월한 유형은 얕은 신경망 (NN), 딥러닝 (DL), 서포트 벡터 머신 (SVM), 그리고 가우시안 프로세스 회귀 (GPR)입니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_4.png)\n\n얕은 신경망(SNN)\n얕은 신경망(Figure 4)은 한 개 또는 두 개의 은닉층으로 구성됩니다. 딥 러닝과 비교하면 비교적 단순하지만 전력 특성의 비선형성을 모델링하기에 충분히 강력합니다. 단층 신경망은 더 간단한 구조로, 계산 능력과 메모리가 덜 필요하여 자원 제한적인 임베디드 장치에서 실시간 SOC 및 SOH 추정에 적합합니다. 이러한 모델은 전압, 전류, 온도와 같은 다양한 입력 특성으로부터 SOC 및 SOH를 예측하는 데 학습될 수 있습니다.\n\n![이미지](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_5.png)\n\n딥 러닝(DL)\n딥 러닝 모델인 딥 신경망(DNNs — Figure 5) 및 합성곱 신경망(CNNs)과 같이 여러 층을 가지고 있어 데이터의 복잡한 패턴과 상호작용을 포착할 수 있습니다. DL 모델은 입력 특성과 SOC 또는 SOH 사이의 복잡한 관계를 학습하여 매우 정확한 추정을 제공할 수 있습니다. 그러나 그들의 복잡성은 더 많은 계산 자원과 메모리를 필요로 하며, 이는 일부 임베디드 시스템에 제약 요인이 될 수 있습니다. 그러나 임베디드 하드웨어의 발전으로 실시간 응용 프로그램에서 딥 러닝 모델을 배포하긴 점점 더 가능해지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![SVM](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_6.png)\n\n서포트 벡터 머신(SVM)\n서포트 벡터 머신(도표 6)은 분류와 회귀 작업 모두에 사용할 수 있는 지도 학습 모델입니다. SOC 및 SOH 추정을 위해 SVM은 고차원 데이터를 효과적으로 처리할 수 있으며, 특히 훈련 데이터가 제한적인 상황에서 과적합에 강합니다. SVM은 데이터를 서로 다른 클래스로 분리하거나 연속 값을 예측하는 데 최적의 초평면을 찾아 작동합니다. 상대적으로 낮은 계산 요구로 인해 리소스가 제한된 임베디드 응용 프로그램에 적합합니다.\n\n![GPR](/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_7.png)\n\n가우시안 프로세스 회귀(GPR)\n가우시안 프로세스 회귀(도표 7)는 예측 뿐만 아니라 불확실성 추정을 제공하는 비모수적인 확률적 접근 방식입니다. SOC 및 SOH 추정에 특히 유용한 GPR은 운영 조건 및 노화로 인한 배터리 행동의 기저 불확실성을 모델링할 수 있습니다. GPR 모델은 유연하며 새로운 데이터로 업데이트할 수 있어, 배터리 수명 주기 내의 변화에 적응할 수 있습니다. 이러한 이유로 GPR 모델을 채택하여 구현하기로 결정했습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 GPR은 계산이 많이 필요하며, 실시간 임베디드 애플리케이션에 적합하게 만들기 위해 효율적인 구현이 필요합니다. 또는 장치 외부에서 처리를 수행하고 최적화된 후에 훈련된 모델을 배포할 수도 있습니다. 이것이 우리가 취할 접근 방식입니다.\n\n## 파트 4\n\n시리즈의 제 4부에서 배터리 SOC 예측기의 ML 프로세스를 계속할 것입니다. 이는 모델을 훈련하고 evaluate하는 데 중점을 둘 것입니다.\n\n## 참고문헌\n\n<div class=\"content-ad\"></div>\n\n[1] Kollmeyer, Philip; Vidal, Carlos; Naguib, Mina; Skells, Michael (2020), “LG 18650HG2 Li-ion Battery Data and Example Deep Neural Network xEV SOC Estimator Script”, Mendeley Data, V3, doi: 10.17632/cp3473x7xv.3\n\n만약 이 글을 즐겁게 보셨고 제 글쓰기를 지원하고 싶으시다면, 팔로우를 누르거나 (최대 50번), 강조하기, 혹은 댓글을 남겨주세요! 혹은 다른 방법으로 커피를 사주시거나 구독해주셔도 됩니다. 새 글이 올라올 때마다 이메일을 받아보실 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_0.png"},"coverImage":"/assets/img/2024-06-30-3EmbeddedAIBatteryStateofChargeusingMachineLearning_0.png","tag":["Tech"],"readingTime":15},{"title":"3D 프린팅의 현황 복잡성과 도전 과제 탐구하기","description":"","date":"2024-06-30 23:34","slug":"2024-06-30-TheStateof3DPrintingNavigatingtheComplexityandChallenges","content":"\n\n지난 10년 동안 3D 프린팅 기술은 많이 발전해 왔습니다. 하지만 저처럼 산업에 오래 종사한 분들은 여전히 극복해야 할 중요한 과제들이 있다는 것을 아실 것입니다. 특히 제가 창업한 3D 프린팅 스타트업은 특정 응용 프로그램 요구 사항을 위한 센서 및 소프트웨어를 만드는 데 초점을 맞추고 있어, 현재 3D 프린팅 분야의 역동성과 복잡성을 직접 경험해왔습니다.\n\n<img src=\"/assets/img/2024-06-30-TheStateof3DPrintingNavigatingtheComplexityandChallenges_0.png\" />\n\n# 3D 프린팅과 어셈블리 코드: 복잡한 병행\n\n현재 3D 프린팅 기술을 되새겨보면서, 초창기 어셈블리 코드로 프로그래밍하는 것과 유사한 점을 느낍니다. 어셈블리 코드는 컴퓨터 아키텍처에 대한 상세한 지식이 요구되는 저수준 프로그래밍 언어입니다. 어셈블리 코드를 사용하여 프로그램을 작성하는 것은 세심한 작업이며, 모든 명령이 명시적으로 기술되어야 하기 때문에 실수할 여지가 거의 없습니다.\n\n<div class=\"content-ad\"></div>\n\n현재 3D 프린터를 설정하고 유지하는 것도 복잡하고 요구가 높은 작업일 수 있습니다. 각 기계마다 독특한 특징과 조정이 필요한 설정이 있어서 최적의 결과를 얻으려면 세밀한 조정이 필요합니다. 표준화된 프로토콜의 부재로 인해 사용자들은 종종 기계의 펌웨어와 구성 설정에 심취해야 합니다, 마치 어셈블리 코드를 다루는 프로그래머처럼요.\n\n비교를 위해 어셈블리와 G코드에서 각각 두 가지 짧은 예시가 아래에 나와 있습니다.\n\n```js\nsection .data\n    msg db 'Hello, World!',0x0a ; 프린트할 메시지\n\nsection .bss\n\nsection .text\n    global _start\n\n_start:\n    ; 메시지 프린트\n    mov eax, 4          ; sys_write의 시스템 콜 번호\n    mov ebx, 1          ; 파일 서술자 1은 표준 출력\n    mov ecx, msg        ; 메시지의 포인터\n    mov edx, 13         ; 메시지의 길이\n    int 0x80            ; 커널 호출\n\n    ; 프로그램 종료\n    mov eax, 1          ; sys_exit의 시스템 콜 번호\n    xor ebx, ebx        ; 반환 값 0\n    int 0x80            ; 커널 호출\n```\n\n```js\n; G코드 시작\nG28 ; 모든 축 원점 복귀\nG21 ; 단위를 밀리미터로 설정\nG90 ; 절대 위치 지정 사용\nM82 ; 외출시 등 분모를 절대 모드로 설정\n\n; 프린팅 시작\nG1 Z0.2 F300 ; 시작 높이로 이동\nG92 E0 ; 외출시 초기화\nG1 F140 E30 ; 140 mm/min 속도로 30mm 필라멘트 밀어내기\nG1 F3000 ; 이후 동작 속도 설정\n\n; 선 그리기\nG1 X50 Y50 Z0.2 F1500 ; 시작점으로 이동\nG1 X150 Y50 E15 ; 15mm 필라멘트를 밀어내면서 선 긋기\nG1 X150 Y150 E30 ; 다음 지점으로 이동하면서 외출시하기\n\n; G코드 종료\nG1 F140 E-3 ; 필라멘트 되감기\nG28 ; 모든 축 원점 복귀\nM84 ; 모터 비활성화\n```\n\n<div class=\"content-ad\"></div>\n\n# 프린터 설정: 초기 2D 프린터의 메아리\n\n스탠다드 드라이버가 2D 인쇄를 간편하게 만들기 전 날들을 기억하십니까? 그때는 프린터 설정이 수동으로 드라이버를 설치하고 다양한 호환성 문제를 해결해야 했기 때문에 불편한 작업이었습니다. 현재 3D 프린터 설정 상태는 그 시대를 연상시킵니다.\n\n기술 발전에도 불구하고, 3D 프린터 설정 프로세스는 여전히 상당한 장벽으로 남아 있습니다. 각 프린터 모델은 고유의 설명서가 있으며, 신뢰할 수 있는 인쇄물을 얻기 위해서는 가파른 학습 곡선이 필요합니다. 이 상황은 다수의 일반적인 해결책이 존재하나, 주로 취미가인을 위해 제공되어 전문가와 산업 사용자의 특정 요구를 해결하지 못하고 있다는 점에서 악화되고 있습니다.\n\n# 🤔 왜요?\n\n<div class=\"content-ad\"></div>\n\n# 코드의 높은 비용과 자동화에 미치는 영향\n\n3D 프린팅 분야의 발전을 방해하는 또 다른 중요한 문제는 미국에서 안정적인 소프트웨어를 개발하는 높은 비용입니다. 이로 인해 우리는 자동화와 고품질, 신뢰성 높은 3D 프린터 개발에서 뒤처지고 있습니다. 3D 프린팅과 같이 복잡한 산업에서 강력하고 자동화된 솔루션이 필수적입니다.\n\n현재 많은 솔루션이 일반화되어 \"한 사이즈가 모든 것에 맞는\" 것으로 설계되어 있습니다. 이러한 접근은 취미로 하는 사람들에게는 도움이 되겠지만, 특정 응용 요구 사항이 있는 사람들에게는 부족합니다. 저희 스타트업은 \"생활 품질 툴킷\"을 만드는 데 집중하고 있습니다. 캘리브레이션, 재료 튜닝, 부분 내부 검사, 그리고 실시간 동적 Gcode™ 조정과 같은 일반적이고 귀찮은 작업을 간소화하는 것을 목표로 합니다. 맞춤 솔루션을 제공함으로써 산업 간극을 메우고 산업을 발전시키는데 기여하길 희망합니다.\n\n# 앞으로 전망: 특화된 솔루션이 필요한 이유\n\n<div class=\"content-ad\"></div>\n\n앞으로 나아가면서, 3D 프린팅 산업은 보다 특화된 응용 프로그램별 솔루션을 개발하는 것이 중요합니다. 2D 프린팅에서 표준 드라이버가 혁명을 일으킨 것처럼, 3D 프린팅 영역에서도 기술을 더 접근 가능하고 신뢰할 수 있게 만들기 위해 유사한 발전이 필요합니다.\n\n우리가 스타트업에서 한 여정은 이러한 도전에 직면하고자 하는 열망으로 인해 이뤄졌습니다. 특정 요구 사항을 충족시키는 센서와 소프트웨어에 집중함으로써, 우리는 보다 체계적이고 효율적인 3D 프린팅 경험을 만들기 위해 노력하고 있습니다. 이제는 일반화된 솔루션 시대를 넘어서 전문화되고 신뢰할 수 있으며 자동화된 3D 프린팅 기술의 미래를 받아들이는 때입니다.\n\n# 시장 역학에 대한 답답함과 전략적 영향\n\n마지막으로 언급하고 싶은 것은 중국이 3D 프린팅 기술에서 미국 기업들을 완전히 압도하고 있다는 점에 대한 저의 답답함입니다. Bambu Labs와 같은 기업들이 소개하는 혁신들은 솔직히 미국 기업들이 여러 년 전에 개발하고 상용화했어야 했던 것들입니다. 만약 우리가 중국과 전쟁을 벌인다면, 빠르고 저렴하게 더 많은 제품을 만들어야 승리할 수 있습니다. 현재 그들은 그 측면에서 우리보다 더 뛰어나죠.\n\n<div class=\"content-ad\"></div>\n\n미국에서 자동화 및 신뢰할 수 있는 기술에 투자가 부족하고 고비용 때문에 우리가 얼마나 뒤쳐져 있는지 보는 것은 마음이 아프다. 3D 프린팅 산업에서 우리의 선두지위를 되찾으려면 혁신, 비용 효율적인 개발, 전문가와 산업 사용자들의 특별한 요구를 해결하는 데 초점을 맞춰야 한다.\n\n## 신기함보다 신뢰할 것의 문제\n\n창업 투자와 컨퍼런스의 세계에서는 종종 가장 주목을 끄는 것이 곧은 새로운 기기와 혁신이다. 그러나 최신과 가장 좋은 것에 초점을 맞추는 것은 종종 신뢰성에 대가가 따른다. 3D 프린팅 산업은 자주 \"문제를 찾는 해결책\"으로 묘사된다. 기업들이 자본 장비에 의존할 수 없을 때, 진정한 진전을 위해 화려한 프로토타입에서 실제 응용에서 지속적으로 성능을 발휘할 수 있는 견고하고 신뢰할 수 있는 기계로의 중점을 옮겨야 한다.\n\n해당 주제에 대한 생각과 경험을 자유롭게 공유해 주세요. 3D 프린팅에서 직면한 가장 큰 문제는 무엇인지, 어떻게 그 문제들을 해결할 수 있을지 생각해 보세요.","ogImage":{"url":"/assets/img/2024-06-30-TheStateof3DPrintingNavigatingtheComplexityandChallenges_0.png"},"coverImage":"/assets/img/2024-06-30-TheStateof3DPrintingNavigatingtheComplexityandChallenges_0.png","tag":["Tech"],"readingTime":4},{"title":"파라향 글꼴","description":"","date":"2024-06-20 06:32","slug":"2024-06-20-ParaHyangFont","content":"\n\nEnhance your design projects with the versatile Para Hyang Font. Download and preview it for free using our powerful text font generator, or purchase the full version with a commercial license here.\n\nWhy Choose Para Hyang Font?\n\n- Free Download: Get the Para Hyang Font for free and start using it in your projects immediately.\n- Versatile Use: Perfect for personal and commercial projects, including websites, graphic design, and digital presentations.\n- Lightweight Package: At just 56.2 KB, this font is easy to download and manage.\n- Easy Compatibility: Available in OTF and TTF format, compatible with most design software.\n- Simple Installation: With only 2 file(s) to install, integrating Para Hyang Font into your workflow is effortless.\n\nFont Details:\n\n<div class=\"content-ad\"></div>\n\n- 디자이너: Vunira Design\n- 무게: 400\n- 버전: 버전 1.000\n- 저작권: 2020년 Vunira Design에 의해 저작권 소유. 모든 권리 보유.\n- 지원 언어: 119개 언어\n\n프로젝트에 독특한 감성을 더할 수 있는 기회를 놓치지 마세요. Para Hyang 폰트를 지금 다운로드하여 창의적 작업을 높이세요!\n\n![ParaHyangFont_0.png](/assets/img/2024-06-20-ParaHyangFont_0.png)\n\n![ParaHyangFont_1.png](/assets/img/2024-06-20-ParaHyangFont_1.png)\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-20-ParaHyangFont_2.png)\n\nVunira Design의 CreativeFabrica에서 제공한 사진입니다.\n\n참고: 본 문서에는 제휴 링크가 포함되어 있습니다. 이 링크를 클릭하고 구매를 하시면 저희가 수수료를 받을 수 있습니다. 이는 별도의 비용이 추가되지 않으며, 당신의 컨텐츠 작성을 지원하는 데 도움이 됩니다. 지원해 주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-06-20-ParaHyangFont_0.png"},"coverImage":"/assets/img/2024-06-20-ParaHyangFont_0.png","tag":["Tech"],"readingTime":2},{"title":"씨즈 오브 톤 미션","description":"","date":"2024-06-20 06:32","slug":"2024-06-20-ThemissionofSeedsofTON","content":"\n\n씨드는 스타트업 게임 프로젝트이지만, 어떤 사람들은 그냥 지루한 게임일 뿐이라고 생각할 수 있고 크게 기대하지 않을 수도 있어요. \n\n그러나 실제로 씨드는 당신이 자신만의 소셜 플랫폼을 구축하고 전체 프로젝트에 기여할 수 있는 독특한 소셜 세계예요.\n\n씨드는 지루한 게임이 아니라, 더 많은 친구들을 사귈 수 있고 친구들과 행복한 집을 짓는 소셜 세계예요.\n\n우리의 미션은 모두가 WEB3의 도입에 대해 이야기하는 것 이상의 것이에요.\n\n<div class=\"content-ad\"></div>\n\n우리의 진정한 미션은 여러분이 성장하고 배우며 더 많은 친구를 사귀고 가장 가까운 커뮤니티를 형성하는 데 도움을 주는 것입니다.\n\n우리의 미션은 소셜 지식을 전파하고 친구들 사이에 행복을 나누는 것입니다.\n\nSeed에서 더 많은 회원들이 친구가 되고 소셜 전문가가 되기를 원합니다.\n\n이 커뮤니티의 일원이 되어 주셔서 모두 감사드리며, 우리는 여러분을 실망시키지 않을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-ThemissionofSeedsofTON_0.png\" />\nTelegram: t.me/SeedsofTON\nTwitter: https://x.com/SeedsofTon\nWebsite: https://www.seedsofton.xyz/","ogImage":{"url":"/assets/img/2024-06-20-ThemissionofSeedsofTON_0.png"},"coverImage":"/assets/img/2024-06-20-ThemissionofSeedsofTON_0.png","tag":["Tech"],"readingTime":1},{"title":"자주 와이어프레임을 스케치해야 하는 이유","description":"","date":"2024-06-20 06:31","slug":"2024-06-20-Whyyoumustsketchwireframesoften","content":"\n\n## 왜 종이와 펜이 최고인가\n\n![image](/assets/img/2024-06-20-Whyyoumustsketchwireframesoften_0.png)\n\n나는 와이어프레임 스케치를 좋아해. 왜? 다양한 솔루션을 제시하고 그들이 결과를 도출하는 걸 테스트할 수 있어. 디자이너들은 와이어프레임을 통해 최선의 방법을 찾기 위해 다양한 접근법을 시각화할 수 있어.\n\n이미 알고있다면 와이어프레임 작성은 치유 되기도 해. 특히 용도를 이해한다면.\n\n<div class=\"content-ad\"></div>\n\n# 디자이너들이 아이디어를 불러일으키는 데 완벽한 통제권을 부여하는 자유로운 과정입니다.\n\n나는 특히 나 같은 새로운 UX 디자이너를 위한 몇 가지 권고사항을 공유하고 싶어요. 이러한 포인트들은 나의 자신감을 향상시키고 이 동적인 결과물을 감상하게 했습니다:\n\n- '멋진 작업을 하지 않아도 괜찮아하다는 것을 두려워하지 마세요'\n와이어프레임은 아이디어를 테스트하는 것이 주된 기능이기 때문에 아름답지 않아도 괜찮습니다. 처음 와이어프레임을 스케치해야 한다는 것에 불안해했어요. 지저분하게 그리고 예쁘지 않게 보일까 걱정했죠. 그러나 저를 '이렇게 되어야 한다'라고 안심시켜준 시니어 동료와 Kelly Gordon의 글은 저에게 많은 자신감을 주었습니다.\n\n- '반복 없는 와이어프레임은 영혼 있는 몸체와 같다'\n와이어프레임은 완벽하지 않아도 되는데, 이는 다양한 경로를 테스트할 수 있게 해주며 이는 아주 강력한 것입니다. 디자인이 다양한 흐름과 패턴에서 어떻게 동작할지 볼 수 있습니다. 그래서 이터레이션을 진행해보세요 - 다양한 방식으로 엘리먼트를 가져와 배치할 두레 이겁니다.\n\n- '픽셀보다 종이가 앞서다'\nMike Rohde를 들으면서, 종이와 펜으로 와이어프레임을 그리는 게 가장 좋다는 것을 이해했어요; 종이와 펜이 부족해지는 일은 없고, 시간을 아낄 수도 있습니다. 다른 디자이너들에게 아이디어를 스케치하기 위해 종이를 사용하자고 이야기해요, 소프트웨어는 우리를 제약하기 마련이니까요. 다양한 개념을 탐구하려면 종이와 펜을 사용해보세요.\n\n요약하자면, 디자이너에게 와이어프레임을 자주 스케치하는 것은 불가피합니다. 이는 아이디어를 빠르게 명확히 하고, 커뮤니케이션을 향상시키며, 시간과 자원을 절약하며, 창의성을 증진시킵니다. 사용자 경험에 초점을 맞추고, 협업을 단순화시키며, 이터레이티브 디자인을 지원합니다. 그래서 펜을 들고 스케치를 시작해보세요 - 결과에 깜짝 놀라실 거예요.","ogImage":{"url":"/assets/img/2024-06-20-Whyyoumustsketchwireframesoften_0.png"},"coverImage":"/assets/img/2024-06-20-Whyyoumustsketchwireframesoften_0.png","tag":["Tech"],"readingTime":2},{"title":"사용자 경험은 인간의 본성에 관한 것입니다","description":"","date":"2024-06-20 06:29","slug":"2024-06-20-Userexperienceisabouthumannature","content":"\n\n![User Experience](/assets/img/2024-06-20-Userexperienceisabouthumannature_0.png)\n\n\"UX가 정말 무엇을 의미하는 걸까요? 사용자 경험(UX)은 사람들이 목표를 달성하기 편리하도록 만드는 것입니다. 이것이 UX의 본질이에요.\n\n하지만 이를 위해 사람들은 종종 물리적 객체, 디지털 응용프로그램, 서비스, 텍스트 등과 상호 작용해야 할 필요가 있어요. 그러므로 이러한 요소들을 설계하여 원활하고 쉬운 상호 작용을 보장하는 것이 훌륭한 UX를 만드는 핵심이에요.\n\n어떤 것이 좋은 사용자 경험을 만들어낼까요?\"\n\n<div class=\"content-ad\"></div>\n\n앱, 서비스 또는 물리적 객체를 디자인하느냐에 따라 달라질 것 같지만, 우리가 무엇을 디자인하느냐에 따라 좋은 사용자 경험을 얻기 위한 지침이 있습니다. 하지만 이러한 요소들 — 무엇이든 간에 — 공통적인 요소가 있습니다:\n\n이러한 요소들의 뒤에 있는 사람입니다.\n\n그래서, 우리가 어떻게 사람으로서 작동하는지를 이해하는 것은 직관적이고 효율적인 사용자 경험을 디자인하는 데 필수적인 기반이 됩니다. 이제 우리가 바로 다루어볼 내용입니다.\n\n# 시장 문제\n\n<div class=\"content-ad\"></div>\n\n저희가 다음과 같은 시장에 도착한다고 상상해 봅시다:\n\n![이미지](/assets/img/2024-06-20-Userexperienceisabouthumannature_1.png)\n\n빠르게 한 눈에 살펴보면 우리 뇌에서 많은 일이 벌어집니다:\n\n- 우리는 장면 속 물체를 인식합니다: 사람, 개, 가게, 차량, 건물..\n- 각각의 색상, 모양, 질감을 인식합니다.\n- 거리를 추정합니다: 배경에 있는 건물은 시장의 장볼스보다 훨씬 멀리 떨어져 있습니다.\n- 상대적인 크기를 계산합니다: 나무는 시장의 장볼스보다 훨씬 더 큽니다.\n- 그 밖에도 다양한 것들이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그리고 우리는 이 모든 것을 몇 초 안에 처리해요.\n\n복잡한 문제를 해결하기 위해 누군가가 전화로 우리에게 전화를 걸어도, 전화 통화를 하면서도 모든 일을 처리할 수 있어요.\n\n우리 두뇌가 이 모든 것을 해낸다는 것은 우리가 시장을 성공적이고 안전하게 탐험하고 목표를 이루기 위해 걸어다니거나 뭔가를 사기 위해 가능하게 해 준 것이에요.\n\n이제 시장을 떠나기 위해 거리를 건너야 한다고 상상해봐요.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-20-Userexperienceisabouthumannature_2.png)\n\n매우 간단하죠? 그렇게 보이지만요.\n우리는 매일 안전하게 이를 할 수 있습니다. \n\n하지만 이것이 간단한 일은 아닙니다.\n\n이를 성공적으로 수행하려면 우리의 걷는 속도를 알아야 하고, 거리를 추정해야 하며, 다가오는 차량의 속도를 판단하고, 마지막으로 우리의 걷는 속도가 차량이 횡단로에 도달하기 전에 그 거리를 건너기에 적합한지 계산해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n위에 설명된 모든 상황이 다양한 문제를 해결하는 것과 관련이 있지만, 우리에게 많은 노력이 필요하지 않습니다.\n\n- 사전 지식이 필요하지 않습니다.\n- 너무 많은 집중력이 필요하지 않습니다.\n- 매우 빨리 해결합니다.\n- 계속해서 해결하는 것에 지루하지 않습니다.\n\n우리가 문제를 해결하고 있다는 것에 대해 심지어 자각하지 못합니다!\n\n이제 다른 이 문제를 해결해야 한다고 상상해보세요:\n\n<div class=\"content-ad\"></div>\n\n# **삼각형 문제**\n\n직각 삼각형에서, 빗변 c의 제곱이 다른 두 변의 제곱의 합과 같음을 증명해보세요.\n\n<img src=\"/assets/img/2024-06-20-Userexperienceisabouthumannature_3.png\" />\n\n이 작업은 꽤 어려울 수 있어요, 그렇죠?\n기하학에 대한 사전 지식, 문제에 집중하는 노력, 심각한 인지 노력, 그리고 해결하기 위해 헌신적인 시간이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n당연히 삼각형 문제보다 시장 문제를 해결하는 것이 훨씬 더 쉽다는 건 맞죠?\n\n왜 그런 걸까요?\n\n시장 문제가 더 간단한가요? 제 생각에는 아니에요. 그것은 삼각형 문제보다 훨씬 복잡합니다.\n\n하지만, 인간에게는 훨씬 더 간단하죠.\n\n<div class=\"content-ad\"></div>\n\n왜요?\n\n그 이유를 더 잘 이해하기 위해 다른 시나리오를 살펴봅시다.\n\n# 사자 문제\n\n출처: '<table>'를 마크다운 형식으로 변경합니다.\n\n상상해보세요. 10만 년 전에 세계 가운데 사바나를 걸어가던 조상인 호모 사피엔스였다가 갑자기 이것이 나타난다면요.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-20-Userexperienceisabouthumannature_4.png)\n\n이제 사자인 것을 식별하는 데 지연이 생긴다면 어떻게 될지 상상해 보세요. 사자가 여러분에게 다가오는 속도와 거리를 빨리 계산하지 못할 때. 이전 정보를 기반으로 하여 도망치거나 숨거나 복종해야 하는지 결정할 수 없을 때.\n\n어떤 일이 일어날 수 있을까요?\n상상하고 생각하기는 쉬워요.\n\n하지만 여전히 여기 있잖아요? 진화와 자연 선택은 이러한 상황에 성공적으로 대처할 수 있는 기술을 우리에게 제공했습니다. 우리의 생존은 이에 달려 있습니다. 우리는 사자 유형의 문제를 해결하기 위한 적응형 기술을 개발했습니다.\n\n<div class=\"content-ad\"></div>\n\n이런 기술들이 정확히 무엇인가요?\n\n우리는 사자(와 다른 것들)를 인식하고, 속도와 거리를 계산하며, 이 정보를 바탕으로 결정을 내리는 등의 기술을 능숙하게 수행합니다. 그리고 이 모든 것을 아주 빠르게 처리할 수 있어요.\n\n이 문제에 필요한 기술들은 시장 문제를 해결하는 데 필요한 기술과 동일하기 때문에, 우리는 시장 문제를 해결하는 데도 능숙합니다.\n\n삼각형 문제로 돌아가봅시다.\n\n<div class=\"content-ad\"></div>\n\n삼각형 문제를 해결하는 방법을 알고 있죠, 맞죠? 하지만 이 문제는 훨씬 더 많은 것을 요구할 거에요: 많은 노력, 많은 시간, 그리고 많은 지식이 필요하죠.\n\n왜냐하면 이것은 현대적인 문제이기 때문이에요.\n\n과거에는 생존을 위해 삼각형 문제를 풀 필요가 없었기 때문에 우리의 두뇌는 특별한 기술을 개발하지 않았어요.\n\n<div class=\"content-ad\"></div>\n\n저희가 진화과정에서 삼각형 문제 해결을 위한 특정 기술을 발전시키지 않았다면 어떻게 해결할 수 있을까요?\n\n답은 간단합니다: 사자류 문제 해결을 위해 발전시킨 동일한 기술을 사용합니다.\n\n그러나 이러한 기술들은 매우 다른 목적을 위해 진화했기 때문에 삼각형 문제를 해결하는 데 훨씬 더 많은 인지적 노력과 시간이 필요합니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n사용자 경험은 말 그대로 사람들이 목표를 달성하기를 매우 쉽게 만드는 것입니다.\n\n사용자 경험 분야를 숙달하기 위해서는 인간의 인지 능력, 한계 및 우리의 인지 과정에 대한 깊은 이해가 필수적입니다.\n\n이 글에서 우리는 이러한 것들 중 일부를 이해하기 시작했습니다.\n다음 글에서는 인간의 인지 능력을 자세히 살펴보겠습니다: 우리가 뛰어나다고 생각되는 부분과 그렇지 않은 부분을 구분하는 것이 중요합니다.\n\n이를 통해 우리는 우리의 강점을 활용하고 약점에 의존할 필요를 최소화하는 애플리케이션 또는 사람들이 상호 작용해야 하는 모든 것을 만들 수 있을 것입니다.","ogImage":{"url":"/assets/img/2024-06-20-Userexperienceisabouthumannature_0.png"},"coverImage":"/assets/img/2024-06-20-Userexperienceisabouthumannature_0.png","tag":["Tech"],"readingTime":4},{"title":"킹스턴 시그니처 폰트","description":"","date":"2024-06-20 06:28","slug":"2024-06-20-KingstonSignatureFont","content":"\n\n다양한 디자인 프로젝트에서 유연하게 활용할 수 있는 킹스턴 시그니처 폰트로 디자인을 강화하세요. 강력한 텍스트 글꼴 생성기를 사용하여 무료로 다운로드하고 미리보기하거나 여기에서 상업적 라이선스로 전체 버전을 구입하세요.\n\n킹스턴 시그니처 폰트를 선택하는 이유는?\n\n- 무료 다운로드: 킹스턴 시그니처 폰트를 무료로 다운로드하고 즉시 프로젝트에 사용하세요.\n- 다양한 용도: 웹사이트, 그래픽 디자인, 디지털 프레젠테이션을 포함한 개인 및 상업용 프로젝트에 완벽히 어울립니다.\n- 가벼운 패키지: 단 51.9 KB의 용량으로 쉽게 다운로드하고 관리할 수 있습니다.\n- 쉬운 호환성: 대부분의 디자인 소프트웨어와 호환되는 OTF 및 TTF 형식으로 제공됩니다.\n- 간편한 설치: 설치할 파일이 2개뿐이기 때문에 킹스턴 시그니처 폰트를 워크플로에 통합하는 것이 매우 간단합니다.\n\n글꼴 세부정보:\n\n<div class=\"content-ad\"></div>\n\n- 서브 패밀리: Regular\n- 무게: 400\n- 버전: 버전 1.004; Fontself Maker 3.5.4\n- 저작권: Alpaprana Studio © 2021\n- 지원되는 언어: 199개 언어\n\n프로젝트에 독특한 감성을 더하고 싶지 않으세요? 지금 \"킹스턴 서명체 폰트\"를 다운로드하여 창의적인 작업을 높여보세요!\n\n![이미지](/assets/img/2024-06-20-KingstonSignatureFont_0.png)\n\n![이미지](/assets/img/2024-06-20-KingstonSignatureFont_1.png)\n\n<div class=\"content-ad\"></div>\n\n![2024-06-20-KingstonSignatureFont_2](/assets/img/2024-06-20-KingstonSignatureFont_2.png)\n\nPhoto by CreativeFabrica\n\n참고: 본 기사에는 제휴 링크가 포함되어 있습니다. 이 링크를 클릭하고 구매를 하게 되면, 우리는 커미션을 받을 수 있습니다. 이 커미션은 여러분들에게 추가 비용이 발생하지 않습니다. 더불어, 이는 저희의 콘텐츠 제작에 도움을 주며 여러분의 지원에 감사드립니다.","ogImage":{"url":"/assets/img/2024-06-20-KingstonSignatureFont_0.png"},"coverImage":"/assets/img/2024-06-20-KingstonSignatureFont_0.png","tag":["Tech"],"readingTime":2}],"page":"1","totalPageCount":18,"totalPageGroupCount":1,"lastPageGroup":18,"currentPageGroup":0},"__N_SSG":true}